+ python -u funsearch_bin_packing_llm_api.py
launch 1 evaluate tasks
INFO:absl:Best score increased to -500.0
current thread_i 0
current thread_i 1
current thread_i 2
current thread_i 3
current thread_i 4
current thread_i 5
current thread_i 6
current thread_i 7
current thread_i 8
current thread_i 9
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...
-----------------------
-----------------------
request...-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
request...
-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


----------------------------------------------


-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------request...
-----------------------request...
request...
-----------------------



import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------
-------------------
    """Returns priority with which we want to add item to each bin.
    
    This version introduces a novel strategy that considers:
    1. Immediate spatial fit (how well the item fits in the bin)
    2. Future packing potential (how much space is left for future items)
    3. A tunable balance between these two factors
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
        
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate immediate fit metric
    # Higher priority for better spatial fit
    spatial_fit = bins - item
    spatial_priority = np.where(spatial_fit > 0, spatial_fit, 0)
    
    # Calculate future potential metric
    # Higher priority for bins that leave more space for future items
    future_space = bins - item
    future_priority = future_space ** tunable(['linear', 'quadratic', 'cubic'])
    
    # Combine metrics with tunable weight
    future_importance = tunable([0.2, 0.5, 0.8])
    combined_priority = (
        (1 - future_importance) * spatial_priority +
        future_importance * future_priority
    )
    
    # Penalize very small remaining capacities to avoid "wasted" space
    min_desired_capacity = tunable([0.1, 0.2, 0.3])
    remaining_capacity_penalty = np.where(
        future_space < min_desired_capacity,
        tunable([0.1, 0.5, 1.0]) * (min_desired_capacity - future_space),
        0
    )
    
    final_priority = combined_priority - remaining_capacity_penalty
    
    return final_priority

call llm times: 1
-------------------


............................................
launch 64 evaluate tasks
current thread_i 2
current thread_i 5
this best socre: -10000000000.0; best score: -10000000000.0; global score: -10000000000.0; space size: 81; measure cnt: 64
.............................................................................................................................................................................................
launch 17 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -10000000000.0; space size: 81; measure cnt: 81
sampler suggest should end sample, break
-------------------
    """Improved priority function for bin-packing that balances:
    1. Spatial fit: How well the item fits in the bin
    2. Future potential: How much capacity remains for future items
    
    The priority score combines these two factors with tunable weights.
    """
    # Spatial fit component: Reward bins where item fits well, but don't penalize too heavily for larger bins
    spatial_fit = 1 / (1 + (item / (bins + 1e-10)))  # Add small epsilon to avoid division by zero
    
    # Future potential component: Reward bins that leave enough capacity for future items
    remaining_capacity = bins - item
    capacity_ratio = remaining_capacity / np.max(remaining_capacity)  # Normalize
    future_potential = np.where(remaining_capacity > 0, capacity_ratio, 0)
    
    # Combine components with tunable weights
    spatial_weight = tunable([0.5, 0.6, 0.7])  # Weight for spatial fit
    future_weight = tunable([0.5, 0.4, 0.3])    # Weight for future potential
    
    # Ensure weights sum to 1
    total_weight = spatial_weight + future_weight
    normalized_spatial = spatial_weight / total_weight * spatial_fit
    normalized_future = future_weight / total_weight * future_potential
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future
    
    return priorities

call llm times: 2
-------------------


...................................................................
launch 9 evaluate tasks
this best socre: -500.0; best score: -500.0; global score: -500.0; space size: 9; measure cnt: 9
sampler suggest should end sample, break
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Improved priority function for bin-packing that balances:
    1. Spatial fit: How well the item fits in the bin
    2. Future potential: How much capacity remains for future items
    
    The priority score combines these two factors with tunable weights.
    """
    # Spatial fit component: Reward bins where item fits well, but don't penalize too heavily for larger bins
    spatial_fit = 1 / (1 + (item / (bins + 1e-10)))  # Add small epsilon to avoid division by zero
    
    # Future potential component: Reward bins that leave enough capacity for future items
    remaining_capacity = bins - item
    capacity_ratio = remaining_capacity / np.max(remaining_capacity)  # Normalize
    future_potential = np.where(remaining_capacity > 0, capacity_ratio, 0)
    
    # Combine components with tunable weights
    spatial_weight = 0.6  # Weight for spatial fit
    future_weight = 0.5    # Weight for future potential
    
    # Ensure weights sum to 1
    total_weight = spatial_weight + future_weight
    normalized_spatial = spatial_weight / total_weight * spatial_fit
    normalized_future = future_weight / total_weight * future_potential
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function for bin-packing that balances:
    1. Spatial fit: How well the item fits in the bin
    2. Future potential: How much capacity remains for future items
    
    The priority score combines these two factors with tunable weights.
    """
    # Spatial fit component: Reward bins where item fits well, but don't penalize too heavily for larger bins
    spatial_fit = 1 / (1 + (item / (bins + 1e-10)))  # Add small epsilon to avoid division by zero
    
    # Future potential component: Reward bins that leave enough capacity for future items
    remaining_capacity = bins - item
    capacity_ratio = remaining_capacity / np.max(remaining_capacity)  # Normalize
    future_potential = np.where(remaining_capacity > 0, capacity_ratio, 0)
    
    # Combine components with tunable weights
    spatial_weight = 0.6  # Weight for spatial fit
    future_weight = 0.5    # Weight for future potential
    
    # Ensure weights sum to 1
    total_weight = spatial_weight + future_weight
    normalized_spatial = spatial_weight / total_weight * spatial_fit
    normalized_future = future_weight / total_weight * future_potential
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin.

    This version uses a more sophisticated strategy that balances:
    1. Spatial fit (how well the item fits in the bin)
    2. Future packing potential (how much capacity remains for future items)
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity for each bin
    remaining_capacity = bins - item
    
    # Filter out bins that can't accommodate the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit metrics
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1 / (1 + np.exp(-tunable([5, 10]) * (remaining_capacity[valid_bins] / bins[valid_bins])))
    
    # Calculate future packing potential
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.log(
        1 + tunable([1, 2]) * remaining_capacity[valid_bins] / np.mean(bins)
    )
    
    # Combine spatial fit and future potential with tunable weights
    alpha = tunable([0.5, 0.7])
    priority = alpha * spatial_fit + (1 - alpha) * future_potential
    
    # Penalize bins with very small remaining capacity to encourage bin consolidation
    small_capacity_penalty = tunable([0.1, 0.2])
    priority[remaining_capacity < tunable([0.2, 0.3])] *= (1 - small_capacity_penalty)
    
    return priority

call llm times: 3
-------------------


....................................................................................................................................................
current thread_i 6
launch 31 evaluate tasks
this best socre: -500.0; best score: -500.0; global score: -500.0; space size: 32; measure cnt: 31
................................................................
launch 0 evaluate tasks
this best socre: -10000000000.0; best score: -500.0; global score: -500.0; space size: 32; measure cnt: 31
................................................................
launch 1 evaluate tasks
this best socre: -500.0; best score: -500.0; global score: -500.0; space size: 32; measure cnt: 32
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function for bin-packing that balances:
    1. Spatial fit: How well the item fits in the bin
    2. Future potential: How much capacity remains for future items
    
    The priority score combines these two factors with tunable weights.
    """
    # Spatial fit component: Reward bins where item fits well, but don't penalize too heavily for larger bins
    spatial_fit = 1 / (1 + (item / (bins + 1e-10)))  # Add small epsilon to avoid division by zero
    
    # Future potential component: Reward bins that leave enough capacity for future items
    remaining_capacity = bins - item
    capacity_ratio = remaining_capacity / np.max(remaining_capacity)  # Normalize
    future_potential = np.where(remaining_capacity > 0, capacity_ratio, 0)
    
    # Combine components with tunable weights
    spatial_weight = 0.6  # Weight for spatial fit
    future_weight = 0.5    # Weight for future potential
    
    # Ensure weights sum to 1
    total_weight = spatial_weight + future_weight
    normalized_spatial = spatial_weight / total_weight * spatial_fit
    normalized_future = future_weight / total_weight * future_potential
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    
    # 1. Spatial Fit Score: How well the item fits into the bin
    capacity = bins
    remaining_capacity = capacity - item
    valid_bins = remaining_capacity >= 0
    
    # Calculate spatial fit score based on how much space is left after placing the item
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1 / (1 + np.exp(-tunable([5, 10]) * (remaining_capacity[valid_bins] / capacity[valid_bins])))
    
    # 2. Future Potential Score: How good the bin is for future packing
    # Reward bins that leave enough space for future items while being close to capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = (
        tunable([0.3, 0.5, 0.7]) * (1 - remaining_capacity[valid_bins] / capacity[valid_bins]) +
        tunable([0.7, 0.5, 0.3]) * np.exp(-tunable([2, 3, 4]) * remaining_capacity[valid_bins])
    )
    
    # 3. Combine scores with tunable weights
    alpha = tunable([0.4, 0.5, 0.6])  # Weight for spatial fit
    beta = 1 - alpha  # Weight for future potential
    
    priorities = alpha * spatial_fit + beta * future_potential
    
    # 4. Add exploration factor to prevent getting stuck in local optima
    exploration = tunable([0.01, 0.05, 0.1]) * np.random.randn(*priorities.shape)
    priorities += exploration
    
    return priorities

call llm times: 4
-------------------


..........
current thread_i 1
launch 64 evaluate tasks
current thread_i 3
this best socre: -213.1; best score: -213.1; global score: -213.1; space size: 486; measure cnt: 64
.............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 41 evaluate tasks
current thread_i 0
this best socre: -213.1; best score: -213.1; global score: -213.1; space size: 486; measure cnt: 105
.......................................................................................
launch 8 evaluate tasks
this best socre: -213.1; best score: -213.1; global score: -213.1; space size: 486; measure cnt: 113
................................................................................................................................................................................................................................................................................................................................................
launch 19 evaluate tasks
this best socre: -213.1; best score: -213.1; global score: -213.1; space size: 486; measure cnt: 132
sampler suggest should end sample, break
INFO:absl:Best score increased to -213.1
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit and future packing potential."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    
    # Ensure we don't consider bins that can't fit the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit component: higher priority for better fit (lower remaining capacity)
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / remaining_capacity[valid_bins]
    
    # Calculate future packing potential component
    # tunable parameter for average future item size
    avg_future_size = tunable([0.2, 0.3, 0.4])  # Example tunable parameter
    
    # tunable parameter for minimum acceptable remaining capacity
    min_remaining = tunable([0.1, 0.2, 0.3])  # Example tunable parameter
    
    # Higher priority if remaining capacity is sufficient for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )
    
    # Calculate bin utilization component: prefer bins that are closer to full but not too full
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - 0.8))  # Peak preference at 80% utilization
    
    # Combine components into a composite priority score
    # tunable weights for each component
    spatial_weight = tunable([0.5, 0.6, 0.7])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])
    
    composite_priority = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        utilization_weight * utilization_score
    )
    
    return composite_priority

call llm times: 5
-------------------


..............
launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -211.05; space size: 243; measure cnt: 64
.....................................
launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -211.05; space size: 243; measure cnt: 128
.........................................................................................................................................................
launch 64 evaluate tasks
current thread_i 4
this best socre: -211.05; best score: -211.05; global score: -211.05; space size: 243; measure cnt: 192
..........................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 42 evaluate tasks
current thread_i 8
this best socre: -211.05; best score: -211.05; global score: -211.05; space size: 243; measure cnt: 234
sampler suggest should end sample, break
INFO:absl:Best score increased to -211.05
-------------------
    """Improved priority function considering spatial fit and future packing potential."""
    # Calculate the remaining capacity if the item is added to each bin
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0
    
    # Spatial fit: How well the item fits into the bin
    spatial_fit = np.zeros_like(bins, dtype=float)
    spatial_fit[valid_bins] = item / bins[valid_bins]
    # Normalize spatial fit to a 0-1 scale
    spatial_fit = (spatial_fit - np.min(spatial_fit)) / (np.max(spatial_fit) - np.min(spatial_fit))
    
    # Future packing potential: Reward bins with higher remaining capacity above a threshold
    # The threshold is a tunable parameter
    capacity_threshold = tunable([0.2, 0.3, 0.4])  # Example tunable parameter
    future_potential = np.zeros_like(bins, dtype=float)
    future_potential[valid_bins] = remaining_capacity[valid_bins] > capacity_threshold
    future_potential = future_potential.astype(float)
    
    # Combine spatial fit and future potential with tunable weights
    weight_spatial = tunable([0.7, 0.5, 0.6])  # Weight for spatial fit
    weight_future = tunable([0.3, 0.5, 0.4])  # Weight for future potential
    
    # Ensure weights sum to 1
    total_weight = weight_spatial + weight_future
    weight_spatial /= total_weight
    weight_future /= total_weight
    
    combined_score = (weight_spatial * spatial_fit) + (weight_future * future_potential)
    
    # Penalize bins that are too full (another tunable parameter)
    full_penalty_threshold = tunable([0.9, 0.85, 0.95])
    full_penalty = np.where(bins > full_penalty_threshold, -0.5, 0)
    
    # Final priority is the combined score plus any penalties
    priorities = combined_score + full_penalty
    
    return priorities

call llm times: 6
-------------------


............................................................
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.05; space size: 81; measure cnt: 64
.................................................................................................................................................................................
launch 15 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.05; space size: 81; measure cnt: 79
.................................................................................................
launch 2 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.05; space size: 81; measure cnt: 81
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future utility."""
    
    # Tunable parameters
    weight_spatial = tunable([0.5, 0.6, 0.7])
    weight_future = tunable([0.5, 0.4, 0.3])
    mu = tunable([1.0, 1.5, 2.0])
    sigma = tunable([0.5, 0.8, 1.0])
    
    priorities = []
    for bin_cap in bins:
        remaining = bin_cap - item
        if remaining < 0:
            priorities.append(0.0)
            continue
        
        # Spatial fit score: how well the item fills the bin
        spatial_fit = 1.0 - (remaining / bin_cap)
        
        # Future utility score: probability a future item fits into remaining space
        future_utility = norm.cdf(remaining, mu, sigma)
        
        # Combine scores with tunable weights
        priority = weight_spatial * spatial_fit + weight_future * future_utility
        priorities.append(priority)
    
    return np.array(priorities)

call llm times: 7
-------------------


..................................................
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.05; space size: 81; measure cnt: 64
......................................................................................................................................................................................
launch 15 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.05; space size: 81; measure cnt: 79
...................................................................................................................
launch 2 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.05; space size: 81; measure cnt: 81
sampler suggest should end sample, break
-------------------
    """Improved priority function considering spatial fit and future packing potential."""
    # Calculate remaining capacity for each bin
    remaining = bins - item
    valid_bins = remaining > 0  # Only consider bins that can fit the item

    # Metric 1: Immediate fit (favor bins with higher remaining capacity after placing the item)
    fit_score = remaining.copy()
    fit_score[~valid_bins] = 0  # Invalid bins have zero score

    # Metric 2: Bin fragmentation (favor bins with less fragmentation after placing the item)
    # Simulate adding the item and calculate the number of 'gaps' it creates
    # For simplicity, we assume that adding the item creates a single gap
    # In a real scenario, this would require tracking the exact arrangement of items
    # Here, we approximate fragmentation as the inverse of the largest possible remaining block
    # Larger remaining blocks mean less fragmentation
    fragmentation_score = 1.0 / (remaining + 1e-10)  # Avoid division by zero
    fragmentation_score[~valid_bins] = 0

    # Metric 3: Future fit potential (favor bins with higher likelihood of accommodating future items)
    # Simulate future items using a distribution (e.g., uniform between 0.1 and 0.5)
    future_items = np.random.uniform(0.1, 0.5, size=100)
    future_fit = np.zeros_like(bins, dtype=float)
    for i in range(len(bins)):
        if valid_bins[i]:
            # Calculate how many future items can fit into the remaining space
            capacity = remaining[i]
            count = 0
            for future_item in future_items:
                if future_item <= capacity:
                    count += 1
                    capacity -= future_item
            future_fit[i] = count
    future_fit_score = future_fit / future_fit.max() if future_fit.max() != 0 else future_fit

    # Combine metrics with tunable weights
    weight_fit = tunable([0.5, 0.4, 0.6])
    weight_fragmentation = tunable([0.3, 0.2, 0.4])
    weight_future = tunable([0.2, 0.1, 0.3])

    # Normalize each metric to [0,1] before combining
    fit_norm = fit_score / (fit_score.max() if fit_score.max() != 0 else 1)
    frag_norm = 1.0 / (fragmentation_score + 1e-10)  # Invert since lower fragmentation is better
    frag_norm = frag_norm / (frag_norm.max() if frag_norm.max() != 0 else 1)
    future_norm = future_fit_score

    # Calculate the final priority score
    priorities = (
        weight_fit * fit_norm +
        weight_fragmentation * frag_norm +
        weight_future * future_norm
    )

    # Ensure invalid bins have zero priority
    priorities[~valid_bins] = 0

    return priorities

call llm times: 8
-------------------


....................................................................................................................................................................................
launch 27 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.05; space size: 27; measure cnt: 27
sampler suggest should end sample, break
request...
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    
    # 1. Spatial Fit Score: How well the item fits into the bin
    capacity = bins
    remaining_capacity = capacity - item
    valid_bins = remaining_capacity >= 0
    
    # Calculate spatial fit score based on how much space is left after placing the item
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1 / (1 + np.exp(-5 * (remaining_capacity[valid_bins] / capacity[valid_bins])))
    
    # 2. Future Potential Score: How good the bin is for future packing
    # Reward bins that leave enough space for future items while being close to capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = (
        0.3 * (1 - remaining_capacity[valid_bins] / capacity[valid_bins]) +
        0.3 * np.exp(-2 * remaining_capacity[valid_bins])
    )
    
    # 3. Combine scores with tunable weights
    alpha = 0.6  # Weight for spatial fit
    beta = 1 - alpha  # Weight for future potential
    
    priorities = alpha * spatial_fit + beta * future_potential
    
    # 4. Add exploration factor to prevent getting stuck in local optima
    exploration = 0.1 * np.random.randn(*priorities.shape)
    priorities += exploration
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit and future packing potential."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    
    # Ensure we don't consider bins that can't fit the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit component: higher priority for better fit (lower remaining capacity)
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / remaining_capacity[valid_bins]
    
    # Calculate future packing potential component
    # tunable parameter for average future item size
    avg_future_size = 0.3  # Example tunable parameter
    
    # tunable parameter for minimum acceptable remaining capacity
    min_remaining = 0.2  # Example tunable parameter
    
    # Higher priority if remaining capacity is sufficient for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )
    
    # Calculate bin utilization component: prefer bins that are closer to full but not too full
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - 0.8))  # Peak preference at 80% utilization
    
    # Combine components into a composite priority score
    # tunable weights for each component
    spatial_weight = 0.5
    future_weight = 0.5
    utilization_weight = 0.4
    
    composite_priority = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        utilization_weight * utilization_score
    )
    
    return composite_priority


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------
-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function for bin-packing that balances:
    1. Spatial fit: How well the item fits in the bin
    2. Future potential: How much capacity remains for future items
    
    The priority score combines these two factors with tunable weights.
    """
    # Spatial fit component: Reward bins where item fits well, but don't penalize too heavily for larger bins
    spatial_fit = 1 / (1 + (item / (bins + 1e-10)))  # Add small epsilon to avoid division by zero
    
    # Future potential component: Reward bins that leave enough capacity for future items
    remaining_capacity = bins - item
    capacity_ratio = remaining_capacity / np.max(remaining_capacity)  # Normalize
    future_potential = np.where(remaining_capacity > 0, capacity_ratio, 0)
    
    # Combine components with tunable weights
    spatial_weight = 0.6  # Weight for spatial fit
    future_weight = 0.5    # Weight for future potential
    
    # Ensure weights sum to 1
    total_weight = spatial_weight + future_weight
    normalized_spatial = spatial_weight / total_weight * spatial_fit
    normalized_future = future_weight / total_weight * future_potential
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit and future packing potential."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    
    # Ensure we don't consider bins that can't fit the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit component: higher priority for better fit (lower remaining capacity)
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / remaining_capacity[valid_bins]
    
    # Calculate future packing potential component
    # tunable parameter for average future item size
    avg_future_size = 0.3  # Example tunable parameter
    
    # tunable parameter for minimum acceptable remaining capacity
    min_remaining = 0.2  # Example tunable parameter
    
    # Higher priority if remaining capacity is sufficient for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )
    
    # Calculate bin utilization component: prefer bins that are closer to full but not too full
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - 0.8))  # Peak preference at 80% utilization
    
    # Combine components into a composite priority score
    # tunable weights for each component
    spatial_weight = 0.5
    future_weight = 0.5
    utilization_weight = 0.4
    
    composite_priority = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        utilization_weight * utilization_score
    )
    
    return composite_priority


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------request...

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function for bin-packing that balances:
    1. Spatial fit: How well the item fits in the bin
    2. Future potential: How much capacity remains for future items
    
    The priority score combines these two factors with tunable weights.
    """
    # Spatial fit component: Reward bins where item fits well, but don't penalize too heavily for larger bins
    spatial_fit = 1 / (1 + (item / (bins + 1e-10)))  # Add small epsilon to avoid division by zero
    
    # Future potential component: Reward bins that leave enough capacity for future items
    remaining_capacity = bins - item
    capacity_ratio = remaining_capacity / np.max(remaining_capacity)  # Normalize
    future_potential = np.where(remaining_capacity > 0, capacity_ratio, 0)
    
    # Combine components with tunable weights
    spatial_weight = 0.6  # Weight for spatial fit
    future_weight = 0.5    # Weight for future potential
    
    # Ensure weights sum to 1
    total_weight = spatial_weight + future_weight
    normalized_spatial = spatial_weight / total_weight * spatial_fit
    normalized_future = future_weight / total_weight * future_potential
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit and future packing potential."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    
    # Ensure we don't consider bins that can't fit the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit component: higher priority for better fit (lower remaining capacity)
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / remaining_capacity[valid_bins]
    
    # Calculate future packing potential component
    # tunable parameter for average future item size
    avg_future_size = 0.3  # Example tunable parameter
    
    # tunable parameter for minimum acceptable remaining capacity
    min_remaining = 0.2  # Example tunable parameter
    
    # Higher priority if remaining capacity is sufficient for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )
    
    # Calculate bin utilization component: prefer bins that are closer to full but not too full
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - 0.8))  # Peak preference at 80% utilization
    
    # Combine components into a composite priority score
    # tunable weights for each component
    spatial_weight = 0.5
    future_weight = 0.5
    utilization_weight = 0.4
    
    composite_priority = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        utilization_weight * utilization_score
    )
    
    return composite_priority


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...-----------------------

-----------------------
request...
import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    
    # 1. Spatial Fit Score: How well the item fits into the bin
    capacity = bins
    remaining_capacity = capacity - item
    valid_bins = remaining_capacity >= 0
    
    # Calculate spatial fit score based on how much space is left after placing the item
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1 / (1 + np.exp(-5 * (remaining_capacity[valid_bins] / capacity[valid_bins])))
    
    # 2. Future Potential Score: How good the bin is for future packing
    # Reward bins that leave enough space for future items while being close to capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = (
        0.3 * (1 - remaining_capacity[valid_bins] / capacity[valid_bins]) +
        0.3 * np.exp(-2 * remaining_capacity[valid_bins])
    )
    
    # 3. Combine scores with tunable weights
    alpha = 0.6  # Weight for spatial fit
    beta = 1 - alpha  # Weight for future potential
    
    priorities = alpha * spatial_fit + beta * future_potential
    
    # 4. Add exploration factor to prevent getting stuck in local optima
    exploration = 0.1 * np.random.randn(*priorities.shape)
    priorities += exploration
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit and future packing potential."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    
    # Ensure we don't consider bins that can't fit the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit component: higher priority for better fit (lower remaining capacity)
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / remaining_capacity[valid_bins]
    
    # Calculate future packing potential component
    # tunable parameter for average future item size
    avg_future_size = 0.3  # Example tunable parameter
    
    # tunable parameter for minimum acceptable remaining capacity
    min_remaining = 0.2  # Example tunable parameter
    
    # Higher priority if remaining capacity is sufficient for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )
    
    # Calculate bin utilization component: prefer bins that are closer to full but not too full
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - 0.8))  # Peak preference at 80% utilization
    
    # Combine components into a composite priority score
    # tunable weights for each component
    spatial_weight = 0.5
    future_weight = 0.5
    utilization_weight = 0.4
    
    composite_priority = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        utilization_weight * utilization_score
    )
    
    return composite_priority


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin.

    This version uses a more sophisticated strategy that balances:
    1. Spatial fit (how well the item fits in the bin)
    2. Future packing potential (how much capacity remains for future items)
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity for each bin
    remaining_capacity = bins - item
    
    # Filter out bins that can't accommodate the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit metrics
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1 / (1 + np.exp(-5 * (remaining_capacity[valid_bins] / bins[valid_bins])))
    
    # Calculate future packing potential
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.log(
        1 + 1 * remaining_capacity[valid_bins] / np.mean(bins)
    )
    
    # Combine spatial fit and future potential with tunable weights
    alpha = 0.7
    priority = alpha * spatial_fit + (1 - alpha) * future_potential
    
    # Penalize bins with very small remaining capacity to encourage bin consolidation
    small_capacity_penalty = 0.2
    priority[remaining_capacity < 0.3] *= (1 - small_capacity_penalty)
    
    return priority


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit and future packing potential."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    
    # Ensure we don't consider bins that can't fit the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit component: higher priority for better fit (lower remaining capacity)
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / remaining_capacity[valid_bins]
    
    # Calculate future packing potential component
    # tunable parameter for average future item size
    avg_future_size = 0.3  # Example tunable parameter
    
    # tunable parameter for minimum acceptable remaining capacity
    min_remaining = 0.2  # Example tunable parameter
    
    # Higher priority if remaining capacity is sufficient for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )
    
    # Calculate bin utilization component: prefer bins that are closer to full but not too full
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - 0.8))  # Peak preference at 80% utilization
    
    # Combine components into a composite priority score
    # tunable weights for each component
    spatial_weight = 0.5
    future_weight = 0.5
    utilization_weight = 0.4
    
    composite_priority = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        utilization_weight * utilization_score
    )
    
    return composite_priority


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


-----------------------
-----------------------
-------------------
    """Improved priority function for bin-packing that balances:
    1. Spatial fit: How well the item fits in the bin
    2. Future potential: How much capacity remains for future items
    3. Bin distribution: Maintain balanced bin utilization
    
    Introduces novel strategies:
    - Dynamic spatial fit calculation based on bin capacity distribution
    - Future potential estimation using capacity percentile
    - Bin utilization balance factor to prevent "bin starvation"
    
    Exposes tunable parameters for strategic customization.
    """
    # Calculate bin capacity statistics
    total_bins = len(bins)
    max_capacity = np.max(bins)
    min_capacity = np.min(bins)
    avg_capacity = np.mean(bins)
    
    # Spatial fit component: 
    # Reward bins where item fits well while considering capacity distribution
    capacity_diff = bins - item
    capacity_diff[capacity_diff < 0] = 0  # Only consider valid fits
    
    # Calculate percentile of remaining capacity to assess future potential
    remaining_percentile = np.percentile(bins - item, 75)
    
    # Calculate spatial balance score
    # Penalize bins that would leave capacity far from the distribution mean
    balance_factor = tunable([0.3, 0.5, 0.7])
    spatial_balance = np.exp(-balance_factor * np.abs((bins - item) - avg_capacity))
    
    # Future potential component:
    # Reward bins that leave capacity in a favorable range
    capacity_ratio = (bins - item) / max_capacity
    future_potential = np.where(
        (capacity_ratio > tunable([0.1, 0.2, 0.3])) & 
        (capacity_ratio < tunable([0.8, 0.9, 1.0])),
        capacity_ratio,
        0
    )
    
    # Combine components with tunable weights
    spatial_weight = tunable([0.4, 0.5, 0.6])
    balance_weight = tunable([0.2, 0.3, 0.4])
    future_weight = tunable([0.2, 0.3, 0.4])
    
    # Ensure weights sum to 1
    total_weight = spatial_weight + balance_weight + future_weight
    normalized_spatial = (spatial_weight / total_weight) * capacity_diff
    normalized_balance = (balance_weight / total_weight) * spatial_balance
    normalized_future = (future_weight / total_weight) * future_potential
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_balance + normalized_future
    
    return priorities

call llm times: 9
-------------------


.
launch 64 evaluate taskscurrent thread_i 6

current thread_i 9
this best socre: -500.0; best score: -500.0; global score: -211.05; space size: 729; measure cnt: 64
........
launch 64 evaluate tasks
this best socre: -500.0; best score: -500.0; global score: -211.05; space size: 729; measure cnt: 128
...................
launch 64 evaluate tasks
this best socre: -500.0; best score: -500.0; global score: -211.05; space size: 729; measure cnt: 192
..........................
launch 64 evaluate tasks
current thread_i 8
current thread_i 5
this best socre: -500.0; best score: -500.0; global score: -211.05; space size: 729; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Improved priority function considering both current fit and future potential."""
    epsilon = 1e-10  # To avoid division by zero
    mask = (bins >= item)
    remaining_after = bins - item
    
    # Calculate fit quality: higher when the item fits well (remaining space is small)
    fit_quality = np.where(mask, 1 / (remaining_after + epsilon), 0)
    
    # Calculate future potential: higher when more space is left for future items
    future_potential = np.where(mask, remaining_after, 0)
    
    # Combine with tunable weights
    alpha = tunable([0.3, 0.5, 0.7])  # Weight for fit quality
    beta = tunable([0.7, 0.5, 0.3])   # Weight for future potential
    priority = alpha * fit_quality + beta * future_potential
    
    # Apply tunable penalty for bins with too little remaining space
    min_remaining = tunable([0.1, 0.2, 0.3])  # Minimum acceptable remaining space
    penalty = tunable([0.5, 0.8])             # Penalty factor to reduce priority
    priority = np.where(remaining_after < min_remaining, priority * penalty, priority)
    
    return priority

call llm times: 10
-------------------


.................................................................................................................................................................................................................
launch 54 evaluate tasks
current thread_i 3
current thread_i 2
this best socre: -377.5; best score: -377.5; global score: -211.05; space size: 54; measure cnt: 54
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.3, 0.4, 0.5])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.25, 0.3])   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.7, 0.8, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = tunable([0.5, 0.6, 0.7])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities

call llm times: 11
-------------------


.
launch 64 evaluate tasks
current thread_i 1
this best socre: -210.2; best score: -210.2; global score: -210.2; space size: 729; measure cnt: 64
..............
launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -210.2; space size: 729; measure cnt: 128
......................
launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -210.2; space size: 729; measure cnt: 192
..............................................
launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -210.2; space size: 729; measure cnt: 256
sampler suggest should end sample, break
INFO:absl:Best score increased to -210.2
-------------------
    """Improved priority function for bin-packing considering spatial fit and future potential with tunable parameters."""
    # Spatial fit component: Rewards bins where the item fits well without excessive remaining space
    spatial_fit = 1 / (1 + (item / (bins + 1e-10)))  # Avoid division by zero

    # Calculate remaining capacity after placing the item
    remaining_capacity = bins - item

    # Future potential component: Reward bins that leave enough space for future items
    # Tunable threshold: Fraction of item size that remaining capacity should exceed
    threshold = tunable([0.5, 0.75, 1.0]) * item
    future_potential = np.where(remaining_capacity > threshold, remaining_capacity, 0)

    # Normalize future potential across bins
    max_remaining = np.max(future_potential)
    if max_remaining == 0:
        future_potential_normalized = np.zeros_like(future_potential)
    else:
        future_potential_normalized = future_potential / max_remaining

    # Combine components with tunable weights
    spatial_weight = tunable([0.5, 0.6, 0.7])
    future_weight = tunable([0.5, 0.4, 0.3])

    # Ensure weights sum to 1
    total_weight = spatial_weight + future_weight
    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential_normalized

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future

    return priorities

call llm times: 12
-------------------


............................................................................................................................................
launch 27 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 27; measure cnt: 27
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced strategy."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0
    
    # Spatial fit component: Reward bins where item fits well, penalize extremes
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = np.exp(
        -tunable([0.5, 0.7, 0.9]) * 
        (remaining_capacity[valid_bins] - tunable([0.2, 0.3, 0.4]))**2
    )
    
    # Future potential component: Reward bins with capacity above average
    avg_remaining = np.mean(remaining_capacity[valid_bins]) if np.any(valid_bins) else 0
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > tunable([avg_remaining * 0.8, avg_remaining * 0.9]),
        1.0 / (1.0 + np.exp(
            -(remaining_capacity[valid_bins] - tunable([0.3, 0.4, 0.5]))
        )),
        0.0
    )
    
    # Bin utilization component: Prefer bins near ideal utilization
    utilization = bins / np.max(bins)
    ideal_util = tunable([0.7, 0.8, 0.9])
    utilization_score = np.exp(
        -tunable([0.5, 0.7, 0.9]) * (utilization - ideal_util)**2
    )
    
    # Combine components with tunable weights
    spatial_weight = tunable([0.4, 0.5, 0.6])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])
    
    # Ensure weights sum to 1
    total_weight = spatial_weight + future_weight + utilization_weight
    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization
    
    return priorities

call llm times: 13
-------------------



launch 64 evaluate tasks
this best socre: -279.15; best score: -279.15; global score: -210.2; space size: 13122; measure cnt: 64
..............
launch 64 evaluate tasks
this best socre: -278.9; best score: -278.9; global score: -210.2; space size: 13122; measure cnt: 128
........................................................................................................................................................
launch 64 evaluate tasks
this best socre: -278.9; best score: -278.9; global score: -210.2; space size: 13122; measure cnt: 192
....................................................................
launch 64 evaluate tasks
current thread_i 0
this best socre: -278.9; best score: -278.9; global score: -210.2; space size: 13122; measure cnt: 256
............................
launch 64 evaluate tasks
current thread_i 4
this best socre: -278.9; best score: -278.9; global score: -210.2; space size: 13122; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Improved priority function for bin-packing that balances spatial fit and future potential with tunable parameters."""
    if bins.size == 0:
        return np.array([])
    
    num_bins = bins.size
    priorities = np.zeros(num_bins)
    
    # Calculate remaining capacities where item fits
    remaining_capacities = np.where(item <= bins, bins - item, 0)
    max_remaining = np.max(remaining_capacities)
    
    for i in range(num_bins):
        bin_cap = bins[i]
        if item > bin_cap:
            continue
        
        # Spatial fit component
        ratio = item / bin_cap
        alpha = tunable([0.5, 1.0, 1.5])  # Controls the peak of spatial fit
        spatial_fit = (1 - ratio) ** alpha
        
        # Future potential component
        remaining = bin_cap - item
        if max_remaining == 0:
            normalized_remaining = 0.0
        else:
            normalized_remaining = remaining / max_remaining
        decay_rate = tunable([0.1, 0.2, 0.3])  # Controls decay of future potential
        future_potential = normalized_remaining * np.exp(-decay_rate * remaining)
        
        # Combine components with tunable weights
        w_spatial = tunable([0.4, 0.5, 0.6])
        w_future = tunable([0.6, 0.5, 0.4])
        total_weight = w_spatial + w_future
        normalized_spatial = (w_spatial / total_weight) * spatial_fit
        normalized_future = (w_future / total_weight) * future_potential
        
        priorities[i] = normalized_spatial + normalized_future
    
    return priorities

call llm times: 14
-------------------


...................................................
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 81; measure cnt: 64
....................................................................................................................................................................................................................................................
launch 16 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 81; measure cnt: 80
..............................................................................
launch 1 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 81; measure cnt: 81
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering multiple strategic factors."""
    # Calculate remaining capacity for each bin
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0
    
    # Initialize priority array
    priority = np.zeros_like(bins, dtype=np.float64)
    
    # Spatial fit component: Reward bins where the item fits well without leaving too much space
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / (1.0 + np.exp(
        -tunable([5, 10]) * (remaining_capacity[valid_bins] - tunable([0.1, 0.2])) / bins[valid_bins]
    ))
    
    # Future packing potential component: Reward bins with sufficient capacity for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    min_remaining = tunable([0.2, 0.3])  # Minimum remaining capacity to consider
    avg_future_size = tunable([0.3, 0.4])  # Average expected size of future items
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(
            -(remaining_capacity[valid_bins] - avg_future_size) / tunable([0.1, 0.2])
        )),
        0.0
    )
    
    # Bin utilization component: Prefer bins with utilization close to a desired level
    utilization = bins / np.max(bins)
    desired_utilization = tunable([0.8, 0.9])
    utilization_score = np.exp(
        -tunable([2, 3]) * np.abs(utilization - desired_utilization)
    )
    
    # Load balance component: Distribute items to balance bin loads
    load_balance = bins / np.mean(bins) if np.mean(bins) != 0 else np.ones_like(bins)
    load_balance_score = 1.0 / (1.0 + np.exp(
        tunable([2, 3]) * (load_balance - 1.0)
    ))
    
    # Combine components with tunable weights
    spatial_weight = tunable([0.4, 0.5])
    future_weight = tunable([0.3, 0.4])
    utilization_weight = tunable([0.2, 0.3])
    balance_weight = tunable([0.1, 0.2])
    
    composite_priority = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        utilization_weight * utilization_score +
        balance_weight * load_balance_score
    )
    
    # Apply penalties for very small remaining capacities to avoid fragmentation
    small_capacity_penalty = tunable([0.2, 0.3])
    penalty_mask = remaining_capacity < tunable([0.1, 0.2])
    composite_priority[penalty_mask] *= (1.0 - small_capacity_penalty)
    
    return composite_priority

call llm times: 15
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 16384; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 16384; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 16384; measure cnt: 192
sampler suggest should end sample, break
request...
request...request...-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced strategy."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0
    
    # Spatial fit component: Reward bins where item fits well, penalize extremes
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = np.exp(
        -0.5 * 
        (remaining_capacity[valid_bins] - 0.2)**2
    )
    
    # Future potential component: Reward bins with capacity above average
    avg_remaining = np.mean(remaining_capacity[valid_bins]) if np.any(valid_bins) else 0
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > avg_remaining * 0.9,
        1.0 / (1.0 + np.exp(
            -(remaining_capacity[valid_bins] - 0.5)
        )),
        0.0
    )
    
    # Bin utilization component: Prefer bins near ideal utilization
    utilization = bins / np.max(bins)
    ideal_util = 0.7
    utilization_score = np.exp(
        -0.9 * (utilization - ideal_util)**2
    )
    
    # Combine components with tunable weights
    spatial_weight = 0.5
    future_weight = 0.4
    utilization_weight = 0.2
    
    # Ensure weights sum to 1
    total_weight = spatial_weight + future_weight + utilization_weight
    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------


-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin.

    This version uses a more sophisticated strategy that balances:
    1. Spatial fit (how well the item fits in the bin)
    2. Future packing potential (how much capacity remains for future items)
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity for each bin
    remaining_capacity = bins - item
    
    # Filter out bins that can't accommodate the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit metrics
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1 / (1 + np.exp(-5 * (remaining_capacity[valid_bins] / bins[valid_bins])))
    
    # Calculate future packing potential
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.log(
        1 + 1 * remaining_capacity[valid_bins] / np.mean(bins)
    )
    
    # Combine spatial fit and future potential with tunable weights
    alpha = 0.7
    priority = alpha * spatial_fit + (1 - alpha) * future_potential
    
    # Penalize bins with very small remaining capacity to encourage bin consolidation
    small_capacity_penalty = 0.2
    priority[remaining_capacity < 0.3] *= (1 - small_capacity_penalty)
    
    return priority


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    
    # 1. Spatial Fit Score: How well the item fits into the bin
    capacity = bins
    remaining_capacity = capacity - item
    valid_bins = remaining_capacity >= 0
    
    # Calculate spatial fit score based on how much space is left after placing the item
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1 / (1 + np.exp(-5 * (remaining_capacity[valid_bins] / capacity[valid_bins])))
    
    # 2. Future Potential Score: How good the bin is for future packing
    # Reward bins that leave enough space for future items while being close to capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = (
        0.3 * (1 - remaining_capacity[valid_bins] / capacity[valid_bins]) +
        0.3 * np.exp(-2 * remaining_capacity[valid_bins])
    )
    
    # 3. Combine scores with tunable weights
    alpha = 0.6  # Weight for spatial fit
    beta = 1 - alpha  # Weight for future potential
    
    priorities = alpha * spatial_fit + beta * future_potential
    
    # 4. Add exploration factor to prevent getting stuck in local optima
    exploration = 0.1 * np.random.randn(*priorities.shape)
    priorities += exploration
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function considering both current fit and future potential."""
    epsilon = 1e-10  # To avoid division by zero
    mask = (bins >= item)
    remaining_after = bins - item
    
    # Calculate fit quality: higher when the item fits well (remaining space is small)
    fit_quality = np.where(mask, 1 / (remaining_after + epsilon), 0)
    
    # Calculate future potential: higher when more space is left for future items
    future_potential = np.where(mask, remaining_after, 0)
    
    # Combine with tunable weights
    alpha = 0.3  # Weight for fit quality
    beta = 0.5   # Weight for future potential
    priority = alpha * fit_quality + beta * future_potential
    
    # Apply tunable penalty for bins with too little remaining space
    min_remaining = 0.2  # Minimum acceptable remaining space
    penalty = 0.5             # Penalty factor to reduce priority
    priority = np.where(remaining_after < min_remaining, priority * penalty, priority)
    
    return priority


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function considering both current fit and future potential."""
    epsilon = 1e-10  # To avoid division by zero
    mask = (bins >= item)
    remaining_after = bins - item
    
    # Calculate fit quality: higher when the item fits well (remaining space is small)
    fit_quality = np.where(mask, 1 / (remaining_after + epsilon), 0)
    
    # Calculate future potential: higher when more space is left for future items
    future_potential = np.where(mask, remaining_after, 0)
    
    # Combine with tunable weights
    alpha = 0.3  # Weight for fit quality
    beta = 0.5   # Weight for future potential
    priority = alpha * fit_quality + beta * future_potential
    
    # Apply tunable penalty for bins with too little remaining space
    min_remaining = 0.2  # Minimum acceptable remaining space
    penalty = 0.5             # Penalty factor to reduce priority
    priority = np.where(remaining_after < min_remaining, priority * penalty, priority)
    
    return priority


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    
    # 1. Spatial Fit Score: How well the item fits into the bin
    capacity = bins
    remaining_capacity = capacity - item
    valid_bins = remaining_capacity >= 0
    
    # Calculate spatial fit score based on how much space is left after placing the item
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1 / (1 + np.exp(-5 * (remaining_capacity[valid_bins] / capacity[valid_bins])))
    
    # 2. Future Potential Score: How good the bin is for future packing
    # Reward bins that leave enough space for future items while being close to capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = (
        0.3 * (1 - remaining_capacity[valid_bins] / capacity[valid_bins]) +
        0.3 * np.exp(-2 * remaining_capacity[valid_bins])
    )
    
    # 3. Combine scores with tunable weights
    alpha = 0.6  # Weight for spatial fit
    beta = 1 - alpha  # Weight for future potential
    
    priorities = alpha * spatial_fit + beta * future_potential
    
    # 4. Add exploration factor to prevent getting stuck in local optima
    exploration = 0.1 * np.random.randn(*priorities.shape)
    priorities += exploration
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

request...-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    
    # 1. Spatial Fit Score: How well the item fits into the bin
    capacity = bins
    remaining_capacity = capacity - item
    valid_bins = remaining_capacity >= 0
    
    # Calculate spatial fit score based on how much space is left after placing the item
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1 / (1 + np.exp(-5 * (remaining_capacity[valid_bins] / capacity[valid_bins])))
    
    # 2. Future Potential Score: How good the bin is for future packing
    # Reward bins that leave enough space for future items while being close to capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = (
        0.3 * (1 - remaining_capacity[valid_bins] / capacity[valid_bins]) +
        0.3 * np.exp(-2 * remaining_capacity[valid_bins])
    )
    
    # 3. Combine scores with tunable weights
    alpha = 0.6  # Weight for spatial fit
    beta = 1 - alpha  # Weight for future potential
    
    priorities = alpha * spatial_fit + beta * future_potential
    
    # 4. Add exploration factor to prevent getting stuck in local optima
    exploration = 0.1 * np.random.randn(*priorities.shape)
    priorities += exploration
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit and future packing potential."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    
    # Ensure we don't consider bins that can't fit the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit component: higher priority for better fit (lower remaining capacity)
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / remaining_capacity[valid_bins]
    
    # Calculate future packing potential component
    # tunable parameter for average future item size
    avg_future_size = 0.3  # Example tunable parameter
    
    # tunable parameter for minimum acceptable remaining capacity
    min_remaining = 0.2  # Example tunable parameter
    
    # Higher priority if remaining capacity is sufficient for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )
    
    # Calculate bin utilization component: prefer bins that are closer to full but not too full
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - 0.8))  # Peak preference at 80% utilization
    
    # Combine components into a composite priority score
    # tunable weights for each component
    spatial_weight = 0.5
    future_weight = 0.5
    utilization_weight = 0.4
    
    composite_priority = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        utilization_weight * utilization_score
    )
    
    return composite_priority


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and bin similarity."""
    
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0
    
    # Spatial Fit component: Prefer bins with better fit (lower remaining capacity)
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        spatial_fit[valid_bins] = 1.0 / remaining_capacity[valid_bins]
    
    # Future Potential component: Reward bins with sufficient space for future items
    avg_future_size = tunable([0.3, 0.4, 0.5])
    min_remaining = tunable([0.2, 0.3])
    
    future_potential = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        future_potential[valid_bins] = np.where(
            remaining_capacity[valid_bins] > min_remaining,
            1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
            0.0
        )
    
    # Utilization component: Prefer bins near target utilization
    target_utilization = tunable([0.7, 0.8, 0.9])
    max_bin = np.max(bins) if bins.size > 0 else 1.0
    utilization = bins / max_bin
    utilization_score = np.exp(-tunable([0.5, 1.0]) * np.abs(utilization - target_utilization))
    
    # Bin Similarity component: Prefer bins with remaining capacity close to the mean
    similarity_score = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        mean_remaining = np.mean(remaining_capacity[valid_bins])
        k = tunable([0.1, 0.2, 0.3])
        differences = np.abs(remaining_capacity[valid_bins] - mean_remaining)
        similarity_score[valid_bins] = np.exp(-k * differences)
    
    # Combine components with tunable weights
    spatial_weight = tunable([0.4, 0.5, 0.6])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])
    similarity_weight = tunable([0.1, 0.2, 0.3])
    
    # Normalize weights to sum to 1
    total_weight = spatial_weight + future_weight + utilization_weight + similarity_weight
    if total_weight != 0:
        spatial_weight /= total_weight
        future_weight /= total_weight
        utilization_weight /= total_weight
        similarity_weight /= total_weight
    
    composite_priority = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        utilization_weight * utilization_score +
        similarity_weight * similarity_score
    )
    
    # Add exploration factor to prevent local optima
    exploration_noise = tunable([0.05, 0.1, 0.15]) * np.random.randn(*composite_priority.shape)
    composite_priority += exploration_noise
    
    return composite_priority

call llm times: 16
-------------------



-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function considering both current fit and future potential."""
    epsilon = 1e-10  # To avoid division by zero
    mask = (bins >= item)
    remaining_after = bins - item
    
    # Calculate fit quality: higher when the item fits well (remaining space is small)
    fit_quality = np.where(mask, 1 / (remaining_after + epsilon), 0)
    
    # Calculate future potential: higher when more space is left for future items
    future_potential = np.where(mask, remaining_after, 0)
    
    # Combine with tunable weights
    alpha = 0.3  # Weight for fit quality
    beta = 0.5   # Weight for future potential
    priority = alpha * fit_quality + beta * future_potential
    
    # Apply tunable penalty for bins with too little remaining space
    min_remaining = 0.2  # Minimum acceptable remaining space
    penalty = 0.5             # Penalty factor to reduce priority
    priority = np.where(remaining_after < min_remaining, priority * penalty, priority)
    
    return priority


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

launch 64 evaluate tasks
this best socre: -240.65; best score: -240.65; global score: -210.2; space size: 26244; measure cnt: 64
................................................................
launch 0 evaluate tasks
this best socre: -10000000000.0; best score: -240.65; global score: -210.2; space size: 26244; measure cnt: 64
................................................................
launch 0 evaluate tasks
this best socre: -10000000000.0; best score: -240.65; global score: -210.2; space size: 26244; measure cnt: 64
................................................................
launch 0 evaluate tasks
this best socre: -10000000000.0; best score: -240.65; global score: -210.2; space size: 26244; measure cnt: 64
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, 
    considering spatial fit, future potential, and utilization."""
    
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Parameters
    threshold = tunable([0.2, 0.3, 0.4])  # Threshold for future potential
    steepness = tunable([0.1, 0.2])      # Steepness of future potential sigmoid
    optimal_util = tunable([0.7, 0.8])   # Optimal utilization
    util_width = tunable([1.0, 2.0])     # Width of utilization curve
    weights = tunable([0.5, 0.3, 0.2])   # Weights for spatial, future, utilization
    exploration_factor = tunable([0.01, 0.1])
    
    for i in range(bins.size):
        if not valid_bins[i]:
            continue
        
        bin_cap = bins[i]
        remaining = remaining_capacity[i]
        
        # Spatial Fit: How well the item fits into the bin
        spatial_fit = item / bin_cap
        
        # Future Potential: Reward bins with remaining capacity above threshold
        future_potential = 1.0 / (1.0 + np.exp(-steepness * (remaining - threshold)))
        
        # Utilization: Reward utilization near optimal level
        utilization = (bin_cap - remaining) / bin_cap
        utilization_score = np.exp(-util_width * (utilization - optimal_util)**2)
        
        # Combine scores with weights
        priority = (
            weights[0] * spatial_fit +
            weights[1] * future_potential +
            weights[2] * utilization_score
        )
        
        # Add exploration factor
        priority += exploration_factor * np.random.randn()
        
        priorities[i] = priority
    
    return priorities

call llm times: 17
-------------------


...........
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 144; measure cnt: 64
.............................................................................................................................................
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 144; measure cnt: 128
.......................................................................................................................................................................................................................................................................................................................
launch 14 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 144; measure cnt: 142
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with dynamic weights."""
    
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Introduce look-ahead mechanism to simulate future item placements
    avg_future_size = tunable([0.5, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3])    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    
    # Look-ahead: Simulate placing an average future item
    future_item = np.random.normal(avg_future_size, 0.1)
    future_remaining = remaining_capacity[valid_bins] - future_item
    valid_future_bins = future_remaining > 0
    
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )
    future_potential[valid_bins][valid_future_bins] += 0.5  # Reward bins that can accommodate future items

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic weights adjustment based on current bin state
    current_avg_util = np.mean(bins) / np.max(bins)
    spatial_weight = tunable([0.7, 0.8]) * (1 - np.abs(current_avg_util - target_utilization))
    future_weight = tunable([0.4, 0.5]) * (1 - np.mean(valid_bins))
    utilization_weight = tunable([0.4, 0.5]) * (1 - np.abs(current_avg_util - target_utilization))

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores with dynamic exploration
    exploration_noise = tunable([0.1, 0.2]) * np.random.randn(*normalized_spatial.shape)
    priorities = normalized_spatial + normalized_future + normalized_utilization + exploration_noise

    return priorities

call llm times: 18
-------------------


..current thread_i 1
................
launch 64 evaluate tasks
this best socre: -277.5; best score: -277.5; global score: -210.2; space size: 128; measure cnt: 64
..................................................................................
launch 4 evaluate tasks
this best socre: -277.5; best score: -277.5; global score: -210.2; space size: 128; measure cnt: 68
...................................................................
launch 1 evaluate tasks
this best socre: -277.5; best score: -277.5; global score: -210.2; space size: 128; measure cnt: 69
................................................................
launch 0 evaluate tasks
this best socre: -10000000000.0; best score: -277.5; global score: -210.2; space size: 128; measure cnt: 69
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function considering both current fit and future potential."""
    epsilon = 1e-10  # To avoid division by zero
    mask = (bins >= item)
    remaining_after = bins - item
    
    # Calculate fit quality: higher when the item fits well (remaining space is small)
    fit_quality = np.where(mask, 1 / (remaining_after + epsilon), 0)
    
    # Calculate future potential: higher when more space is left for future items
    future_potential = np.where(mask, remaining_after, 0)
    
    # Combine with tunable weights
    alpha = 0.3  # Weight for fit quality
    beta = 0.5   # Weight for future potential
    priority = alpha * fit_quality + beta * future_potential
    
    # Apply tunable penalty for bins with too little remaining space
    min_remaining = 0.2  # Minimum acceptable remaining space
    penalty = 0.5             # Penalty factor to reduce priority
    priority = np.where(remaining_after < min_remaining, priority * penalty, priority)
    
    return priority


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and bin diversity.

    This version introduces a novel strategy that balances multiple factors for optimal bin packing:
    1. Spatial fit: How well the item fits in the bin.
    2. Future potential: How much capacity remains for future items.
    3. Utilization: Preference for bins that are neither too empty nor too full.
    4. Bin diversity: Encourages maintaining a variety of bin capacities for future items.
    5. Penalty for creating partially filled bins.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity for each bin
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    optimal_remaining = tunable([0.1, 0.2])  # Optimal remaining capacity
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = np.exp(
        -np.abs(remaining_capacity[valid_bins] - optimal_remaining) / tunable([0.05, 0.1])
    )

    # Future potential component
    if len(bins) > 0:
        mean_past = np.mean(bins)
        std_past = np.std(bins)
        min_remaining_future = tunable([0.1, 0.2])
        future_potential = np.zeros_like(bins, dtype=np.float64)
        future_potential[valid_bins] = np.where(
            remaining_capacity[valid_bins] > min_remaining_future,
            1.0 / (1.0 + np.exp(
                -(remaining_capacity[valid_bins] - (mean_past + std_past)) / tunable([0.05, 0.1])
            )),
            0.0
        )
    else:
        future_potential = np.zeros_like(bins, dtype=np.float64)

    # Utilization score component
    current_avg_util = np.mean(bins) / np.max(bins) if np.max(bins) != 0 else 0.0
    target_utilization = tunable([0.8, 0.9]) + (current_avg_util - 0.5) * tunable([0.1, 0.2])
    utilization = bins / np.max(bins) if np.max(bins) != 0 else bins
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Bin diversity component
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if np.sum(valid_bins) > 0:
        remaining_sorted = np.sort(remaining_capacity[valid_bins])
        diversity = np.std(remaining_sorted) if len(remaining_sorted) > 1 else 0.0
        diversity_score[valid_bins] = diversity / (np.max(remaining_capacity[valid_bins]) + epsilon)

    # Penalty for small remaining capacity
    penalty = np.ones_like(bins, dtype=np.float64)
    penalty[remaining_capacity < tunable([0.05, 0.1])] *= tunable([0.5, 0.8])

    # Combine components with tunable weights
    spatial_weight = tunable([0.6, 0.7])
    future_weight = tunable([0.3, 0.4])
    utilization_weight = tunable([0.3, 0.4])
    diversity_weight = tunable([0.1, 0.2])
    penalty_weight = tunable([0.1, 0.2])

    total_weight = (
        spatial_weight +
        future_weight +
        utilization_weight +
        diversity_weight +
        penalty_weight
    )
    if total_weight == 0:
        total_weight = 1.0

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score
    normalized_penalty = (penalty_weight / total_weight) * penalty

    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity +
        normalized_penalty
    )

    return priorities

call llm times: 19
-------------------


current thread_i 9

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 8192; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 8192; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 8192; measure cnt: 192
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit and future packing potential."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    
    # Ensure we don't consider bins that can't fit the item
    valid_bins = remaining_capacity > 0
    
    # Calculate spatial fit component: higher priority for better fit (lower remaining capacity)
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / remaining_capacity[valid_bins]
    
    # Calculate future packing potential component
    # tunable parameter for average future item size
    avg_future_size = 0.3  # Example tunable parameter
    
    # tunable parameter for minimum acceptable remaining capacity
    min_remaining = 0.2  # Example tunable parameter
    
    # Higher priority if remaining capacity is sufficient for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )
    
    # Calculate bin utilization component: prefer bins that are closer to full but not too full
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - 0.8))  # Peak preference at 80% utilization
    
    # Combine components into a composite priority score
    # tunable weights for each component
    spatial_weight = 0.5
    future_weight = 0.5
    utilization_weight = 0.4
    
    composite_priority = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        utilization_weight * utilization_score
    )
    
    return composite_priority


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = tunable([0.6, 0.7, 0.8])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.15, 0.2])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 20
-------------------



launch 64 evaluate tasks
current thread_i 5
this best socre: -210.5; best score: -210.5; global score: -210.2; space size: 6561; measure cnt: 64
..
launch 64 evaluate tasks
current thread_i 3
current thread_i 2
this best socre: -210.4; best score: -210.4; global score: -210.2; space size: 6561; measure cnt: 128

launch 64 evaluate tasks
current thread_i 1
current thread_i 4
this best socre: -210.4; best score: -210.4; global score: -210.2; space size: 6561; measure cnt: 192
...
launch 64 evaluate tasks
current thread_i 6
current thread_i 8
current thread_i 0
this best socre: -210.35; best score: -210.35; global score: -210.2; space size: 6561; measure cnt: 256
....
launch 64 evaluate tasks
this best socre: -210.35; best score: -210.35; global score: -210.2; space size: 6561; measure cnt: 320
..
launch 64 evaluate tasks
this best socre: -210.35; best score: -210.35; global score: -210.2; space size: 6561; measure cnt: 384
......
launch 64 evaluate tasks
this best socre: -210.35; best score: -210.35; global score: -210.2; space size: 6561; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and penalties.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    epsilon = 1e-10  # To avoid division by zero
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.75])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3])     # Minimum acceptable remaining capacity
    max_remaining = tunable([1.0, 1.5])     # Maximum acceptable remaining capacity

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.8, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Penalty for bins with very large remaining capacities
    penalty_factor = tunable([0.5, 0.75])  # Penalty factor to reduce priority
    large_remaining_penalty = np.where(remaining_capacity > max_remaining, penalty_factor, 1.0)

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.6])
    future_weight = tunable([0.4, 0.5])
    utilization_weight = tunable([0.4, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Apply penalties
    priorities = normalized_spatial + normalized_future + normalized_utilization
    priorities = priorities * large_remaining_penalty

    return priorities

call llm times: 21
-------------------


..................
launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -210.2; space size: 256; measure cnt: 64
.................................
launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -210.2; space size: 256; measure cnt: 128
.........................................................................................................................
launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -210.2; space size: 256; measure cnt: 192
........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 54 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -210.2; space size: 256; measure cnt: 246
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced strategy.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well, penalize extremes
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    preferred_remaining = tunable([0.1, 0.2, 0.3])  # Tunable parameter
    sigma = tunable([0.05, 0.1, 0.15])  # Tunable parameter
    spatial_fit[valid_bins] = np.exp(
        -((remaining_capacity[valid_bins] - preferred_remaining) ** 2) / (2 * sigma ** 2)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    min_remaining = tunable([0.2, 0.3, 0.4])  # Tunable parameter
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Tunable parameter
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(
            -(remaining_capacity[valid_bins] - avg_future_size)
        )),
        0.0
    )

    # Utilization score component: Prefer bins near ideal utilization
    target_utilization = tunable([0.8, 0.85, 0.9])  # Tunable parameter
    utilization = bins / np.max(bins)
    utilization_score = np.exp(
        -tunable([1.0, 1.5, 2.0]) * (utilization - target_utilization) ** 2
    )

    # Dynamic weighting based on current bin state
    avg_remaining = np.mean(remaining_capacity[valid_bins]) if np.any(valid_bins) else 0
    if avg_remaining < tunable([0.1, 0.2]):
        spatial_weight = 0.4
        future_weight = 0.6
    elif avg_remaining > tunable([0.4, 0.5]):
        spatial_weight = 0.6
        future_weight = 0.4
    else:
        spatial_weight = 0.5
        future_weight = 0.5

    utilization_weight = tunable([0.2, 0.3, 0.4])  # Tunable parameter

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities

call llm times: 22
-------------------



launch 64 evaluate tasks
current thread_i 9
this best socre: -330.45; best score: -330.45; global score: -210.2; space size: 8748; measure cnt: 64

launch 64 evaluate tasks
this best socre: -330.45; best score: -330.45; global score: -210.2; space size: 8748; measure cnt: 128
...
launch 64 evaluate tasks
this best socre: -330.45; best score: -330.45; global score: -210.2; space size: 8748; measure cnt: 192
..
launch 64 evaluate tasks
this best socre: -330.45; best score: -330.45; global score: -210.2; space size: 8748; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced strategy that considers:
    
    1. Spatial efficiency (how well the item fits with current and future items)
    2. Bin diversity (encourages spreading items across different bins)
    3. Dynamic expected future item size
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    epsilon = 1e-10  # To avoid division by zero
    bin_count = len(bins)
    valid_bins = bins >= item
    
    # 1. Spatial Efficiency Component
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    
    # Calculate spatial efficiency score
    # Uses a sigmoid function to penalize both too much and too little remaining space
    ideal_remaining = tunable([0.2, 0.3, 0.4])  # Tunable parameter
    spatial_efficiency = 1 / (1 + np.exp(-tunable([2.0, 3.0]) * 
                                        (remaining_capacity[valid_bins] - ideal_remaining)))
    
    # 2. Future Potential Component
    # Dynamic expected future item size based on current item size and bin usage
    expected_future_size = tunable([item * 0.8, item * 1.2, 0.5])  # Tunable parameter
    future_potential = np.where(
        remaining_capacity[valid_bins] > expected_future_size,
        1 / (1 + np.exp(-tunable([1.0, 2.0]) * 
                       (remaining_capacity[valid_bins] - expected_future_size))),
        0.0
    )
    
    # 3. Bin Diversity Component
    # Encourage spreading items across different bins to maintain diversity
    # Uses inverse of bin utilization to promote less utilized bins
    bin_utilization = bins / tunable([np.max(bins), np.mean(bins)])  # Tunable parameter
    diversity_score = 1 / (1 + bin_utilization[valid_bins])
    
    # 4. Combine Components with Tunable Weights
    spatial_weight = tunable([0.5, 0.6, 0.7])  # Weight for spatial efficiency
    future_weight = tunable([0.3, 0.4, 0.5])   # Weight for future potential
    diversity_weight = tunable([0.2, 0.3, 0.4])  # Weight for bin diversity
    
    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero
    
    # Normalize and combine components
    spatial_norm = (spatial_weight / total_weight) * spatial_efficiency
    future_norm = (future_weight / total_weight) * future_potential
    diversity_norm = (diversity_weight / total_weight) * diversity_score
    
    # Calculate final priority scores
    priorities = np.zeros_like(bins, dtype=np.float64)
    priorities[valid_bins] = spatial_norm + future_norm + diversity_norm
    
    return priorities

call llm times: 23
-------------------


.
launch 64 evaluate tasks
this best socre: -215.3; best score: -215.3; global score: -210.2; space size: 1944; measure cnt: 64
....
launch 64 evaluate tasks
this best socre: -215.3; best score: -215.3; global score: -210.2; space size: 1944; measure cnt: 128
..
launch 64 evaluate tasks
this best socre: -215.3; best score: -215.3; global score: -210.2; space size: 1944; measure cnt: 192
.......
launch 64 evaluate tasks
this best socre: -215.3; best score: -215.3; global score: -210.2; space size: 1944; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    sensitivity = tunable([0.5, 0.7, 1.0])  # Sensitivity of the spatial fit function
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** sensitivity)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.7, 1.0])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.7, 0.8, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = tunable([0.5, 0.6, 0.7])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Add exploration factor to prevent getting stuck in local optima
    exploration_scale = tunable([0.1, 0.2, 0.3])
    exploration = exploration_scale * np.random.randn(*priorities.shape)
    priorities += exploration

    return priorities

call llm times: 24
-------------------



launch 64 evaluate tasks
this best socre: -266.45; best score: -266.45; global score: -210.2; space size: 6561; measure cnt: 64
.............................................................................
launch 64 evaluate tasks
this best socre: -260.85; best score: -260.85; global score: -210.2; space size: 6561; measure cnt: 128
..............................................................................................................................................................................................................................................................................
launch 18 evaluate tasks
this best socre: -260.85; best score: -260.85; global score: -210.2; space size: 6561; measure cnt: 146
.................................................................................................................................
launch 5 evaluate tasks
this best socre: -260.85; best score: -260.85; global score: -210.2; space size: 6561; measure cnt: 151
................................................................................................................................................
launch 11 evaluate tasks
this best socre: -260.85; best score: -260.85; global score: -210.2; space size: 6561; measure cnt: 162
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future packing potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where remaining capacity is close to average future item size
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + np.abs(remaining_capacity[valid_bins] - avg_future_size + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    min_remaining = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins near target utilization
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage spreading items across bins
    num_items_per_bin = np.array([len(b) for b in bins])  # Assuming bins are represented as lists of items
    diversity_score = 1.0 / (1.0 + num_items_per_bin)

    # Combine components with tunable weights
    spatial_weight = tunable([0.6, 0.7, 0.8])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    return priorities

call llm times: 25
-------------------


..
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 2187; measure cnt: 64
.......
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 2187; measure cnt: 128
...
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 2187; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and dynamic utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is optimal for future items
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    optimal_remaining = tunable([0.1, 0.2, 0.3])  # Tunable parameter
    spatial_fit[valid_bins] = np.exp(-np.abs(remaining_capacity[valid_bins] - optimal_remaining))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Using a sigmoid function to reward bins with remaining capacity above a certain threshold
    future_potential = np.zeros_like(bins, dtype=np.float64)
    min_remaining = tunable([0.2, 0.3, 0.4])  # Tunable parameter
    future_potential[valid_bins] = 1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - min_remaining)))

    # Utilization score component: Prefer bins that are well-utilized
    # Using a function that peaks at a target utilization level
    target_utilization = tunable([0.8, 0.85, 0.9])  # Tunable parameter
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic weighting based on the current state of packing
    # More weight on future potential early on, shifting towards spatial fit and utilization
    num_bins_used = np.count_nonzero(bins > 0)
    total_bins = len(bins)
    usage_ratio = num_bins_used / total_bins
    weight_spatial = tunable([0.5, 0.6, 0.7]) * (1 - usage_ratio)
    weight_future = tunable([0.3, 0.4, 0.5]) * (1 - usage_ratio)
    weight_utilization = tunable([0.2, 0.3, 0.4]) * usage_ratio

    # Ensure numerical stability and normalize weights
    total_weight = weight_spatial + weight_future + weight_utilization
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (weight_spatial / total_weight) * spatial_fit
    normalized_future = (weight_future / total_weight) * future_potential
    normalized_utilization = (weight_utilization / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Add exploration factor to prevent getting stuck in local optima
    exploration_noise = tunable([0.1, 0.2, 0.3]) * np.random.randn(*priorities.shape)
    priorities += exploration_noise

    return priorities

call llm times: 26
-------------------


...
launch 64 evaluate tasks
this best socre: -331.85; best score: -331.85; global score: -210.2; space size: 2187; measure cnt: 64
..............................
launch 64 evaluate tasks
this best socre: -331.85; best score: -331.85; global score: -210.2; space size: 2187; measure cnt: 128
........................................
launch 64 evaluate tasks
this best socre: -331.55; best score: -331.55; global score: -210.2; space size: 2187; measure cnt: 192
.............................................
launch 64 evaluate tasks
this best socre: -331.55; best score: -331.55; global score: -210.2; space size: 2187; measure cnt: 256
..........................................
launch 64 evaluate tasks
this best socre: -331.55; best score: -331.55; global score: -210.2; space size: 2187; measure cnt: 320
......................................................................
launch 64 evaluate tasks
this best socre: -331.45; best score: -331.45; global score: -210.2; space size: 2187; measure cnt: 384
.......................................................................
launch 64 evaluate tasks
this best socre: -331.45; best score: -331.45; global score: -210.2; space size: 2187; measure cnt: 448
....................................................................................
launch 64 evaluate tasks
this best socre: -331.45; best score: -331.45; global score: -210.2; space size: 2187; measure cnt: 512
.................................................................................................................................................
launch 64 evaluate tasks
this best socre: -331.45; best score: -331.45; global score: -210.2; space size: 2187; measure cnt: 576
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    epsilon = 1e-10  # To avoid division by zero
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial Fit: Rewards bins where the item fits well, penalizes too much or too little space
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    optimal_remaining = tunable([0.1, 0.2, 0.3], 0.2)  # Optimal remaining space for good fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + np.abs(remaining_capacity[valid_bins] - optimal_remaining))

    # Future Potential: Assesses ability to fit future items
    future_sizes = tunable([0.1, 0.2, 0.3], [0.1, 0.2, 0.3])  # Expected future item sizes
    future_penalty = tunable([0.1, 0.2, 0.3], 0.2)  # Penalty for poor future fit
    future_potential = np.zeros_like(bins, dtype=np.float64)
    for size in future_sizes:
        future_remaining = remaining_capacity - size
        suitable = future_remaining > 0
        future_potential[valid_bins] += np.where(suitable, 1.0 / (1.0 + future_remaining[suitable]), 0.0)
    future_potential = future_potential / len(future_sizes)  # Normalize by number of future sizes

    # Utilization Score: Prefers bins that are well-utilized
    target_utilization = tunable([0.7, 0.8, 0.9], 0.8)  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = tunable([0.4, 0.5, 0.6], 0.5)
    future_weight = tunable([0.3, 0.4, 0.5], 0.4)
    utilization_weight = tunable([0.2, 0.3, 0.4], 0.3)

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Apply tunable penalty for bins with too little remaining space
    min_remaining = tunable([0.1, 0.2, 0.3], 0.2)
    penalty_factor = tunable([0.5, 0.6, 0.7], 0.5)
    penalty_mask = remaining_capacity < min_remaining
    normalized_spatial[penalty_mask] *= penalty_factor
    normalized_future[penalty_mask] *= penalty_factor

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities

call llm times: 27
-------------------


...................................................................
launch 6 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 6; measure cnt: 6
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 2)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    min_remaining = tunable([0.2, 0.3, 0.4])  # Tunable parameter
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - min_remaining))),
        0.0
    )

    # Utilization score component: Prefer bins near target utilization
    target_utilization = tunable([0.8, 0.9])  # Tunable parameter
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Penalize bins with similar remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    for i in range(len(bins)):
        if valid_bins[i]:
            # Compare with other bins to measure similarity
            similarity = np.sum(np.abs(remaining_capacity[i] - remaining_capacity[valid_bins]) < tunable([0.1, 0.2]))
            diversity_score[i] = 1.0 / (1.0 + similarity)

    # Combine components with tunable weights
    spatial_weight = tunable([0.6, 0.7, 0.8])  # Tunable parameter
    future_weight = tunable([0.3, 0.4, 0.5])   # Tunable parameter
    utilization_weight = tunable([0.2, 0.3, 0.4])  # Tunable parameter
    diversity_weight = tunable([0.1, 0.2, 0.3])    # Tunable parameter

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    return priorities

call llm times: 28
-------------------


..
launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 972; measure cnt: 64
.......
launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 972; measure cnt: 128
...............
launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 972; measure cnt: 192
.......................
launch 64 evaluate tasks
this best socre: -211.25; best score: -211.25; global score: -210.2; space size: 972; measure cnt: 256
.................................
launch 64 evaluate tasks
current thread_i 7
errrrrrr launch_llm Can not find core code.
this best socre: -211.25; best score: -211.25; global score: -210.2; space size: 972; measure cnt: 320
..................................................
launch 64 evaluate tasks
this best socre: -211.25; best score: -211.25; global score: -210.2; space size: 972; measure cnt: 384
...................................................
launch 64 evaluate tasks
this best socre: -211.25; best score: -211.25; global score: -210.2; space size: 972; measure cnt: 448
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.6
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.15
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.6
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.15
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...request...request...request...


-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.6
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.15
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.6
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.15
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.6
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.15
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.6
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.15
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and penalties.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    epsilon = 1e-10  # To avoid division by zero
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.75  # Expected average size of future items
    min_remaining = 0.3     # Minimum acceptable remaining capacity
    max_remaining = 1.5     # Maximum acceptable remaining capacity

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.8  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Penalty for bins with very large remaining capacities
    penalty_factor = 0.5  # Penalty factor to reduce priority
    large_remaining_penalty = np.where(remaining_capacity > max_remaining, penalty_factor, 1.0)

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Apply penalties
    priorities = normalized_spatial + normalized_future + normalized_utilization
    priorities = priorities * large_remaining_penalty

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 2)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    min_remaining = 0.2  # Tunable parameter
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - min_remaining))),
        0.0
    )

    # Utilization score component: Prefer bins near target utilization
    target_utilization = 0.8  # Tunable parameter
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Penalize bins with similar remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    for i in range(len(bins)):
        if valid_bins[i]:
            # Compare with other bins to measure similarity
            similarity = np.sum(np.abs(remaining_capacity[i] - remaining_capacity[valid_bins]) < 0.2)
            diversity_score[i] = 1.0 / (1.0 + similarity)

    # Combine components with tunable weights
    spatial_weight = 0.8  # Tunable parameter
    future_weight = 0.3   # Tunable parameter
    utilization_weight = 0.2  # Tunable parameter
    diversity_weight = 0.2    # Tunable parameter

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and penalties.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    epsilon = 1e-10  # To avoid division by zero
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.75  # Expected average size of future items
    min_remaining = 0.3     # Minimum acceptable remaining capacity
    max_remaining = 1.5     # Maximum acceptable remaining capacity

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.8  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Penalty for bins with very large remaining capacities
    penalty_factor = 0.5  # Penalty factor to reduce priority
    large_remaining_penalty = np.where(remaining_capacity > max_remaining, penalty_factor, 1.0)

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Apply penalties
    priorities = normalized_spatial + normalized_future + normalized_utilization
    priorities = priorities * large_remaining_penalty

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2   # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    penalty_factor = tunable([0.5, 0.6, 0.7])
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < tunable([0.2, 0.3, 0.4]),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**2 * penalty_factor),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.1, 0.2, 0.3])
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.15, 0.2, 0.25])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * tunable([0.5, 0.6, 0.7]), priorities)

    return priorities

call llm times: 29
-------------------


current thread_i 5

launch 64 evaluate tasks
this best socre: -210.5; best score: -210.5; global score: -210.2; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.5; best score: -210.5; global score: -210.2; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.45; best score: -210.45; global score: -210.2; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
current thread_i 0
this best socre: -210.45; best score: -210.45; global score: -210.2; space size: 531441; measure cnt: 256

launch 64 evaluate tasks
current thread_i 3
current thread_i 2
this best socre: -210.45; best score: -210.45; global score: -210.2; space size: 531441; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.45; best score: -210.45; global score: -210.2; space size: 531441; measure cnt: 384
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced strategy that:
    
    1. Considers both immediate spatial fit and future packing potential
    2. Uses dynamic parameter adjustment based on packing progress
    3. Incorporates item diversity considerations
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
        
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0
    
    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # To avoid division by zero
    
    # Dynamic spatial fit calculation based on item size relative to bin capacity
    max_capacity = np.max(bins)
    item_size_ratio = item / max_capacity
    tightness_factor = tunable([0.8, 0.9, 1.0])
    
    spatial_fit[valid_bins] = tightness_factor / (1.0 + (remaining_capacity[valid_bins] + epsilon) / max_capacity)
    
    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Dynamic parameters based on current packing state
    bins_used = len(bins) - np.count_nonzero(bins == 0)
    total_bins = len(bins)
    progress = bins_used / total_bins if total_bins > 0 else 0
    expected_future_items = tunable([5, 10, 15])
    
    # Adaptive future potential calculation
    min_remaining = tunable([0.2, 0.3, 0.4]) * max_capacity
    max_remaining = tunable([1.0, 1.2, 1.5]) * max_capacity
    
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - tunable([0.5, 0.7, 1.0]) * max_capacity))),
        0.0
    )
    
    # Utilization score component: Prefer bins that are neither too empty nor too full
    # Dynamic target utilization based on packing progress
    target_utilization = tunable([0.7, 0.8, 0.9]) + (1.0 - tunable([0.7, 0.8, 0.9])) * progress
    utilization = bins / max_capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))
    
    # Dynamic weight adjustment based on remaining items
    remaining_items = tunable([5, 10, 15]) - (bins_used * tunable([1.0, 1.5, 2.0]))
    weight_modulation = np.clip(remaining_items / tunable([5, 10, 15]), 0.0, 1.0)
    
    # Combine components with tunable weights
    spatial_weight = tunable([0.6, 0.7, 0.8])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])
    
    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero
        
    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    
    # Apply dynamic weight modulation
    priorities = normalized_spatial + normalized_future + normalized_utilization
    priorities = priorities * (1.0 + weight_modulation)
    
    # Apply penalties for bins with very large remaining capacities
    large_remaining_penalty = np.where(remaining_capacity > max_remaining, 
                                     tunable([0.5, 0.6, 0.7]), 1.0)
    priorities = priorities * large_remaining_penalty
    
    return priorities

call llm times: 30
-------------------



launch 64 evaluate tasks
current thread_i 9
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 4782969; measure cnt: 64

launch 64 evaluate tasks
current thread_i 1
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 4782969; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 4782969; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = tunable([2.0, 3.0])  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])    # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.85])
    future_weight = tunable([0.3, 0.4, 0.45])
    utilization_weight = tunable([0.3, 0.35, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.15, 0.2])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 31
-------------------



launch 64 evaluate tasks
current thread_i 4
current thread_i 8
this best socre: -210.25; best score: -210.25; global score: -210.2; space size: 39366; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -210.2; space size: 39366; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.1; best score: -210.1; global score: -210.1; space size: 39366; measure cnt: 192
..
launch 64 evaluate tasks
current thread_i 6
this best socre: -210.05; best score: -210.05; global score: -210.05; space size: 39366; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -210.05; space size: 39366; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -210.05; space size: 39366; measure cnt: 384
.
launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -210.05; space size: 39366; measure cnt: 448
sampler suggest should end sample, break
INFO:absl:Best score increased to -210.05
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Consider a distribution of expected future item sizes
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Reward bins that leave a unique remaining capacity
    # Calculate the distribution of remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Calculate how unique each remaining capacity is
        # Using a Gaussian kernel to measure similarity
        sigma = tunable([0.1, 0.2, 0.3])
        similarities = np.exp(-np.abs(rc_values - rc_values[:, np.newaxis]) ** 2 / (2 * sigma ** 2))
        # Sum of similarities (lower sum means more unique)
        sum_similarities = np.sum(similarities, axis=1)
        # Invert to get higher score for more unique
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.15, 0.2, 0.25])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 32
-------------------



launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -210.05; space size: 59049; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -210.05; space size: 59049; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -210.05; space size: 59049; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 59049; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 59049; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 59049; measure cnt: 384

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 59049; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is a small fraction of bin capacity
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    bin_capacity = np.max(bins) if bins.size > 0 else 1.0
    spatial_weight = tunable([0.7, 0.6, 0.8])
    
    # Calculate spatial fit dynamically based on item size relative to bin capacity
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) / bin_capacity)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Use dynamic average based on past items and consider multiple future scenarios
    avg_future_size = tunable([0.5, 0.6, 0.4])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.1])    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    
    # Enhanced future potential calculation considering multiple scenarios
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.9, 0.85, 0.95])  # Target utilization level
    utilization = bins / bin_capacity  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    future_weight = tunable([0.4, 0.5, 0.3])
    utilization_weight = tunable([0.4, 0.3, 0.5])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores with additional diversity factor
    diversity_factor = tunable([0.1, 0.15, 0.2])  # Penalty for choosing the same bin consecutively
    # (Assuming a mechanism to track recent choices is in place)

    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.15, 0.2, 0.1])
    penalty_factor = tunable([0.5, 0.6, 0.4])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 33
-------------------



launch 64 evaluate tasks
this best socre: -215.4; best score: -215.4; global score: -210.05; space size: 19683; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -215.4; best score: -215.4; global score: -210.05; space size: 19683; measure cnt: 128

launch 64 evaluate tasks
this best socre: -215.4; best score: -215.4; global score: -210.05; space size: 19683; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -215.4; best score: -215.4; global score: -210.05; space size: 19683; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, bin diversity, and dynamic utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    optimal_remaining = tunable([0.1, 0.2])  # Optimal remaining capacity for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + np.abs(remaining_capacity[valid_bins] - optimal_remaining) + epsilon)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3])    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Bin diversity component: Penalize bins that are too different from others
    avg_remaining = np.mean(remaining_capacity[valid_bins]) if np.any(valid_bins) else 0.0
    diversity_penalty = np.exp(-np.abs(remaining_capacity - avg_remaining))
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_score[valid_bins] = diversity_penalty[valid_bins]

    # Dynamic utilization component: Adjust target based on current bin states
    target_utilization = tunable([0.85, 0.9, 0.95])  # Dynamic target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8])
    future_weight = tunable([0.4, 0.5])
    diversity_weight = tunable([0.3, 0.4])
    utilization_weight = tunable([0.4, 0.5])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + diversity_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_diversity = (diversity_weight / total_weight) * diversity_score
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_diversity + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.15, 0.2])
    penalty_factor = tunable([0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 34
-------------------


..
launch 64 evaluate tasks
this best socre: -214.25; best score: -214.25; global score: -210.05; space size: 1536; measure cnt: 64
..
launch 64 evaluate tasks
this best socre: -214.25; best score: -214.25; global score: -210.05; space size: 1536; measure cnt: 128
......
launch 64 evaluate tasks
this best socre: -214.25; best score: -214.25; global score: -210.05; space size: 1536; measure cnt: 192
.............
launch 64 evaluate tasks
this best socre: -214.25; best score: -214.25; global score: -210.05; space size: 1536; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + np.exp(remaining_capacity[valid_bins] / (bins[valid_bins] + epsilon)))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.4, 0.5, 0.6])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Reward bins that maintain diversity in remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate the variance of remaining capacities across bins
        variance = np.var(remaining_capacity)
        diversity_score = np.exp(-np.abs(variance - tunable([0.1, 0.2, 0.3])))

    # Dynamic weights based on current state
    avg_remaining = np.mean(remaining_capacity[valid_bins]) if np.any(valid_bins) else 0.0
    if avg_remaining < tunable([0.3, 0.4]):
        spatial_weight = tunable([0.5, 0.6, 0.7])
        future_weight = tunable([0.4, 0.5, 0.6])
        utilization_weight = tunable([0.3, 0.4, 0.5])
        diversity_weight = tunable([0.2, 0.3, 0.4])
    else:
        spatial_weight = tunable([0.6, 0.7, 0.8])
        future_weight = tunable([0.5, 0.6, 0.7])
        utilization_weight = tunable([0.4, 0.5, 0.6])
        diversity_weight = tunable([0.3, 0.4, 0.5])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.15, 0.2])
    penalty_factor = tunable([0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 35
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.05; space size: 4251528; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.05; space size: 4251528; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.05; space size: 4251528; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well, with optimal remaining space
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # To avoid division by zero

    # Tunable parameters for spatial fit
    ideal_remaining = tunable([0.2, 0.3, 0.4])  # Ideal remaining capacity after placing the item
    max_spatial_reward = tunable([1.0, 0.95, 0.9])  # Maximum reward for spatial fit

    # Calculate spatial fit using a quadratic function that peaks at ideal_remaining
    valid_remaining = remaining_capacity[valid_bins]
    spatial_fit[valid_bins] = max_spatial_reward * np.exp(
        -((valid_remaining - ideal_remaining) ** 2) / (2 * (0.1 ** 2) + epsilon)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)

    # Tunable parameters for future potential
    expected_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_for_future = tunable([0.1, 0.2, 0.3])  # Minimum acceptable remaining capacity for future items
    max_remaining_for_future = tunable([1.0, 1.2, 1.5])  # Maximum acceptable remaining capacity for future items

    # Calculate future potential using a quadratic function that penalizes extremes
    future_potential[valid_bins] = np.where(
        valid_remaining > min_remaining_for_future,
        np.where(
            valid_remaining < max_remaining_for_future,
            1.0 - ((valid_remaining - expected_future_size) ** 2) / (max_remaining_for_future ** 2 + epsilon),
            0.0
        ),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    utilization_score = np.zeros_like(bins, dtype=np.float64)

    # Tunable parameters for utilization
    target_utilization = tunable([0.7, 0.8, 0.9])  # Target utilization level
    max_bin_capacity = np.max(bins) if np.max(bins) != 0 else 1.0  # Avoid division by zero

    utilization = bins / max_bin_capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = tunable([0.6, 0.7, 0.8])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    return priorities

call llm times: 36
-------------------



launch 64 evaluate tasks
this best socre: -220.35; best score: -220.35; global score: -210.05; space size: 19683; measure cnt: 64

launch 64 evaluate tasks
this best socre: -220.35; best score: -220.35; global score: -210.05; space size: 19683; measure cnt: 128

launch 64 evaluate tasks
this best socre: -220.35; best score: -220.35; global score: -210.05; space size: 19683; measure cnt: 192

launch 64 evaluate tasks
this best socre: -220.35; best score: -220.35; global score: -210.05; space size: 19683; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where remaining capacity is optimal for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected future item size
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + np.abs(remaining_capacity[valid_bins] - avg_future_size) + epsilon)

    # Future potential component: Reward bins with remaining capacity above a tunable threshold
    min_remaining = tunable([0.2, 0.3, 0.4])
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - min_remaining))),
        0.0
    )

    # Utilization score component: Prefer bins near target utilization
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Penalize bins with similar remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    similarity_threshold = tunable([0.1, 0.2, 0.3])
    for i in range(len(bins)):
        if valid_bins[i]:
            # Compare with other valid bins to measure similarity
            similarity = np.sum(np.abs(remaining_capacity[i] - remaining_capacity[valid_bins]) < similarity_threshold)
            diversity_score[i] = 1.0 / (1.0 + similarity)

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    return priorities

call llm times: 37
-------------------



launch 64 evaluate tasks
this best socre: -211.4; best score: -211.4; global score: -210.05; space size: 6561; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -211.0; best score: -211.0; global score: -210.05; space size: 6561; measure cnt: 128
...
launch 64 evaluate tasks
this best socre: -211.0; best score: -211.0; global score: -210.05; space size: 6561; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -210.05; space size: 6561; measure cnt: 256
..
launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -210.05; space size: 6561; measure cnt: 320
....
launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -210.05; space size: 6561; measure cnt: 384
......
launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 6561; measure cnt: 448
....
launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 6561; measure cnt: 512
..........
launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 6561; measure cnt: 576
..........
launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 6561; measure cnt: 640
sampler suggest should end sample, break
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    penalty_factor = 0.5
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < 0.2,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**2 * penalty_factor),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * 0.7, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.45
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    penalty_factor = 0.5
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < 0.2,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**2 * penalty_factor),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * 0.7, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.45
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    penalty_factor = 0.5
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < 0.2,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**2 * penalty_factor),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * 0.7, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.45
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    penalty_factor = 0.5
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < 0.2,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**2 * penalty_factor),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * 0.7, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.45
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Consider a distribution of expected future item sizes
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Reward bins that leave a unique remaining capacity
    # Calculate the distribution of remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Calculate how unique each remaining capacity is
        # Using a Gaussian kernel to measure similarity
        sigma = 0.3
        similarities = np.exp(-np.abs(rc_values - rc_values[:, np.newaxis]) ** 2 / (2 * sigma ** 2))
        # Sum of similarities (lower sum means more unique)
        sum_similarities = np.sum(similarities, axis=1)
        # Invert to get higher score for more unique
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.3
    utilization_weight = 0.3
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.15
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.45
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where remaining capacity is optimal for future items
    avg_future_size = 0.6  # Expected future item size
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + np.abs(remaining_capacity[valid_bins] - avg_future_size) + epsilon)

    # Future potential component: Reward bins with remaining capacity above a tunable threshold
    min_remaining = 0.3
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - min_remaining))),
        0.0
    )

    # Utilization score component: Prefer bins near target utilization
    target_utilization = 0.8  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Penalize bins with similar remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    similarity_threshold = 0.1
    for i in range(len(bins)):
        if valid_bins[i]:
            # Compare with other valid bins to measure similarity
            similarity = np.sum(np.abs(remaining_capacity[i] - remaining_capacity[valid_bins]) < similarity_threshold)
            diversity_score[i] = 1.0 / (1.0 + similarity)

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.3
    utilization_weight = 0.4
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.45
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where remaining capacity is optimal for future items
    avg_future_size = 0.6  # Expected future item size
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + np.abs(remaining_capacity[valid_bins] - avg_future_size) + epsilon)

    # Future potential component: Reward bins with remaining capacity above a tunable threshold
    min_remaining = 0.3
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - min_remaining))),
        0.0
    )

    # Utilization score component: Prefer bins near target utilization
    target_utilization = 0.8  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Penalize bins with similar remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    similarity_threshold = 0.1
    for i in range(len(bins)):
        if valid_bins[i]:
            # Compare with other valid bins to measure similarity
            similarity = np.sum(np.abs(remaining_capacity[i] - remaining_capacity[valid_bins]) < similarity_threshold)
            diversity_score[i] = 1.0 / (1.0 + similarity)

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.3
    utilization_weight = 0.4
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.45
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Consider a distribution of expected future item sizes
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Reward bins that leave a unique remaining capacity
    # Calculate the distribution of remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Calculate how unique each remaining capacity is
        # Using a Gaussian kernel to measure similarity
        sigma = 0.3
        similarities = np.exp(-np.abs(rc_values - rc_values[:, np.newaxis]) ** 2 / (2 * sigma ** 2))
        # Sum of similarities (lower sum means more unique)
        sum_similarities = np.sum(similarities, axis=1)
        # Invert to get higher score for more unique
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.3
    utilization_weight = 0.3
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.15
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.45
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Consider a distribution of expected future item sizes
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size))),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Reward bins that leave a unique remaining capacity
    # Calculate the distribution of remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Calculate how unique each remaining capacity is
        # Using a Gaussian kernel to measure similarity
        sigma = 0.3
        similarities = np.exp(-np.abs(rc_values - rc_values[:, np.newaxis]) ** 2 / (2 * sigma ** 2))
        # Sum of similarities (lower sum means more unique)
        sum_similarities = np.sum(similarities, axis=1)
        # Invert to get higher score for more unique
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.3
    utilization_weight = 0.3
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.15
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, and utilization with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.45
    utilization_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = tunable([2.0, 3.0, 4.0])  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])    # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Penalize bins with similar remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    similarity_threshold = tunable([0.05, 0.1, 0.15])  # Threshold for considering bins similar
    for i in range(len(bins)):
        if valid_bins[i]:
            # Compare with other valid bins to measure similarity
            similarity = np.sum(np.abs(remaining_capacity[i] - remaining_capacity[valid_bins]) < similarity_threshold)
            diversity_score[i] = 1.0 / (1.0 + similarity)

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.85])
    future_weight = tunable([0.2, 0.3, 0.4])
    utilization_weight = tunable([0.1, 0.2, 0.3])
    diversity_weight = tunable([0.1, 0.15, 0.2])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.15, 0.2])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 38
-------------------


current thread_i 9

launch 64 evaluate tasks
current thread_i 4
current thread_i 2
current thread_i 0
current thread_i 6
current thread_i 3
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
current thread_i 8
current thread_i 5
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
current thread_i 1
this best socre: -210.75; best score: -210.75; global score: -210.05; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -210.05; space size: 531441; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -210.05; space size: 531441; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -210.05; space size: 531441; measure cnt: 384

launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -210.05; space size: 531441; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using a novel hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = tunable([0.1, 0.2, 0.3]) * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > tunable([0.3, 0.4, 0.5]),
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-tunable([0.1, 0.2, 0.3]) * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.6, 0.7, 0.8])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.15, 0.2, 0.25])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 39
-------------------



launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -209.95; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -209.95; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -209.95; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -209.95; space size: 531441; measure cnt: 256
sampler suggest should end sample, break
INFO:absl:Best score increased to -209.95
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is just enough
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = tunable([2.0, 3.0, 4.0])  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Using an adaptive average based on past items
    min_remaining = tunable([0.3, 0.4, 0.5])  # Tunable minimum acceptable remaining capacity
    decay_rate = tunable([0.2, 0.3, 0.4])     # Tunable decay rate for large remaining capacities

    # Calculate expected future item size based on past items (simplified example)
    # In a real scenario, this would be replaced with a more sophisticated prediction model
    expected_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - expected_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.9, 0.95, 0.98])  # Tunable target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Reward bins that leave a unique remaining capacity
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Calculate how unique each remaining capacity is using a tunable sigma
        sigma = tunable([0.2, 0.3, 0.4])  # Tunable sigma for diversity calculation
        similarities = np.exp(-np.abs(rc_values - rc_values[:, np.newaxis]) ** 2 / (2 * sigma ** 2))
        sum_similarities = np.sum(similarities, axis=1)
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])    # Tunable weight for spatial fit
    future_weight = tunable([0.4, 0.5, 0.6])     # Tunable weight for future potential
    utilization_weight = tunable([0.3, 0.4, 0.5]) # Tunable weight for utilization
    diversity_weight = tunable([0.3, 0.4, 0.5])   # Tunable weight for diversity

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalties
    penalty_threshold = tunable([0.1, 0.15, 0.2])  # Tunable threshold for applying penalties
    penalty_factor = tunable([0.5, 0.6, 0.7])      # Tunable penalty factor
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    # Additional penalty for bins that are too full
    full_penalty_threshold = tunable([0.9, 0.95, 0.98])  # Tunable threshold for full bins
    full_penalty_factor = tunable([0.5, 0.6, 0.7])       # Tunable penalty factor for full bins
    priorities = np.where(bins > full_penalty_threshold, priorities * full_penalty_factor, priorities)

    return priorities

call llm times: 40
-------------------



launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -209.95; space size: 4782969; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -209.95; space size: 4782969; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -209.95; space size: 4782969; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -209.95; space size: 4782969; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and bin similarity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = tunable([2.0, 3.0, 4.0])  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])    # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.9, 0.95, 1.0])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Bin similarity component: Penalize bins with similar remaining capacities
    similarity_penalty = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Calculate pairwise differences
        pairwise_diffs = np.abs(rc_values[:, np.newaxis] - rc_values)
        # Apply a penalty based on the number of similar bins
        similarity_count = np.sum(np.where(pairwise_diffs < tunable([0.1, 0.2]), 1, 0), axis=1)
        similarity_penalty[valid_bins] = 1.0 / (1.0 + similarity_count)

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.85, 0.9])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])
    similarity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + similarity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_similarity = (similarity_weight / total_weight) * similarity_penalty

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_similarity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.15, 0.2])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 41
-------------------



launch 64 evaluate tasks
this best socre: -210.85; best score: -210.85; global score: -209.95; space size: 354294; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.85; best score: -210.85; global score: -209.95; space size: 354294; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -209.95; space size: 354294; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -209.95; space size: 354294; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.3; best score: -210.3; global score: -209.95; space size: 354294; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.3; best score: -210.3; global score: -209.95; space size: 354294; measure cnt: 384

launch 64 evaluate tasks
this best socre: -210.3; best score: -210.3; global score: -209.95; space size: 354294; measure cnt: 448
.
launch 64 evaluate tasks
this best socre: -210.3; best score: -210.3; global score: -209.95; space size: 354294; measure cnt: 512
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = tunable([2.0, 3.0, 4.0])  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])    # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.1, 0.2, 0.3])
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.85])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 42
-------------------



launch 64 evaluate tasks
this best socre: -210.1; best score: -210.1; global score: -209.95; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.1; best score: -210.1; global score: -209.95; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.1; best score: -210.1; global score: -209.95; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -209.95; space size: 531441; measure cnt: 256

launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -209.95; space size: 531441; measure cnt: 320

launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -209.95; space size: 531441; measure cnt: 384

launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -209.95; space size: 531441; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering:
    
    1. Spatial fit: How well the item fits in the bin
    2. Future potential: Bin's ability to accommodate future items
    3. Utilization balance: Prevent bins from becoming too full or too empty
    4. Dynamic adaptation: Adjust strategy based on current bin distribution
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
        
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0
    
    # 1. Spatial Fit Component
    # Reward bins where item fits well, penalize large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Tunable parameters for spatial fit
    fit_mode = tunable(['sigmoid', 'inverse'], index=0)  # Options: 'sigmoid', 'inverse'
    ideal_fit = tunable([0.1, 0.2, 0.3])  # Ideal remaining capacity after fit
    
    if fit_mode == 'sigmoid':
        # Sigmoid-based fit that peaks at ideal_fit
        spatial_fit[valid_bins] = 1.0 / (1.0 + np.exp(-tunable([5.0, 10.0]) * 
                                                      (remaining_capacity[valid_bins] - ideal_fit)))
    else:
        # Inverse relationship with tunable exponent
        exponent = tunable([2.0, 3.0, 4.0])
        spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)
    
    # 2. Future Potential Component
    # Reward bins that maintain enough capacity for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    
    # Tunable parameters for future potential
    min_remaining = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    future_item_size = tunable([0.5, 0.6, 0.7])  # Expected size of future items
    
    # Calculate potential based on remaining capacity after current item
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - future_item_size))),
        0.0
    )
    
    # 3. Utilization Balance Component
    # Prevent bins from becoming too full or too empty
    utilization_balance = np.zeros_like(bins, dtype=np.float64)
    
    # Tunable parameters for utilization balance
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    balance_strength = tunable([1.0, 2.0, 3.0])  # Strength of balance penalty
    
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_balance = np.exp(-balance_strength * np.abs(utilization - target_utilization))
    
    # 4. Dynamic Adaptation Component
    # Adjust strategy based on current bin distribution
    dynamic_adaptation = np.zeros_like(bins, dtype=np.float64)
    
    # Tunable parameters for dynamic adaptation
    diversity_weight = tunable([0.1, 0.2, 0.3])  # Weight for diversity encouragement
    load_factor = tunable([0.5, 0.7, 0.9])  # Factor for load-based adjustment
    
    if len(bins) > 1:
        # Encourage diversity in remaining capacities
        diversity_score = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        dynamic_adaptation[valid_bins] = diversity_score
        
        # Penalize bins that are too similar to the average load
        average_load = np.mean(bins)
        dynamic_adaptation += load_factor * np.exp(-np.abs(bins - average_load))
    
    # Combine components with tunable weights
    weights = {
        'spatial': tunable([0.6, 0.7, 0.8]),
        'future': tunable([0.3, 0.4, 0.5]),
        'balance': tunable([0.2, 0.3, 0.4]),
        'dynamic': tunable([0.1, 0.2, 0.3])
    }
    
    # Ensure numerical stability and normalize weights
    total_weight = sum(weights.values())
    if total_weight == 0:
        total_weight = 1.0
        
    normalized_spatial = (weights['spatial'] / total_weight) * spatial_fit
    normalized_future = (weights['future'] / total_weight) * future_potential
    normalized_balance = (weights['balance'] / total_weight) * utilization_balance
    normalized_dynamic = (weights['dynamic'] / total_weight) * dynamic_adaptation
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_balance + normalized_dynamic
    
    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)
    
    return priorities

call llm times: 43
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.95; space size: 9565938; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.95; space size: 9565938; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.95; space size: 9565938; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = tunable([2.0, 3.0, 4.0])  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.3, 0.4, 0.5])    # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.85])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 44
-------------------



launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -209.95; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -209.95; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -209.95; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -209.95; space size: 531441; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -209.95; space size: 531441; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with tunable parameters
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = tunable([2.0, 3.0, 4.0])  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])    # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near target utilization
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Penalize bins with similar remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    similarity_threshold = tunable([0.05, 0.1, 0.15])  # Tunable similarity threshold
    for i in range(len(bins)):
        if valid_bins[i]:
            # Compare with other valid bins to measure similarity
            similarity = np.sum(np.abs(remaining_capacity[i] - remaining_capacity[valid_bins]) < similarity_threshold)
            diversity_score[i] = 1.0 / (1.0 + similarity)

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.85])
    future_weight = tunable([0.2, 0.3, 0.4])
    utilization_weight = tunable([0.1, 0.2, 0.3])
    diversity_weight = tunable([0.1, 0.15, 0.2])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.15, 0.2])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 45
-------------------



launch 64 evaluate tasks
this best socre: -210.9; best score: -210.9; global score: -209.95; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -209.95; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -209.95; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -209.95; space size: 531441; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -209.95; space size: 531441; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = tunable([1.0, 2.0, 3.0])  # Tunable exponent
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Using a dynamic average of recent item sizes (assumed to be passed or tracked)
    # For demonstration, we'll use a placeholder value; in practice, this should be dynamic
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.3, 0.4, 0.5])    # Minimum acceptable remaining capacity
    decay_rate = tunable([0.2, 0.3, 0.4])       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins within a target utilization range
    target_util_lower = tunable([0.8, 0.85, 0.9])
    target_util_upper = tunable([0.95, 1.0, 1.05])
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - tunable([0.9, 0.95, 1.0])))

    # Diversity component: Reward bins with less common remaining capacities
    # Using frequency-based diversity
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Bin remaining capacities into intervals
        num_bins = tunable([5, 10, 15])
        bin_edges = np.linspace(0, np.max(rc_values), num_bins + 1)
        bin_indices = np.digitize(rc_values, bin_edges)
        # Calculate frequency of each bin
        freq = np.bincount(bin_indices, minlength=num_bins + 1)
        # Avoid division by zero
        freq = np.where(freq == 0, 1, freq)
        # Higher score for less frequent bins
        diversity_score[valid_bins] = 1.0 / freq[bin_indices]

    # Bin lifespan component: Reward bins with fewer items
    # Assuming we have access to the number of items in each bin
    # For demonstration, we'll use a placeholder array; in practice, this should be tracked
    items_per_bin = np.array([tunable([1, 2, 3])] * len(bins))
    lifespan_weight = tunable([0.1, 0.2, 0.3])
    lifespan_score = np.exp(-lifespan_weight * items_per_bin)

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.85, 0.9])
    future_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.2, 0.3, 0.4])
    lifespan_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = (
        spatial_weight + future_weight + utilization_weight + 
        diversity_weight + lifespan_weight
    )
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score
    normalized_lifespan = (lifespan_weight / total_weight) * lifespan_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial + normalized_future + normalized_utilization +
        normalized_diversity + normalized_lifespan
    )

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.15, 0.2])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 46
-------------------



launch 64 evaluate tasks
this best socre: -212.4; best score: -212.4; global score: -209.95; space size: 129140163; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.35; best score: -212.35; global score: -209.95; space size: 129140163; measure cnt: 128

launch 64 evaluate tasks
this best socre: -212.35; best score: -212.35; global score: -209.95; space size: 129140163; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.35; best score: -212.35; global score: -209.95; space size: 129140163; measure cnt: 256

launch 64 evaluate tasks
this best socre: -212.35; best score: -212.35; global score: -209.95; space size: 129140163; measure cnt: 320
sampler suggest should end sample, break
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using a novel hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.3 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.3,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.3 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.3
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.1       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.6
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 4.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.3
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using a novel hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.3 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.3,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.3 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.3
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using a novel hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.3 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.3,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.3 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.3
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.1       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.6
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.1       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.6
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using a novel hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.3 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.3,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.3 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.3
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
request...request...-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.1       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.6
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using a novel hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.3 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.3,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.3 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.3
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 4.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.3
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.1       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.6
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------


-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 4.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.3
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.1       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.6
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and bin similarity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 4.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2    # Minimum acceptable remaining capacity
    decay_rate = 0.3       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Bin similarity component: Penalize bins with similar remaining capacities
    similarity_penalty = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Calculate pairwise differences
        pairwise_diffs = np.abs(rc_values[:, np.newaxis] - rc_values)
        # Apply a penalty based on the number of similar bins
        similarity_count = np.sum(np.where(pairwise_diffs < 0.1, 1, 0), axis=1)
        similarity_penalty[valid_bins] = 1.0 / (1.0 + similarity_count)

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.3
    similarity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + similarity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_similarity = (similarity_weight / total_weight) * similarity_penalty

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_similarity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.1       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.6
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.1       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.6
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using a novel hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.3 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.3,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.3 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.3
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, using an enhanced strategy.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.4, 0.5, 0.6])  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > tunable([0.2, 0.3, 0.4]),
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-tunable([0.2, 0.3, 0.4]) * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.4, 0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 47
-------------------



current thread_i 5
launch 64 evaluate tasks
current thread_i 3
current thread_i 0
current thread_i 2
this best socre: -209.8; best score: -209.8; global score: -209.8; space size: 177147; measure cnt: 64

launch 64 evaluate tasks
current thread_i 9
current thread_i 1
this best socre: -209.8; best score: -209.8; global score: -209.8; space size: 177147; measure cnt: 128

launch 64 evaluate tasks
current thread_i 8
current thread_i 6
this best socre: -209.8; best score: -209.8; global score: -209.8; space size: 177147; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.8; best score: -209.8; global score: -209.8; space size: 177147; measure cnt: 256
sampler suggest should end sample, break
INFO:absl:Best score increased to -209.8
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, diversity, and load balancing with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = tunable([3.0, 4.0, 5.0])  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.4, 0.5, 0.6])  # Expected average size of future items
    min_remaining = tunable([0.2, 0.3, 0.4])    # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Load balancing component: Distribute items evenly across bins
    load_balancing = np.zeros_like(bins, dtype=np.float64)
    load_balancing[valid_bins] = 1.0 / (1.0 + (np.sort(bins)[::-1].argsort() + 1) ** 2)

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.6, 0.7, 0.8])
    utilization_weight = tunable([0.5, 0.6, 0.7])
    diversity_weight = tunable([0.2, 0.3, 0.4])
    balancing_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = (
        spatial_weight + future_weight + utilization_weight + 
        diversity_weight + balancing_weight
    )
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score
    normalized_balancing = (balancing_weight / total_weight) * load_balancing

    # Calculate final priority scores
    priorities = (
        normalized_spatial + normalized_future + normalized_utilization + 
        normalized_diversity + normalized_balancing
    )

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2, 0.3])
    penalty_factor = tunable([0.4, 0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 48
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.8; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.8; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.8; space size: 531441; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Utilization balance with tunable targets
    4. Dynamic diversity encouragement
    5. Look-ahead adjustments based on current bin state

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Adaptive threshold based on item size relative to bin capacity
    item_ratio = item / np.max(bins) if np.max(bins) != 0 else 0.0
    min_remaining = tunable([0.2, 0.3, 0.4]) * (1.0 - item_ratio)
    exponent = tunable([2.0, 3.0, 4.0])

    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with suitable remaining capacity for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with tunable target
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins) if np.max(bins) != 0 else np.zeros_like(bins)
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Look-ahead adjustment: Penalize bins that would leave too little space for future items
    look_ahead_penalty = np.zeros_like(bins, dtype=np.float64)
    max_expected_item = tunable([0.7, 0.8, 0.9])  # Maximum expected future item size
    look_ahead_penalty[valid_bins] = np.where(
        remaining_capacity[valid_bins] < max_expected_item,
        tunable([0.1, 0.2, 0.3]) / (remaining_capacity[valid_bins] + epsilon),
        0.0
    )

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.1, 0.2, 0.3])
    look_ahead_weight = tunable([0.1, 0.15, 0.2])

    # Ensure numerical stability and normalize weights
    total_weight = (
        spatial_weight + future_weight + utilization_weight +
        diversity_weight + look_ahead_weight
    )
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score
    normalized_look_ahead = (look_ahead_weight / total_weight) * look_ahead_penalty

    # Calculate final priority scores
    priorities = (
        normalized_spatial + normalized_future + normalized_utilization +
        normalized_diversity - normalized_look_ahead
    )

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2, 0.25])
    penalty_factor = tunable([0.4, 0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 49
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.8; space size: 14348907; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.8; space size: 14348907; measure cnt: 128
current thread_i 4

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.8; space size: 14348907; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2 * item, 0.3 * item, 0.4 * item])
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.4, 0.5, 0.6])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.15, 0.2, 0.25])
    penalty_factor = tunable([0.4, 0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 50
-------------------



launch 64 evaluate tasks
this best socre: -209.6; best score: -209.6; global score: -209.6; space size: 4782969; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.6; best score: -209.6; global score: -209.6; space size: 4782969; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.6; best score: -209.6; global score: -209.6; space size: 4782969; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.6; best score: -209.6; global score: -209.6; space size: 4782969; measure cnt: 256
sampler suggest should end sample, break
INFO:absl:Best score increased to -209.6
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Smart bin utilization balance
    4. Adaptive diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic threshold based on item size and tunable parameter
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    exponent_low = tunable([2.0, 3.0, 4.0])
    exponent_high = tunable([1.0, 1.5, 2.0])

    # Adaptive spatial fit calculation
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])
    decay_rate = tunable([0.1, 0.2, 0.3])

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2, 0.3])
    penalty_factor = tunable([0.4, 0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 51
-------------------



launch 64 evaluate tasks
this best socre: -209.8; best score: -209.8; global score: -209.6; space size: 4782969; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.8; best score: -209.8; global score: -209.6; space size: 4782969; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.8; best score: -209.8; global score: -209.6; space size: 4782969; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.8; best score: -209.8; global score: -209.6; space size: 4782969; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic exponent based on item size
    exponent = tunable([3.0, 2.0, 4.0])  # Different exponents to try
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.3, 0.2, 0.4])    # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.05])      # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = tunable([0.9, 0.85, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on how unique the remaining capacity is
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.7, 0.9])
    future_weight = tunable([0.7, 0.6, 0.8])
    utilization_weight = tunable([0.6, 0.5, 0.7])
    diversity_weight = tunable([0.3, 0.2, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2, 0.15])
    penalty_factor = tunable([0.5, 0.4, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 52
-------------------



launch 64 evaluate tasks
this best socre: -210.35; best score: -210.35; global score: -209.6; space size: 177147; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.35; best score: -210.35; global score: -209.6; space size: 177147; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.35; best score: -210.35; global score: -209.6; space size: 177147; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.35; best score: -210.35; global score: -209.6; space size: 177147; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = tunable([1e-10, 1e-9])  # Small value to avoid division by zero
    exponent = tunable([3.0, 4.0, 5.0])  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2])  # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = tunable([0.8, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2])
    penalty_factor = tunable([0.5, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 53
-------------------



launch 64 evaluate tasks
this best socre: -210.65; best score: -210.65; global score: -209.6; space size: 209952; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -209.6; space size: 209952; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 209952; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 209952; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 209952; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 209952; measure cnt: 384
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, diversity, and clustering with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = tunable([2.0, 3.0, 4.0])  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining = tunable([0.3, 0.4, 0.5])    # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])       # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])  # Weight for diversity component
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Clustering component: Group bins into clusters to handle similar items efficiently
    num_clusters = tunable([2, 3, 4])  # Number of clusters
    if len(bins) >= num_clusters:
        # Simple clustering based on remaining capacity
        from sklearn.cluster import KMeans
        clusterer = KMeans(n_clusters=num_clusters, random_state=0)
        cluster_labels = clusterer.fit_predict(remaining_capacity[valid_bins].reshape(-1, 1))
        cluster_centers = clusterer.cluster_centers_.flatten()
        
        # Calculate cluster utility: higher utility for clusters with capacity near average future item size
        cluster_utility = np.exp(-np.abs(cluster_centers - avg_future_size))
        cluster_utility = cluster_utility / cluster_utility.sum()  # Normalize utilities
        
        # Assign cluster utility scores to valid bins
        cluster_scores = np.zeros_like(bins, dtype=np.float64)
        for i, label in enumerate(cluster_labels):
            cluster_scores[i] = cluster_utility[label]
        clustering_score = cluster_scores
    else:
        clustering_score = np.ones_like(bins, dtype=np.float64)  # Uniform score if not enough bins

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])     # Weight for spatial fit
    future_weight = tunable([0.6, 0.7, 0.8])      # Weight for future compatibility
    utilization_weight = tunable([0.5, 0.6, 0.7]) # Weight for utilization
    diversity_weight = tunable([0.3, 0.4, 0.5])   # Weight for diversity
    cluster_weight = tunable([0.4, 0.5, 0.6])     # Weight for clustering

    # Ensure numerical stability and normalize weights
    total_weight = (
        spatial_weight + future_weight + utilization_weight + 
        diversity_weight + cluster_weight
    )
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score
    normalized_clustering = (cluster_weight / total_weight) * clustering_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial + normalized_future + normalized_utilization + 
        normalized_diversity + normalized_clustering
    )

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.15, 0.2])  # Threshold for applying penalty
    penalty_factor = tunable([0.4, 0.5, 0.6])     # Factor to reduce priority
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 54
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 4782969; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 4782969; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 4782969; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an improved hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = tunable([0.3 * item, 0.4 * item, 0.5 * item])
    exponent = tunable([2.0, 3.0, 4.0])  # Tunable exponent for spatial fit decay

    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.4, 0.5, 0.6])  # Expected average size of future items
    future_min_remaining = tunable([0.3, 0.4, 0.5])  # Minimum acceptable remaining capacity
    future_decay_rate = tunable([0.1, 0.2, 0.3])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > future_min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-future_decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization_decay = tunable([0.1, 0.2, 0.3])  # Decay factor for utilization score
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-utilization_decay * np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_weight = tunable([0.1, 0.2, 0.3])  # Weight for diversity component
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])  # Weight for spatial fit
    future_weight = tunable([0.5, 0.6, 0.7])   # Weight for future potential
    utilization_weight = tunable([0.4, 0.5, 0.6])  # Weight for utilization score
    diversity_weight = tunable([0.2, 0.3, 0.4])  # Weight for diversity

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2, 0.25])  # Tunable penalty threshold
    penalty_factor = tunable([0.5, 0.6, 0.7])      # Tunable penalty factor
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 55
-------------------



launch 64 evaluate tasks
this best socre: -210.4; best score: -210.4; global score: -209.6; space size: 4782969; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.4; best score: -210.4; global score: -209.6; space size: 4782969; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.4; best score: -210.4; global score: -209.6; space size: 4782969; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.4; best score: -210.4; global score: -209.6; space size: 4782969; measure cnt: 256
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an enhanced strategy.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.4 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.4,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.2 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.3
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Smart bin utilization balance
    4. Adaptive diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic threshold based on item size and tunable parameter
    min_remaining = 0.4 * item
    exponent_low = 3.0
    exponent_high = 1.0

    # Adaptive spatial fit calculation
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3
    decay_rate = 0.2

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an enhanced strategy.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.4 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.4,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.2 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.3
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Smart bin utilization balance
    4. Adaptive diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic threshold based on item size and tunable parameter
    min_remaining = 0.4 * item
    exponent_low = 3.0
    exponent_high = 1.0

    # Adaptive spatial fit calculation
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3
    decay_rate = 0.2

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an enhanced strategy.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.4 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.4,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.2 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.3
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an enhanced strategy.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.4 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.4,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.2 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.3
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Smart bin utilization balance
    4. Adaptive diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic threshold based on item size and tunable parameter
    min_remaining = 0.4 * item
    exponent_low = 3.0
    exponent_high = 1.0

    # Adaptive spatial fit calculation
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3
    decay_rate = 0.2

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Smart bin utilization balance
    4. Adaptive diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic threshold based on item size and tunable parameter
    min_remaining = 0.4 * item
    exponent_low = 3.0
    exponent_high = 1.0

    # Adaptive spatial fit calculation
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3
    decay_rate = 0.2

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Smart bin utilization balance
    4. Adaptive diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic threshold based on item size and tunable parameter
    min_remaining = 0.4 * item
    exponent_low = 3.0
    exponent_high = 1.0

    # Adaptive spatial fit calculation
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3
    decay_rate = 0.2

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 2.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.6, 0.5, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.3, 0.25, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15, 0.2])  # Decay rate for large remaining capacities
    future_items_count = tunable([3, 5, 7])  # Number of future items to consider

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Normalize future potential based on the number of future items
    future_potential /= future_items_count

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.95, 0.9, 0.85])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.4, 0.3, 0.5])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.9, 0.85, 0.8])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.5, 0.6, 0.4])
    diversity_weight = tunable([0.1, 0.2, 0.15])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.25, 0.3, 0.2])
    penalty_factor = tunable([0.6, 0.7, 0.5])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 56
-------------------


current thread_i 9

launch 64 evaluate tasks
current thread_i 4
current thread_i 5
this best socre: -210.85; best score: -210.85; global score: -209.6; space size: 14348907; measure cnt: 64

launch 64 evaluate tasks
current thread_i 2
current thread_i 8
current thread_i 3
current thread_i 1
this best socre: -210.85; best score: -210.85; global score: -209.6; space size: 14348907; measure cnt: 128

launch 64 evaluate tasks
current thread_i 6
current thread_i 0
this best socre: -210.35; best score: -210.35; global score: -209.6; space size: 14348907; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.35; best score: -210.35; global score: -209.6; space size: 14348907; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.35; best score: -210.35; global score: -209.6; space size: 14348907; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.35; best score: -210.35; global score: -209.6; space size: 14348907; measure cnt: 384
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    from tunable import tunable

    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.8, 0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 57
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 944784; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 944784; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 944784; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and bin capacity
    min_remaining = tunable([0.3, 0.4]) * item
    adaptive_threshold = tunable([0.1, 0.2]) * np.max(bins)
    min_remaining = np.maximum(min_remaining, adaptive_threshold)
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 2.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.95, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.9, 0.8])
    future_weight = tunable([0.5, 0.6])
    utilization_weight = tunable([0.5, 0.4])
    diversity_weight = tunable([0.1, 0.2])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.25, 0.3])
    penalty_factor = tunable([0.6, 0.5])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 58
-------------------



launch 64 evaluate tasks
this best socre: -215.2; best score: -215.2; global score: -209.6; space size: 16384; measure cnt: 64
...
launch 64 evaluate tasks
this best socre: -215.2; best score: -215.2; global score: -209.6; space size: 16384; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -215.2; best score: -215.2; global score: -209.6; space size: 16384; measure cnt: 192

launch 64 evaluate tasks
this best socre: -215.2; best score: -215.2; global score: -209.6; space size: 16384; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 59
-------------------



launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -209.6; space size: 1594323; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -209.6; space size: 1594323; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.0; best score: -211.0; global score: -209.6; space size: 1594323; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.0; best score: -211.0; global score: -209.6; space size: 1594323; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -209.6; space size: 1594323; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 1594323; measure cnt: 384

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 1594323; measure cnt: 448

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 1594323; measure cnt: 512

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 1594323; measure cnt: 576

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 1594323; measure cnt: 640

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 1594323; measure cnt: 704

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 1594323; measure cnt: 768
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation with expected item size distribution
    3. Smart bin utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable parameter
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    exponent_low = tunable([2.0, 3.0, 4.0])
    exponent_high = tunable([1.0, 1.5])

    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Using expected item size distribution
    expected_sizes = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])
    decay_rate = tunable([0.1, 0.2, 0.3])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - expected_sizes)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    # Dynamic target based on current bin utilization
    current_avg_util = np.mean(bins) / np.max(bins) if len(bins) > 0 else 0.0
    target_utilization = tunable([0.85, 0.9, 0.95]) + (current_avg_util - 0.5) * tunable([0.1, 0.2])
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.1, 0.2, 0.3])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.6, 0.7, 0.8])
    diversity_weight = tunable([0.1, 0.15, 0.2])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 60
-------------------



launch 64 evaluate tasks
this best socre: -241.05; best score: -241.05; global score: -209.6; space size: 6377292; measure cnt: 64

launch 64 evaluate tasks
this best socre: -220.15; best score: -220.15; global score: -209.6; space size: 6377292; measure cnt: 128
........................................................................................................................................................................................................................................................................................................................
launch 16 evaluate tasks
this best socre: -220.15; best score: -220.15; global score: -209.6; space size: 6377292; measure cnt: 144
...............................................................................................................................................................................................................................................................................................................................................................................
launch 23 evaluate tasks
this best socre: -220.15; best score: -220.15; global score: -209.6; space size: 6377292; measure cnt: 167
......................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 23 evaluate tasks
this best socre: -220.15; best score: -220.15; global score: -209.6; space size: 6377292; measure cnt: 190
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation with probabilistic modeling
    3. Smart bin utilization balance with adaptive targets
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic minimum remaining capacity based on item size and tunable parameter
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    exponent_low = tunable([2.0, 3.0, 4.0])
    exponent_high = tunable([1.0, 1.5])

    # Adaptive spatial fit calculation
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.1, 0.2, 0.3])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.05, 0.1, 0.15])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply adaptive penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 61
-------------------



launch 64 evaluate tasks
this best socre: -214.3; best score: -214.3; global score: -209.6; space size: 3188646; measure cnt: 64
.........................................
launch 64 evaluate tasks
this best socre: -214.3; best score: -214.3; global score: -209.6; space size: 3188646; measure cnt: 128
........................................................
launch 64 evaluate tasks
this best socre: -214.3; best score: -214.3; global score: -209.6; space size: 3188646; measure cnt: 192
.........................................................
launch 64 evaluate tasks
this best socre: -214.3; best score: -214.3; global score: -209.6; space size: 3188646; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Smart bin utilization balance
    4. Adaptive diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic threshold based on item size and tunable parameter
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    exponent_low = tunable([2.0, 3.0, 4.0])
    exponent_high = tunable([1.0, 1.5])

    # Adaptive spatial fit calculation
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])
    decay_rate = tunable([0.1, 0.2, 0.3])

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = tunable([0.9, 0.95, 0.98])
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.1, 0.2, 0.3])
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.7, 0.9])
    future_weight = tunable([0.6, 0.5, 0.7])
    utilization_weight = tunable([0.5, 0.4, 0.6])
    diversity_weight = tunable([0.2, 0.1, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 62
-------------------



launch 64 evaluate tasks
this best socre: -221.5; best score: -221.5; global score: -209.6; space size: 3188646; measure cnt: 64
........................................................................................................
launch 64 evaluate tasks
this best socre: -221.5; best score: -221.5; global score: -209.6; space size: 3188646; measure cnt: 128
............................................................................................................................................................................................................................................................................................................................
launch 64 evaluate tasks
this best socre: -221.5; best score: -221.5; global score: -209.6; space size: 3188646; measure cnt: 192
.................................................................................................................................................................................................................................................................................................................................................
launch 31 evaluate tasks
this best socre: -221.5; best score: -221.5; global score: -209.6; space size: 3188646; measure cnt: 223
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Smart bin utilization balance
    4. Adaptive diversity encouragement

    The function uses tunable parameters for strategic innovation and optimization.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic threshold based on item size and tunable parameter
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    exponent_low = tunable([3.0, 4.0, 5.0])
    exponent_high = tunable([1.0, 2.0])

    # Adaptive spatial fit calculation
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])
    decay_rate = tunable([0.1, 0.2, 0.3])

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = tunable([0.9, 0.95, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.1, 0.2, 0.3])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.6, 0.7, 0.8])
    utilization_weight = tunable([0.7, 0.8, 0.9])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.3, 0.4])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 63
-------------------



launch 64 evaluate tasks
this best socre: -227.05; best score: -227.05; global score: -209.6; space size: 3188646; measure cnt: 64
.................................................................
launch 64 evaluate tasks
this best socre: -227.05; best score: -227.05; global score: -209.6; space size: 3188646; measure cnt: 128
..................................................................
launch 64 evaluate tasks
this best socre: -227.05; best score: -227.05; global score: -209.6; space size: 3188646; measure cnt: 192
..................................................................
launch 64 evaluate tasks
this best socre: -227.05; best score: -227.05; global score: -209.6; space size: 3188646; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Smart bin utilization balance
    4. Adaptive diversity encouragement
    5. Learning component based on historical performance

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and tunable parameter
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    # Use a sigmoid function to reward bins where remaining capacity is just enough
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - min_remaining) * tunable([3.0, 5.0]))),
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - tunable([0.1, 0.2])) * tunable([1.0, 2.0])))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Dynamically estimate average future item size based on historical data
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.1, 0.2, 0.3])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Learning component: Adjust priorities based on historical performance
    # For simplicity, we use a moving average of past remaining capacities
    learning_weight = tunable([0.05, 0.1, 0.15])
    if hasattr(priority_v2, 'history'):
        history = priority_v2.history
        # Update history with current remaining capacities
        history = np.append(history, remaining_capacity[valid_bins])
        # Use the last N entries for learning
        n = tunable([10, 20, 30])
        recent_history = history[-n:] if len(history) > n else history
        # Calculate the average change in remaining capacity
        avg_change = np.mean(np.abs(np.diff(recent_history)))
        # Penalize bins with high variability in remaining capacity
        learning_score = np.exp(-avg_change * learning_weight)
    else:
        learning_score = 1.0
        priority_v2.history = remaining_capacity[valid_bins]

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.5, 0.6, 0.7])
    diversity_weight = tunable([0.1, 0.2, 0.3])
    learning_weight = tunable([0.05, 0.1, 0.15])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight + learning_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score
    normalized_learning = (learning_weight / total_weight) * learning_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity + normalized_learning

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 64
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 114791256; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 114791256; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 114791256; measure cnt: 192
sampler suggest should end sample, break
request...request...
request...
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and bin similarity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 4.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2    # Minimum acceptable remaining capacity
    decay_rate = 0.3       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Bin similarity component: Penalize bins with similar remaining capacities
    similarity_penalty = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Calculate pairwise differences
        pairwise_diffs = np.abs(rc_values[:, np.newaxis] - rc_values)
        # Apply a penalty based on the number of similar bins
        similarity_count = np.sum(np.where(pairwise_diffs < 0.1, 1, 0), axis=1)
        similarity_penalty[valid_bins] = 1.0 / (1.0 + similarity_count)

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.3
    similarity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + similarity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_similarity = (similarity_weight / total_weight) * similarity_penalty

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_similarity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
----------------------------------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is just enough
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Using an adaptive average based on past items
    min_remaining = 0.5  # Tunable minimum acceptable remaining capacity
    decay_rate = 0.3     # Tunable decay rate for large remaining capacities

    # Calculate expected future item size based on past items (simplified example)
    # In a real scenario, this would be replaced with a more sophisticated prediction model
    expected_future_size = 0.5  # Expected average size of future items

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - expected_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.98  # Tunable target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Reward bins that leave a unique remaining capacity
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Calculate how unique each remaining capacity is using a tunable sigma
        sigma = 0.2  # Tunable sigma for diversity calculation
        similarities = np.exp(-np.abs(rc_values - rc_values[:, np.newaxis]) ** 2 / (2 * sigma ** 2))
        sum_similarities = np.sum(similarities, axis=1)
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

    # Combine components with tunable weights
    spatial_weight = 0.7    # Tunable weight for spatial fit
    future_weight = 0.4     # Tunable weight for future potential
    utilization_weight = 0.3 # Tunable weight for utilization
    diversity_weight = 0.4   # Tunable weight for diversity

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalties
    penalty_threshold = 0.1  # Tunable threshold for applying penalties
    penalty_factor = 0.6      # Tunable penalty factor
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    # Additional penalty for bins that are too full
    full_penalty_threshold = 0.9  # Tunable threshold for full bins
    full_penalty_factor = 0.6       # Tunable penalty factor for full bins
    priorities = np.where(bins > full_penalty_threshold, priorities * full_penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an enhanced strategy.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.4 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.4,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.2 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.3
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.



-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.4 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.4  # Minimum acceptable remaining capacity
    decay_rate = 0.2  # Decay rate for large remaining capacities
    future_items_count = 5  # Number of future items to consider

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Normalize future potential based on the number of future items
    future_potential /= future_items_count

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.6
    utilization_weight = 0.6
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.7
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic exponent based on item size
    exponent = 3.0  # Different exponents to try
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    decay_rate = 0.05      # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on how unique the remaining capacity is
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.7
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.4
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
request...
-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------request...request...

-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 2.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.5
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

request...
import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic exponent based on item size
    exponent = 3.0  # Different exponents to try
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    decay_rate = 0.05      # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on how unique the remaining capacity is
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.7
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.4
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an improved hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.5 * item
    exponent = 3.0  # Tunable exponent for spatial fit decay

    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    future_min_remaining = 0.3  # Minimum acceptable remaining capacity
    future_decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > future_min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-future_decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization_decay = 0.3  # Decay factor for utilization score
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-utilization_decay * np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_weight = 0.3  # Weight for diversity component
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8  # Weight for spatial fit
    future_weight = 0.5   # Weight for future potential
    utilization_weight = 0.5  # Weight for utilization score
    diversity_weight = 0.3  # Weight for diversity

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.25  # Tunable penalty threshold
    penalty_factor = 0.7      # Tunable penalty factor
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Advanced priority function for online bin packing.

    This version introduces:
    1. Dynamic spatial-temporal packing strategy
    2. Memory-aware future potential estimation
    3. Improved diversity scoring
    4. Better handling of edge cases

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and global memory
    min_remaining = tunable([0.2, 0.3]) * item
    min_remaining = max(min_remaining, tunable([0.1, 0.15]))  # Minimum absolute threshold
    
    # Adaptive exponent based on remaining capacity distribution
    exponent = tunable([3.0, 4.0]) 
    if np.mean(remaining_capacity[valid_bins]) < min_remaining:
        exponent = tunable([1.0, 2.0])  # Use lower exponent when capacity is tight
    
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component with memory-aware estimation
    future_potential = np.zeros_like(bins, dtype=np.float64)
    
    # Calculate expected future item size using exponential moving average
    if bins.size > 10:  # Only calculate when enough history is available
        recent_bins = bins[-10:]  # Look at last 10 bins
        recent_items = recent_bins - np.roll(recent_bins, 1)  # Estimate recent items added
        recent_items = recent_items[recent_items > 0]  # Filter valid items
        if recent_items.size > 0:
            avg_future_size = np.mean(recent_items) * tunable([0.9, 0.95])  # Discount factor
        else:
            avg_future_size = tunable([0.5, 0.6])  # Fallback to default
    else:
        avg_future_size = tunable([0.5, 0.6])
    
    min_remaining_future = tunable([0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2])  # Decay rate for large remaining capacities

    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component with dynamic target
    target_utilization = tunable([0.95, 0.98])  # Adaptive target utilization
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component with improved scoring
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        rc_values = remaining_capacity[valid_bins]
        # Calculate diversity based on distribution uniqueness
        sigma = tunable([0.2, 0.3])  # Tunable sigma for diversity calculation
        pairwise_diffs = np.abs(rc_values - rc_values[:, np.newaxis])
        similarities = np.exp(-pairwise_diffs ** 2 / (2 * sigma ** 2))
        sum_similarities = np.sum(similarities, axis=1)
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

        # Apply additional penalty for bins that are too similar to the best bin
        best_bin = np.argmax(remaining_capacity)
        best_bin_diffs = np.abs(remaining_capacity - remaining_capacity[best_bin])
        diversity_score = np.where(
            best_bin_diffs < tunable([0.1, 0.2]),
            diversity_score * tunable([0.5, 0.6]),
            diversity_score
        )

    # Combine components with tunable weights
    spatial_weight = tunable([0.9, 0.85])
    future_weight = tunable([0.5, 0.6])
    utilization_weight = tunable([0.5, 0.4])
    diversity_weight = tunable([0.1, 0.15])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalties for edge cases
    penalty_threshold = tunable([0.25, 0.2])
    penalty_factor = tunable([0.6, 0.5])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    # Additional penalty for bins that are too full
    full_penalty_threshold = tunable([0.9, 0.95])
    full_penalty_factor = tunable([0.6, 0.5])
    priorities = np.where(bins > full_penalty_threshold, priorities * full_penalty_factor, priorities)

    # Bin refresh mechanism to prevent stagnation
    if np.random.rand() < tunable([0.01, 0.02]):
        priorities = priorities * (1 + np.random.normal(0, 0.1, bins.shape))

    return priorities

call llm times: 65
-------------------


current thread_i 
0
launch 64 evaluate tasks
current thread_i 9
current thread_i 2
current thread_i 3
current thread_i 5
current thread_i 6
current thread_i 4
current thread_i 8
this best socre: -210.65; best score: -210.65; global score: -209.6; space size: 8388608; measure cnt: 64

launch 64 evaluate tasks
current thread_i 1
this best socre: -210.65; best score: -210.65; global score: -209.6; space size: 8388608; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.5; best score: -210.5; global score: -209.6; space size: 8388608; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.5; best score: -210.5; global score: -209.6; space size: 8388608; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.5; best score: -210.5; global score: -209.6; space size: 8388608; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.5; best score: -210.5; global score: -209.6; space size: 8388608; measure cnt: 384
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 4.0, 5.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.8, 0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 66
-------------------



launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -209.6; space size: 1417176; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -209.6; space size: 1417176; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -209.6; space size: 1417176; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.05; best score: -210.05; global score: -209.6; space size: 1417176; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.8, 0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.5, 0.6, 0.7])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.4, 0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 67
-------------------



launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -209.6; space size: 2125764; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -209.6; space size: 2125764; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -209.6; space size: 2125764; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -209.6; space size: 2125764; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 2.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.6, 0.7, 0.5])  # Expected average size of future items
    min_remaining_future = tunable([0.3, 0.4, 0.2])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.05])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.95, 0.9, 0.85])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities using clustering
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        # Using k-means clustering to identify distinct remaining capacity clusters
        from sklearn.cluster import KMeans
        n_clusters = tunable([3, 2, 4])
        if n_clusters > len(bins):
            n_clusters = len(bins)
        kmeans = KMeans(n_clusters=n_clusters, random_state=0)
        clusters = kmeans.fit_predict(remaining_capacity[valid_bins].reshape(-1, 1))
        cluster_sizes = np.bincount(clusters)
        diversity = 1.0 / (1.0 + np.var(cluster_sizes))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.9, 0.8, 0.7])
    future_weight = tunable([0.5, 0.6, 0.4])
    utilization_weight = tunable([0.5, 0.6, 0.4])
    diversity_weight = tunable([0.2, 0.3, 0.1])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.25, 0.3, 0.2])
    penalty_factor = tunable([0.6, 0.7, 0.5])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 68
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 4782969; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 4782969; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 4782969; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    ideal_remaining = tunable([0.5, 0.6, 0.7]) * item

    # Calculate spatial fit using a sigmoid function
    spatial_fit[valid_bins] = 1.0 / (1.0 + np.exp(
        -tunable([2.0, 3.0, 4.0]) * 
        (remaining_capacity[valid_bins] - ideal_remaining) / (ideal_remaining + epsilon)
    ))

    # Penalize bins with remaining capacity below the minimum threshold
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        tunable([0.5, 0.7, 0.9]) * spatial_fit[valid_bins],
        spatial_fit[valid_bins]
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    expected_future_size = tunable([0.5, 0.6, 0.7]) * item
    min_remaining_future = tunable([0.2, 0.3, 0.4]) * item
    decay_rate = tunable([0.1, 0.2, 0.3])

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(
            -(remaining_capacity[valid_bins] - expected_future_size) / (expected_future_size + epsilon)
        ))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 0.98])
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(
        -tunable([0.5, 1.0, 1.5]) * np.abs(utilization - target_utilization)
    )

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial + 
        normalized_future + 
        normalized_utilization + 
        normalized_diversity
    )

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2, 0.3]) * item
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 69
-------------------



launch 64 evaluate tasks
this best socre: -449.05; best score: -449.05; global score: -209.6; space size: 14348907; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -449.05; best score: -449.05; global score: -209.6; space size: 14348907; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -449.05; best score: -449.05; global score: -209.6; space size: 14348907; measure cnt: 192

launch 64 evaluate tasks
this best socre: -449.05; best score: -449.05; global score: -209.6; space size: 14348907; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic minimum remaining capacity based on item size and average item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item

    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.4, 0.5, 0.6])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-tunable([0.2, 0.3, 0.4]) * np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.6, 0.7, 0.8])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    # Normalize priorities to ensure they are on a comparable scale
    priorities = priorities / (np.max(priorities) + 1e-10)

    return priorities

call llm times: 70
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 14348907; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 14348907; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 14348907; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable parameter
    min_remaining = tunable([0.25, 0.3, 0.35]) * item
    
    # Calculate spatial fit with adaptive decay and tunable exponents
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Expected average size of future items with tunable parameter
    avg_future_size = tunable([0.5, 0.6, 0.7])
    # Minimum acceptable remaining capacity with tunable parameter
    min_remaining_future = tunable([0.25, 0.3, 0.35])
    # Decay rate for large remaining capacities with tunable parameter
    decay_rate = tunable([0.15, 0.2, 0.25])
    # Number of future items to consider with tunable parameter
    future_items_count = tunable([3, 5, 7])

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Normalize future potential based on the number of future items
    future_potential /= future_items_count

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    # Target utilization level with tunable parameter
    target_utilization = tunable([0.9, 0.93, 0.95, 0.98])
    # Normalize by max bin capacity
    utilization = bins / np.max(bins)
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        # Using coefficient of variation as a measure of diversity
        cv = np.var(remaining_capacity[valid_bins]) / np.mean(remaining_capacity[valid_bins] + epsilon)
        diversity = 1.0 / (1.0 + cv)
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.85, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.5, 0.6, 0.7])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.6, 0.7, 0.8])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 71
-------------------



launch 64 evaluate tasks
this best socre: -253.45; best score: -253.45; global score: -209.6; space size: 12754584; measure cnt: 64
...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 47 evaluate tasks
this best socre: -253.45; best score: -253.45; global score: -209.6; space size: 12754584; measure cnt: 111
.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 25 evaluate tasks
this best socre: -253.45; best score: -253.45; global score: -209.6; space size: 12754584; measure cnt: 136
..........................................................................................................................................................................................................
launch 14 evaluate tasks
this best socre: -253.45; best score: -253.45; global score: -209.6; space size: 12754584; measure cnt: 150
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item

    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 4.0, 2.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    std_future_size = tunable([0.1, 0.2, 0.15])  # Expected standard deviation of future item sizes
    min_remaining_future = tunable([0.2, 0.3, 0.25])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.05, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 0.85])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.1, 0.2, 0.15])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 0.7])
    future_weight = tunable([0.6, 0.5, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.3])
    diversity_weight = tunable([0.1, 0.2, 0.1])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.4])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 72
-------------------



launch 64 evaluate tasks
this best socre: -211.2; best score: -211.2; global score: -209.6; space size: 14348907; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.2; best score: -211.2; global score: -209.6; space size: 14348907; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.2; best score: -211.2; global score: -209.6; space size: 14348907; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.2; best score: -211.2; global score: -209.6; space size: 14348907; measure cnt: 256
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.5 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 2.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.7
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.5 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 2.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.7
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.2 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.15  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.6
    utilization_weight = 0.5
    diversity_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------request...


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.2 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.15  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.6
    utilization_weight = 0.5
    diversity_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.4 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.4  # Minimum acceptable remaining capacity
    decay_rate = 0.2  # Decay rate for large remaining capacities
    future_items_count = 5  # Number of future items to consider

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Normalize future potential based on the number of future items
    future_potential /= future_items_count

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.6
    utilization_weight = 0.6
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.7
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.5 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 2.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.7
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.5 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 2.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.7
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an improved hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.5 * item
    exponent = 3.0  # Tunable exponent for spatial fit decay

    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    future_min_remaining = 0.3  # Minimum acceptable remaining capacity
    future_decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > future_min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-future_decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization_decay = 0.3  # Decay factor for utilization score
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-utilization_decay * np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_weight = 0.3  # Weight for diversity component
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8  # Weight for spatial fit
    future_weight = 0.5   # Weight for future potential
    utilization_weight = 0.5  # Weight for utilization score
    diversity_weight = 0.3  # Weight for diversity

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.25  # Tunable penalty threshold
    penalty_factor = 0.7      # Tunable penalty factor
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 4.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    decay_rate = 0.2       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.5
    utilization_weight = 0.3
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item

    # Dynamic exponent based on item size relative to average bin capacity
    avg_bin_capacity = np.mean(bins) if len(bins) > 0 else 1.0
    exponent = 2.0 + 1.0 * (item / avg_bin_capacity)
    exponent = np.clip(exponent, 1.0, 4.0)  # Ensure exponent remains within reasonable bounds

    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        # Using a combination of variance and entropy for better distribution awareness
        rc = remaining_capacity[valid_bins]
        if len(rc) == 0:
            diversity = 0.0
        else:
            variance = np.var(rc)
            # Calculate entropy
            hist, _ = np.histogram(rc, bins=5)
            hist = hist + 1e-10  # Avoid zero probabilities
            entropy = -np.sum(hist * np.log2(hist / hist.sum()))
            # Combine variance and entropy, preferring lower variance and higher entropy
            diversity = 1.0 / (1.0 + variance) * (1.0 + entropy)
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.5, 0.6, 0.7])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 73
-----------------------

-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 177147; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 177147; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 177147; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.4 * item, 0.6 * item])
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.3, 0.4])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.85])
    future_weight = tunable([0.4, 0.5])
    utilization_weight = tunable([0.5, 0.6])
    diversity_weight = tunable([0.2, 0.25])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.3])
    penalty_factor = tunable([0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 74
-------------------



current thread_i 3
launch 64 evaluate tasks
current thread_i 5
this best socre: -221.3; best score: -221.3; global score: -209.6; space size: 16384; measure cnt: 64
..
launch 64 evaluate tasks
this best socre: -221.3; best score: -221.3; global score: -209.6; space size: 16384; measure cnt: 128
.......................
launch 64 evaluate tasks
this best socre: -220.55; best score: -220.55; global score: -209.6; space size: 16384; measure cnt: 192
.........................
launch 64 evaluate tasks
current thread_i 9
current thread_i 0
this best socre: -220.55; best score: -220.55; global score: -209.6; space size: 16384; measure cnt: 256
.............................................................
launch 64 evaluate tasks
current thread_i 1
current thread_i 2
this best socre: -220.55; best score: -220.55; global score: -209.6; space size: 16384; measure cnt: 320
......................................................................................
launch 64 evaluate tasks
current thread_i 8
this best socre: -220.55; best score: -220.55; global score: -209.6; space size: 16384; measure cnt: 384
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness
    5. Novel item-bin similarity metric

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    from tunable import tunable

    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 4.0, 5.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 2.0, 3.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Novel item-bin similarity metric: Reward bins that match item size well
    similarity_score = np.zeros_like(bins, dtype=np.float64)
    similarity_threshold = tunable([0.1, 0.2, 0.3])
    similarity_bonus = tunable([0.8, 0.9, 1.0])
    similarity_penalty = tunable([0.1, 0.2, 0.3])
    
    # Calculate similarity based on how well bin capacity matches item size
    similarity = np.abs(bins - item) / (np.max(bins) + 1e-10)
    similarity_score = np.where(
        similarity < similarity_threshold,
        similarity_bonus,
        similarity_penalty
    )

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.2, 0.3, 0.4])
    similarity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = (
        spatial_weight + 
        future_weight + 
        utilization_weight + 
        diversity_weight + 
        similarity_weight
    )
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score
    normalized_similarity = (similarity_weight / total_weight) * similarity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial + 
        normalized_future + 
        normalized_utilization + 
        normalized_diversity + 
        normalized_similarity
    )

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.6, 0.7, 0.8])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 75
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 129140163; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 129140163; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 129140163; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.25, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 4.0, 5.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Use adaptive average based on item history
    avg_future_size = tunable([0.6, 0.7, 0.8])  # Expected average size of future items
    min_remaining_future = tunable([0.25, 0.3, 0.35])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15, 0.2])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.92, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.85, 0.9, 0.95])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.45, 0.5, 0.55])
    diversity_weight = tunable([0.3, 0.4, 0.5])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 76
-------------------



launch 64 evaluate tasks
current thread_i 6
this best socre: -216.6; best score: -216.6; global score: -209.6; space size: 1594323; measure cnt: 64
.............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 44 evaluate tasks
current thread_i 4
this best socre: -216.6; best score: -216.6; global score: -209.6; space size: 1594323; measure cnt: 108
.......................................................................................................................................................................................................................................................................................................................................
launch 28 evaluate tasks
this best socre: -216.6; best score: -216.6; global score: -209.6; space size: 1594323; measure cnt: 136
...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 51 evaluate tasks
this best socre: -216.6; best score: -216.6; global score: -209.6; space size: 1594323; measure cnt: 187
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable weight
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.6, 0.7, 0.8])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15, 0.2])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.92, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.85, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.3, 0.4, 0.5])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.25, 0.3, 0.35])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 77
-------------------



launch 64 evaluate tasks
this best socre: -216.2; best score: -216.2; global score: -209.6; space size: 1594323; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -215.85; best score: -215.85; global score: -209.6; space size: 1594323; measure cnt: 128
......
launch 64 evaluate tasks
this best socre: -215.85; best score: -215.85; global score: -209.6; space size: 1594323; measure cnt: 192
......
launch 64 evaluate tasks
this best socre: -215.85; best score: -215.85; global score: -209.6; space size: 1594323; measure cnt: 256
......
launch 64 evaluate tasks
this best socre: -215.85; best score: -215.85; global score: -209.6; space size: 1594323; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.4, 0.6]) * item

    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Using a dynamic average of future item sizes with decay
    avg_future_size = tunable([0.5, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.25, 0.35])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        # Using a combination of variance and Gini coefficient for better distribution awareness
        rc = remaining_capacity[valid_bins]
        if len(rc) > 1:
            variance = np.var(rc)
            gini = 1.0 - (2.0 * np.sum(np.sort(rc) * np.arange(1, len(rc)+1))) / (len(rc) * np.sum(rc))
            diversity = 1.0 / (1.0 + variance + gini)
            diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.85])
    future_weight = tunable([0.4, 0.6])
    utilization_weight = tunable([0.5, 0.7])
    diversity_weight = tunable([0.1, 0.25])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply adaptive penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.3])
    penalty_factor = tunable([0.6, 0.8])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 78
-------------------



launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -209.6; space size: 8192; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -209.6; space size: 8192; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -209.6; space size: 8192; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -209.6; space size: 8192; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.25, 0.3, 0.35])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.15, 0.2, 0.25])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization_base = 0.95  # Base target utilization level
    # Adjust target based on item size relative to max bin capacity
    max_capacity = np.max(bins)
    item_ratio = item / max_capacity
    target_utilization = target_utilization_base + (1.0 - target_utilization_base) * item_ratio
    utilization = bins / max_capacity  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.25, 0.3, 0.35])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.85, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.5, 0.6, 0.7])
    diversity_weight = tunable([0.15, 0.2, 0.25])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.6, 0.7, 0.8])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 79
-------------------



launch 64 evaluate tasks
this best socre: -329.65; best score: -329.65; global score: -209.6; space size: 1594323; measure cnt: 64
..
launch 64 evaluate tasks
this best socre: -329.65; best score: -329.65; global score: -209.6; space size: 1594323; measure cnt: 128

launch 64 evaluate tasks
this best socre: -329.65; best score: -329.65; global score: -209.6; space size: 1594323; measure cnt: 192
...
launch 64 evaluate tasks
this best socre: -329.65; best score: -329.65; global score: -209.6; space size: 1594323; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3 * item, 0.4 * item])
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9])
    future_weight = tunable([0.4, 0.5])
    utilization_weight = tunable([0.5, 0.6])
    diversity_weight = tunable([0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25])
    penalty_factor = tunable([0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 80
-------------------



launch 64 evaluate tasks
this best socre: -218.35; best score: -218.35; global score: -209.6; space size: 8192; measure cnt: 64
..............................................................................................................................................................................................................................................................................................................................
launch 50 evaluate tasks
this best socre: -218.35; best score: -218.35; global score: -209.6; space size: 8192; measure cnt: 114
....................................................................................................................................................................................................................................................................................................
launch 8 evaluate tasks
this best socre: -218.35; best score: -218.35; global score: -209.6; space size: 8192; measure cnt: 122
............................................................................................................................................................................................................................................................................................................................................................................................................................
launch 63 evaluate tasks
this best socre: -218.35; best score: -218.35; global score: -209.6; space size: 8192; measure cnt: 185
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3 * item, 0.5 * item])
    
    # Adaptive exponent based on item size
    exponent = tunable([3.0, 2.0]) if item > tunable([0.6, 0.7]) else tunable([1.5, 2.0])
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.6, 0.5, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.3, 0.25, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15, 0.05])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.95, 0.9, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-tunable([0.3, 0.4, 0.2]) * np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.4, 0.3, 0.5])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.9, 0.85, 0.8])
    future_weight = tunable([0.5, 0.6, 0.4])
    utilization_weight = tunable([0.5, 0.6, 0.4])
    diversity_weight = tunable([0.1, 0.15, 0.05])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.25, 0.3])
    penalty_factor = tunable([0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 81
-------------------



launch 64 evaluate tasks
this best socre: -212.9; best score: -212.9; global score: -209.6; space size: 3779136; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.9; best score: -212.9; global score: -209.6; space size: 3779136; measure cnt: 128

launch 64 evaluate tasks
this best socre: -212.9; best score: -212.9; global score: -209.6; space size: 3779136; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.9; best score: -212.9; global score: -209.6; space size: 3779136; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3, 0.4, 0.5]) * item

    # Adaptive exponent based on remaining capacity
    exponent = tunable([1.0, 2.0, 3.0])
    high_remaining_exponent = tunable([1.0, 2.0])
    low_remaining_exponent = tunable([3.0, 4.0])

    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** low_remaining_exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** high_remaining_exponent)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Using a moving average for expected future item size
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    max_bin_capacity = np.max(bins)
    target_utilization = tunable([0.9, 0.95, 0.98])  # Base target utilization level
    dynamic_target = np.clip(target_utilization + (item / max_bin_capacity) * tunable([0.05, 0.1, 0.15]), 0.8, 1.0)
    utilization = bins / max_bin_capacity  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - dynamic_target))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.3, 0.4, 0.5])
    if len(bins) > 1:
        # Calculate diversity based on entropy of remaining capacities
        prob = remaining_capacity[valid_bins] / np.sum(remaining_capacity[valid_bins])
        entropy = -np.sum(prob * np.log2(prob + epsilon))
        diversity = 1.0 / (1.0 + np.exp(-(entropy - tunable([1.0, 1.5, 2.0]))))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.85, 0.9])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.6, 0.7, 0.8])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 82
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 57395628; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 57395628; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 57395628; measure cnt: 192
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.4 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.4  # Minimum acceptable remaining capacity
    decay_rate = 0.2  # Decay rate for large remaining capacities
    future_items_count = 5  # Number of future items to consider

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Normalize future potential based on the number of future items
    future_potential /= future_items_count

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.6
    utilization_weight = 0.6
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.7
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.2 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.15  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.6
    utilization_weight = 0.5
    diversity_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic exponent based on item size
    exponent = 3.0  # Different exponents to try
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining = 0.4    # Minimum acceptable remaining capacity
    decay_rate = 0.05      # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on how unique the remaining capacity is
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.7
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.4
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future compatibility, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 3.0  # Tunable exponent for spatial fit decay
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future compatibility component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_compatibility = np.zeros_like(bins, dtype=np.float64)
    future_compatibility[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.2
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_compatibility
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an improved hybrid approach.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.5 * item
    exponent = 3.0  # Tunable exponent for spatial fit decay

    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    future_min_remaining = 0.3  # Minimum acceptable remaining capacity
    future_decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > future_min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-future_decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.9  # Target utilization level
    utilization_decay = 0.3  # Decay factor for utilization score
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-utilization_decay * np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_weight = 0.3  # Weight for diversity component
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8  # Weight for spatial fit
    future_weight = 0.5   # Weight for future potential
    utilization_weight = 0.5  # Weight for utilization score
    diversity_weight = 0.3  # Weight for diversity

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.25  # Tunable penalty threshold
    penalty_factor = 0.7      # Tunable penalty factor
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    # Using a function that peaks when remaining capacity is close to zero but penalizes large remaining spaces
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 2.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining = 0.2    # Minimum acceptable remaining capacity
    decay_rate = 0.3       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.9  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Penalize bins with similar remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    similarity_threshold = 0.05  # Threshold for considering bins similar
    for i in range(len(bins)):
        if valid_bins[i]:
            # Compare with other valid bins to measure similarity
            similarity = np.sum(np.abs(remaining_capacity[i] - remaining_capacity[valid_bins]) < similarity_threshold)
            diversity_score[i] = 1.0 / (1.0 + similarity)

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.4
    utilization_weight = 0.1
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.15
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and bin similarity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 4.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.2    # Minimum acceptable remaining capacity
    decay_rate = 0.3       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Bin similarity component: Penalize bins with similar remaining capacities
    similarity_penalty = np.zeros_like(bins, dtype=np.float64)
    if np.any(valid_bins):
        rc_values = remaining_capacity[valid_bins]
        # Calculate pairwise differences
        pairwise_diffs = np.abs(rc_values[:, np.newaxis] - rc_values)
        # Apply a penalty based on the number of similar bins
        similarity_count = np.sum(np.where(pairwise_diffs < 0.1, 1, 0), axis=1)
        similarity_penalty[valid_bins] = 1.0 / (1.0 + similarity_count)

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.5
    utilization_weight = 0.3
    similarity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + similarity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_similarity = (similarity_weight / total_weight) * similarity_penalty

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_similarity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin packing.

    This version introduces:
    1. Dynamic spatial-temporal packing strategy
    2. Memory-aware future potential estimation
    3. Improved diversity scoring
    4. Better handling of edge cases

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and global memory
    min_remaining = 0.2 * item
    min_remaining = max(min_remaining, 0.15)  # Minimum absolute threshold
    
    # Adaptive exponent based on remaining capacity distribution
    exponent = 4.0 
    if np.mean(remaining_capacity[valid_bins]) < min_remaining:
        exponent = 1.0  # Use lower exponent when capacity is tight
    
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component with memory-aware estimation
    future_potential = np.zeros_like(bins, dtype=np.float64)
    
    # Calculate expected future item size using exponential moving average
    if bins.size > 10:  # Only calculate when enough history is available
        recent_bins = bins[-10:]  # Look at last 10 bins
        recent_items = recent_bins - np.roll(recent_bins, 1)  # Estimate recent items added
        recent_items = recent_items[recent_items > 0]  # Filter valid items
        if recent_items.size > 0:
            avg_future_size = np.mean(recent_items) * 0.95  # Discount factor
        else:
            avg_future_size = 0.5  # Fallback to default
    else:
        avg_future_size = 0.5
    
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.2  # Decay rate for large remaining capacities

    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component with dynamic target
    target_utilization = 0.98  # Adaptive target utilization
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component with improved scoring
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        rc_values = remaining_capacity[valid_bins]
        # Calculate diversity based on distribution uniqueness
        sigma = 0.2  # Tunable sigma for diversity calculation
        pairwise_diffs = np.abs(rc_values - rc_values[:, np.newaxis])
        similarities = np.exp(-pairwise_diffs ** 2 / (2 * sigma ** 2))
        sum_similarities = np.sum(similarities, axis=1)
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

        # Apply additional penalty for bins that are too similar to the best bin
        best_bin = np.argmax(remaining_capacity)
        best_bin_diffs = np.abs(remaining_capacity - remaining_capacity[best_bin])
        diversity_score = np.where(
            best_bin_diffs < 0.2,
            diversity_score * 0.5,
            diversity_score
        )

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.6
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalties for edge cases
    penalty_threshold = 0.2
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    # Additional penalty for bins that are too full
    full_penalty_threshold = 0.95
    full_penalty_factor = 0.6
    priorities = np.where(bins > full_penalty_threshold, priorities * full_penalty_factor, priorities)

    # Bin refresh mechanism to prevent stagnation
    if np.random.rand() < 0.02:
        priorities = priorities * (1 + np.random.normal(0, 0.1, bins.shape))

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 2.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.5
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 83
-------------------



current thread_i 1
launch 64 evaluate tasks
this best socre: -215.4; best score: -215.4; global score: -209.6; space size: 1062882; measure cnt: 64
.............................................................................................................................
launch 12 evaluate tasks
this best socre: -215.4; best score: -215.4; global score: -209.6; space size: 1062882; measure cnt: 76
.......................................................................................................................................................................................................
launch 8 evaluate tasks
this best socre: -215.4; best score: -215.4; global score: -209.6; space size: 1062882; measure cnt: 84
.............................................................................................................................................................................
launch 9 evaluate tasks
this best socre: -215.4; best score: -215.4; global score: -209.6; space size: 1062882; measure cnt: 93
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an enhanced strategy.

    This function combines:
    1. Spatial fit analysis with dynamic thresholds
    2. Future packing potential estimation
    3. Bin utilization balance
    4. Dynamic diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic threshold based on item size
    min_remaining = 0.4 * item
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon)**3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > 0.4,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-0.2 * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins that are neither too empty nor too full
    target_utilization = 0.85  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Dynamic diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.6
    utilization_weight = 0.3
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3 * item, 0.5 * item])
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 2.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.6, 0.5])  # Expected average size of future items
    min_remaining_future = tunable([0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.95, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.4, 0.3])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.9, 0.8])
    future_weight = tunable([0.5, 0.6])
    utilization_weight = tunable([0.5, 0.4])
    diversity_weight = tunable([0.1, 0.2])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.25, 0.2])
    penalty_factor = tunable([0.6, 0.5])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 84
-------------------



current thread_i 9
launch 64 evaluate tasks
current thread_i 6
current thread_i 5
this best socre: -215.1; best score: -215.1; global score: -209.6; space size: 16384; measure cnt: 64
..........
launch 64 evaluate tasks
current thread_i 2
current thread_i 4
this best socre: -215.1; best score: -215.1; global score: -209.6; space size: 16384; measure cnt: 128
............................................
launch 64 evaluate tasks
current thread_i 3
this best socre: -215.1; best score: -215.1; global score: -209.6; space size: 16384; measure cnt: 192
....................................................
launch 64 evaluate tasks
current thread_i 0
current thread_i 8
this best socre: -215.1; best score: -215.1; global score: -209.6; space size: 16384; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining_options = [0.2 * item, 0.3 * item, 0.25 * item]
    min_remaining = tunable(min_remaining_options)
    
    # Adaptive decay factors based on remaining capacity
    decay_power_options = [1.0, 2.0, 3.0]
    decay_power = tunable(decay_power_options)
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 2.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** decay_power)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size_options = [0.7, 0.6, 0.5]
    avg_future_size = tunable(avg_future_size_options)
    
    min_remaining_future_options = [0.2, 0.3, 0.25]
    min_remaining_future = tunable(min_remaining_future_options)
    
    decay_rate_options = [0.15, 0.1, 0.2]
    decay_rate = tunable(decay_rate_options)
    
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization_options = [0.9, 0.95, 0.85]
    target_utilization = tunable(target_utilization_options)
    
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight_options = [0.9, 0.85, 0.95]
    future_weight_options = [0.6, 0.5, 0.7]
    utilization_weight_options = [0.5, 0.45, 0.55]
    diversity_weight_options = [0.4, 0.35, 0.45]
    
    spatial_weight = tunable(spatial_weight_options)
    future_weight = tunable(future_weight_options)
    utilization_weight = tunable(utilization_weight_options)
    diversity_weight = tunable(diversity_weight_options)

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold_options = [0.3, 0.25, 0.2]
    penalty_threshold = tunable(penalty_threshold_options)
    
    penalty_factor_options = [0.5, 0.6, 0.4]
    penalty_factor = tunable(penalty_factor_options)
    
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 85
-------------------


................................................................
launch 2 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 2; measure cnt: 2
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15, 0.2])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.92, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.85, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.5, 0.6, 0.7])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.6, 0.7, 0.8])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 86
-------------------



launch 64 evaluate tasks
current thread_i 1
this best socre: -220.75; best score: -220.75; global score: -209.6; space size: 3188646; measure cnt: 64
................................................................................................................................................................................................................................................................................................................................................................................
launch 27 evaluate tasks
this best socre: -220.75; best score: -220.75; global score: -209.6; space size: 3188646; measure cnt: 91
..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 38 evaluate tasks
this best socre: -218.85; best score: -218.85; global score: -209.6; space size: 3188646; measure cnt: 129
................................................................
launch 64 evaluate tasks
this best socre: -218.85; best score: -218.85; global score: -209.6; space size: 3188646; measure cnt: 193
.....................
launch 64 evaluate tasks
this best socre: -217.95; best score: -217.95; global score: -209.6; space size: 3188646; measure cnt: 257
......
launch 64 evaluate tasks
this best socre: -217.95; best score: -217.95; global score: -209.6; space size: 3188646; measure cnt: 321
....................
launch 64 evaluate tasks
this best socre: -217.95; best score: -217.95; global score: -209.6; space size: 3188646; measure cnt: 385
..............
launch 64 evaluate tasks
this best socre: -217.95; best score: -217.95; global score: -209.6; space size: 3188646; measure cnt: 449
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach with tunable parameters.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3 * item, 0.2 * item, 0.4 * item])
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 2.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.6, 0.5, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.3, 0.25, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15, 0.2])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.95, 0.9, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.4, 0.3, 0.5])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.9, 0.8, 1.0])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.5, 0.4, 0.6])
    diversity_weight = tunable([0.1, 0.2, 0.15])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.25, 0.2, 0.3])
    penalty_factor = tunable([0.6, 0.5, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 87
-------------------



launch 64 evaluate tasks
this best socre: -215.75; best score: -215.75; global score: -209.6; space size: 4782969; measure cnt: 64
.......................................................................
launch 1 evaluate tasks
this best socre: -215.75; best score: -215.75; global score: -209.6; space size: 4782969; measure cnt: 65
.....................................................................................................
launch 5 evaluate tasks
this best socre: -215.75; best score: -215.75; global score: -209.6; space size: 4782969; measure cnt: 70
.........................................................................
launch 1 evaluate tasks
this best socre: -215.75; best score: -215.75; global score: -209.6; space size: 4782969; measure cnt: 71
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.7, 0.8, 0.9])
    diversity_weight = tunable([0.3, 0.4, 0.5])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.4, 0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 88
-------------------



launch 64 evaluate tasks
this best socre: -210.0; best score: -210.0; global score: -209.6; space size: 1594323; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.0; best score: -210.0; global score: -209.6; space size: 1594323; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.0; best score: -210.0; global score: -209.6; space size: 1594323; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -210.0; best score: -210.0; global score: -209.6; space size: 1594323; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Load balance to maintain even distribution
    5. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable parameter
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Load balance component: Prefer bins with capacity near the mean
    mean_capacity = np.mean(bins)
    load_balance = np.exp(-np.abs(bins - mean_capacity) / (mean_capacity + epsilon))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    load_weight = tunable([0.3, 0.4, 0.5])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + load_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_load = (load_weight / total_weight) * load_balance
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_load + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.4, 0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 89
-------------------



launch 64 evaluate tasks
this best socre: -224.35; best score: -224.35; global score: -209.6; space size: 6377292; measure cnt: 64
................................................................
launch 0 evaluate tasks
this best socre: -10000000000.0; best score: -224.35; global score: -209.6; space size: 6377292; measure cnt: 64
................................................................
launch 0 evaluate tasks
this best socre: -10000000000.0; best score: -224.35; global score: -209.6; space size: 6377292; measure cnt: 64
................................................................
launch 0 evaluate tasks
this best socre: -10000000000.0; best score: -224.35; global score: -209.6; space size: 6377292; measure cnt: 64
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    exponent = tunable([2.0, 3.0, 4.0])  # Tunable exponent for spatial fit decay

    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 1.0])  # Target utilization level
    utilization_decay = tunable([0.5, 1.0, 1.5])  # Decay factor for utilization score
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-utilization_decay * np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_weight = tunable([0.05, 0.1, 0.15])  # Weight for diversity component
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])  # Weight for spatial fit
    future_weight = tunable([0.5, 0.6, 0.7])   # Weight for future potential
    utilization_weight = tunable([0.4, 0.5, 0.6])  # Weight for utilization score
    diversity_weight = tunable([0.1, 0.15, 0.2])  # Weight for diversity

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])  # Tunable penalty threshold
    penalty_factor = tunable([0.6, 0.7, 0.8])      # Tunable penalty factor
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 90
-------------------



launch 64 evaluate tasks
this best socre: -213.0; best score: -213.0; global score: -209.6; space size: 4782969; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.95; best score: -212.95; global score: -209.6; space size: 4782969; measure cnt: 128

launch 64 evaluate tasks
this best socre: -212.95; best score: -212.95; global score: -209.6; space size: 4782969; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.9; best score: -212.9; global score: -209.6; space size: 4782969; measure cnt: 256

launch 64 evaluate tasks
this best socre: -212.9; best score: -212.9; global score: -209.6; space size: 4782969; measure cnt: 320

launch 64 evaluate tasks
this best socre: -212.9; best score: -212.9; global score: -209.6; space size: 4782969; measure cnt: 384

launch 64 evaluate tasks
this best socre: -212.9; best score: -212.9; global score: -209.6; space size: 4782969; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic minimum remaining capacity based on item size and global memory
    min_remaining = tunable([0.2, 0.3]) * item
    min_remaining = max(min_remaining, tunable([0.15, 0.2]))  # Minimum absolute threshold

    # Adaptive exponent based on remaining capacity distribution
    exponent = tunable([4.0, 3.0])
    if np.mean(remaining_capacity[valid_bins]) < min_remaining:
        exponent = tunable([1.0, 1.5])  # Use lower exponent when capacity is tight

    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    if bins.size > tunable([10, 15]):  # Only calculate when enough history is available
        recent_bins = bins[-tunable([10, 15]):]  # Look at last N bins
        recent_items = recent_bins - np.roll(recent_bins, 1)  # Estimate recent items added
        recent_items = recent_items[recent_items > 0]  # Filter valid items
        if recent_items.size > 0:
            avg_future_size = np.mean(recent_items) * tunable([0.95, 0.9])
        else:
            avg_future_size = tunable([0.5, 0.6])  # Fallback to default
    else:
        avg_future_size = tunable([0.5, 0.6])

    min_remaining_future = tunable([0.3, 0.25])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.2, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.98, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        rc_values = remaining_capacity[valid_bins]
        # Calculate diversity based on distribution uniqueness
        sigma = tunable([0.2, 0.3])  # Tunable sigma for diversity calculation
        pairwise_diffs = np.abs(rc_values - rc_values[:, np.newaxis])
        similarities = np.exp(-pairwise_diffs ** 2 / (2 * sigma ** 2))
        sum_similarities = np.sum(similarities, axis=1)
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

        # Apply additional penalty for bins that are too similar to the best bin
        best_bin = np.argmax(remaining_capacity)
        best_bin_diffs = np.abs(remaining_capacity - remaining_capacity[best_bin])
        diversity_score = np.where(
            best_bin_diffs < tunable([0.2, 0.3]),
            diversity_score * tunable([0.5, 0.6]),
            diversity_score
        )

    # Combine components with tunable weights
    spatial_weight = tunable([0.9, 0.85])
    future_weight = tunable([0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5])
    diversity_weight = tunable([0.1, 0.2])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalties for edge cases
    penalty_threshold = tunable([0.2, 0.25])
    penalty_factor = tunable([0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    # Additional penalty for bins that are too full
    full_penalty_threshold = tunable([0.95, 0.9])
    full_penalty_factor = tunable([0.6, 0.7])
    priorities = np.where(bins > full_penalty_threshold, priorities * full_penalty_factor, priorities)

    # Bin refresh mechanism to prevent stagnation
    if np.random.rand() < tunable([0.02, 0.01]):
        priorities = priorities * (1 + np.random.normal(0, tunable([0.1, 0.05]), bins.shape))

    return priorities

call llm times: 91
-------------------



launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 67108864; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 67108864; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 67108864; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -209.6; space size: 67108864; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -209.6; space size: 67108864; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -209.6; space size: 67108864; measure cnt: 384

launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -209.6; space size: 67108864; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable options
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.4, 0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 92
-------------------



launch 64 evaluate tasks
this best socre: -211.1; best score: -211.1; global score: -209.6; space size: 1594323; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -209.6; space size: 1594323; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -209.6; space size: 1594323; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 1594323; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 1594323; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 1594323; measure cnt: 384

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 1594323; measure cnt: 448
sampler suggest should end sample, break
request...
-----------------------request...


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.05  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.7
    utilization_weight = 0.7
    diversity_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.05  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.7
    utilization_weight = 0.7
    diversity_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.05  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.7
    utilization_weight = 0.7
    diversity_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------request...
-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 4.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.05  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.7
    utilization_weight = 0.7
    diversity_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin packing.

    This version introduces:
    1. Dynamic spatial-temporal packing strategy
    2. Memory-aware future potential estimation
    3. Improved diversity scoring
    4. Better handling of edge cases

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and global memory
    min_remaining = 0.2 * item
    min_remaining = max(min_remaining, 0.15)  # Minimum absolute threshold
    
    # Adaptive exponent based on remaining capacity distribution
    exponent = 4.0 
    if np.mean(remaining_capacity[valid_bins]) < min_remaining:
        exponent = 1.0  # Use lower exponent when capacity is tight
    
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component with memory-aware estimation
    future_potential = np.zeros_like(bins, dtype=np.float64)
    
    # Calculate expected future item size using exponential moving average
    if bins.size > 10:  # Only calculate when enough history is available
        recent_bins = bins[-10:]  # Look at last 10 bins
        recent_items = recent_bins - np.roll(recent_bins, 1)  # Estimate recent items added
        recent_items = recent_items[recent_items > 0]  # Filter valid items
        if recent_items.size > 0:
            avg_future_size = np.mean(recent_items) * 0.95  # Discount factor
        else:
            avg_future_size = 0.5  # Fallback to default
    else:
        avg_future_size = 0.5
    
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.2  # Decay rate for large remaining capacities

    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component with dynamic target
    target_utilization = 0.98  # Adaptive target utilization
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component with improved scoring
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        rc_values = remaining_capacity[valid_bins]
        # Calculate diversity based on distribution uniqueness
        sigma = 0.2  # Tunable sigma for diversity calculation
        pairwise_diffs = np.abs(rc_values - rc_values[:, np.newaxis])
        similarities = np.exp(-pairwise_diffs ** 2 / (2 * sigma ** 2))
        sum_similarities = np.sum(similarities, axis=1)
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

        # Apply additional penalty for bins that are too similar to the best bin
        best_bin = np.argmax(remaining_capacity)
        best_bin_diffs = np.abs(remaining_capacity - remaining_capacity[best_bin])
        diversity_score = np.where(
            best_bin_diffs < 0.2,
            diversity_score * 0.5,
            diversity_score
        )

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.6
    utilization_weight = 0.4
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalties for edge cases
    penalty_threshold = 0.2
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    # Additional penalty for bins that are too full
    full_penalty_threshold = 0.95
    full_penalty_factor = 0.6
    priorities = np.where(bins > full_penalty_threshold, priorities * full_penalty_factor, priorities)

    # Bin refresh mechanism to prevent stagnation
    if np.random.rand() < 0.02:
        priorities = priorities * (1 + np.random.normal(0, 0.1, bins.shape))

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...-----------------------

request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity with tunable parameters.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with tunable parameters
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    exponent = 2.0  # Tunable exponent for spatial fit
    spatial_fit[valid_bins] = 1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining = 0.3    # Minimum acceptable remaining capacity
    decay_rate = 0.1       # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near target utilization
    target_utilization = 0.8  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Penalize bins with similar remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    similarity_threshold = 0.1  # Tunable similarity threshold
    for i in range(len(bins)):
        if valid_bins[i]:
            # Compare with other valid bins to measure similarity
            similarity = np.sum(np.abs(remaining_capacity[i] - remaining_capacity[valid_bins]) < similarity_threshold)
            diversity_score[i] = 1.0 / (1.0 + similarity)

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.3
    utilization_weight = 0.1
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.1
    penalty_factor = 0.7
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation
    3. Smart bin utilization balance
    4. Adaptive diversity encouragement

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic threshold based on item size and tunable parameter
    min_remaining = 0.5 * item
    exponent_low = 4.0
    exponent_high = 1.5

    # Adaptive spatial fit calculation
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_low),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent_high)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining_future = 0.3
    decay_rate = 0.1

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization
    target_utilization = 0.95
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.1
    if len(bins) > 1:
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply tunable penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering spatial fit, future potential, utilization, and diversity.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where remaining capacity is optimal for future items
    avg_future_size = 0.6  # Expected future item size
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    spatial_fit[valid_bins] = 1.0 / (1.0 + np.abs(remaining_capacity[valid_bins] - avg_future_size) + epsilon)

    # Future potential component: Reward bins with remaining capacity above a tunable threshold
    min_remaining = 0.3
    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining,
        1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - min_remaining))),
        0.0
    )

    # Utilization score component: Prefer bins near target utilization
    target_utilization = 0.8  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity score component: Penalize bins with similar remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    similarity_threshold = 0.1
    for i in range(len(bins)):
        if valid_bins[i]:
            # Compare with other valid bins to measure similarity
            similarity = np.sum(np.abs(remaining_capacity[i] - remaining_capacity[valid_bins]) < similarity_threshold)
            diversity_score[i] = 1.0 / (1.0 + similarity)

    # Combine components with tunable weights
    spatial_weight = 0.7
    future_weight = 0.3
    utilization_weight = 0.4
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = (
        normalized_spatial +
        normalized_future +
        normalized_utilization +
        normalized_diversity
    )

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable options
    min_remaining = 0.4 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 2.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.15  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.8  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 1.0
    future_weight = 0.7
    utilization_weight = 0.6
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.4
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and tunable options
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.1, 0.2, 0.3])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 93
-------------------



current thread_i 0
launch 64 evaluate tasks
current thread_i 9
this best socre: -210.15; best score: -210.15; global score: -209.6; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
current thread_i 6
current thread_i 1
current thread_i 4
this best socre: -210.15; best score: -210.15; global score: -209.6; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
current thread_i 3
this best socre: -210.15; best score: -210.15; global score: -209.6; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
current thread_i 5
current thread_i 8
this best socre: -210.15; best score: -210.15; global score: -209.6; space size: 531441; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 4.0, 5.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.4, 0.5, 0.6])
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.6, 0.7, 0.8])
    utilization_weight = tunable([0.6, 0.7, 0.8])
    diversity_weight = tunable([0.3, 0.4, 0.5])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 94
-------------------



launch 64 evaluate tasks
this best socre: -213.2; best score: -213.2; global score: -209.6; space size: 4782969; measure cnt: 64

launch 64 evaluate tasks
this best socre: -213.2; best score: -213.2; global score: -209.6; space size: 4782969; measure cnt: 128

launch 64 evaluate tasks
this best socre: -213.2; best score: -213.2; global score: -209.6; space size: 4782969; measure cnt: 192

launch 64 evaluate tasks
this best socre: -213.2; best score: -213.2; global score: -209.6; space size: 4782969; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable options
    min_remaining = tunable([0.2 * item, 0.3 * item, 0.4 * item])
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 4.0, 5.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.6, 0.7, 0.8])
    utilization_weight = tunable([0.6, 0.7, 0.8])
    diversity_weight = tunable([0.3, 0.4, 0.5])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 95
-------------------



launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 1594323; measure cnt: 64

launch 64 evaluate tasks
current thread_i 2
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 1594323; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 1594323; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.5; best score: -210.5; global score: -209.6; space size: 1594323; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.5; best score: -210.5; global score: -209.6; space size: 1594323; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.5; best score: -210.5; global score: -209.6; space size: 1594323; measure cnt: 384

launch 64 evaluate tasks
this best socre: -210.5; best score: -210.5; global score: -209.6; space size: 1594323; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable scaling
    min_remaining = tunable([0.3, 0.4, 0.5]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9])
    future_weight = tunable([0.6, 0.7])
    utilization_weight = tunable([0.6, 0.7])
    diversity_weight = tunable([0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25])
    penalty_factor = tunable([0.5, 0.6])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 96
-------------------



launch 64 evaluate tasks
this best socre: -213.4; best score: -213.4; global score: -209.6; space size: 27648; measure cnt: 64

launch 64 evaluate tasks
this best socre: -213.35; best score: -213.35; global score: -209.6; space size: 27648; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -213.35; best score: -213.35; global score: -209.6; space size: 27648; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -213.35; best score: -213.35; global score: -209.6; space size: 27648; measure cnt: 256

launch 64 evaluate tasks
this best socre: -213.3; best score: -213.3; global score: -209.6; space size: 27648; measure cnt: 320
.
launch 64 evaluate tasks
this best socre: -213.3; best score: -213.3; global score: -209.6; space size: 27648; measure cnt: 384

launch 64 evaluate tasks
this best socre: -213.25; best score: -213.25; global score: -209.6; space size: 27648; measure cnt: 448
.
launch 64 evaluate tasks
this best socre: -213.25; best score: -213.25; global score: -209.6; space size: 27648; measure cnt: 512
....
launch 64 evaluate tasks
this best socre: -213.25; best score: -213.25; global score: -209.6; space size: 27648; measure cnt: 576
.
launch 64 evaluate tasks
this best socre: -213.25; best score: -213.25; global score: -209.6; space size: 27648; measure cnt: 640
sampler suggest should end sample, break
-------------------
    """Advanced priority function for online bin-packing with dynamic parameters and ML integration."""
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4])(lambda: 0.3 * item)()
    
    # Calculate spatial fit with adaptive decay
    def calculate_spatial_fit(rc, min_r):
        return np.where(
            rc < min_r,
            1.0 / (1.0 + (rc + epsilon) ** tunable([2.0, 3.0, 4.0])(lambda: 3.0)()),
            1.0 / (1.0 + (rc + epsilon) ** tunable([1.0, 1.5, 2.0])(lambda: 1.0)())
        )
    spatial_fit[valid_bins] = calculate_spatial_fit(remaining_capacity[valid_bins], min_remaining)

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Using a simple moving average for expected future item sizes
    avg_future_size = tunable([0.5, 0.6, 0.7])(lambda: 0.6)  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])(lambda: 0.3)  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])(lambda: 0.1)  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.8, 0.85, 0.9])(lambda: 0.85)  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])(lambda: 0.8)
    future_weight = tunable([0.4, 0.5, 0.6])(lambda: 0.5)
    utilization_weight = tunable([0.3, 0.4, 0.5])(lambda: 0.4)
    diversity_weight = tunable([0.1, 0.2, 0.3])(lambda: 0.2)

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.1, 0.2, 0.25])(lambda: 0.2)
    penalty_factor = tunable([0.6, 0.7, 0.8])(lambda: 0.7)
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 97
-------------------



launch 64 evaluate tasks
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 1594323; measure cnt: 64

launch 64 evaluate tasks
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 1594323; measure cnt: 128

launch 64 evaluate tasks
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:48: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:51: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:53: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:54: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:55: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:58: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:65: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:66: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:67: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:68: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:77: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
<string>:78: SyntaxWarning: 'float' object is not callable; perhaps you missed a comma?
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 1594323; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Enhanced future packing potential estimation with expected item size distribution
    3. Smart bin utilization balance with dynamic target
    4. Advanced diversity encouragement using entropy

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size relative to bin capacity
    min_remaining_ratio = tunable([0.2, 0.3, 0.4])  # Tunable parameter
    min_remaining = min_remaining_ratio * np.maximum(item, np.mean(bins))

    # Calculate spatial fit with adaptive decay based on remaining capacity
    rc_valid = remaining_capacity[valid_bins]
    spatial_fit[valid_bins] = np.where(
        rc_valid < min_remaining,
        1.0 / (1.0 + (rc_valid + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (rc_valid + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Using expected distribution of future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    std_future_size = tunable([0.1, 0.2, 0.3])  # Expected standard deviation of future item sizes
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        rc_valid > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(rc_valid - avg_future_size)))) * 
        np.exp(-decay_rate * rc_valid) * 
        (1.0 + np.exp(-( (rc_valid - avg_future_size) ** 2 ) / (2 * std_future_size ** 2))),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    max_capacity = np.max(bins)
    utilization = bins / max_capacity
    target_utilization_base = tunable([0.9, 0.92, 0.95])  # Base target utilization
    target_utilization = target_utilization_base + (item / max_capacity) * tunable([0.05, 0.1, 0.15])
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities using entropy
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = tunable([0.2, 0.3, 0.4])  # Weight for diversity component
    if len(bins) > 1 and np.any(valid_bins):
        # Calculate distribution of remaining capacities
        rc_valid_normalized = rc_valid / np.sum(rc_valid)
        entropy = -np.sum(rc_valid_normalized * np.log(rc_valid_normalized + epsilon))
        diversity_score[valid_bins] = entropy

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])  # Tunable parameter
    penalty_factor = tunable([0.5, 0.6, 0.7])  # Tunable parameter
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 98
-------------------



launch 64 evaluate tasks
this best socre: -213.85; best score: -213.85; global score: -209.6; space size: 43046721; measure cnt: 64
............
launch 64 evaluate tasks
this best socre: -213.85; best score: -213.85; global score: -209.6; space size: 43046721; measure cnt: 128
........
launch 64 evaluate tasks
this best socre: -213.85; best score: -213.85; global score: -209.6; space size: 43046721; measure cnt: 192
..
launch 64 evaluate tasks
this best socre: -213.85; best score: -213.85; global score: -209.6; space size: 43046721; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with recent item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    # Using a tunable parameter for average future size based on recent items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.1, 0.2, 0.3])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.6, 0.7, 0.8])
    utilization_weight = tunable([0.6, 0.7, 0.8])
    diversity_weight = tunable([0.3, 0.4, 0.5])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 99
-------------------



launch 64 evaluate tasks
this best socre: -210.9; best score: -210.9; global score: -209.6; space size: 1594323; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 1594323; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 1594323; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 1594323; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -209.6; space size: 1594323; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable options
    min_remaining_options = [0.3 * item, 0.4 * item, 0.5 * item]
    min_remaining = tunable(min_remaining_options)
    
    # Calculate spatial fit with adaptive decay (tunable decay exponents)
    decay_exponent = tunable([2.0, 3.0, 4.0])
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** decay_exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.15, 0.2])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.85, 0.9, 0.95])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity_measure = tunable(['variance', 'entropy', 'std'])
        if diversity_measure == 'variance':
            diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        elif diversity_measure == 'entropy':
            prob = remaining_capacity[valid_bins] / np.sum(remaining_capacity[valid_bins])
            diversity = -np.sum(prob * np.log2(prob + epsilon))
        else:  # 'std'
            diversity = 1.0 / (1.0 + np.std(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.5, 0.6, 0.7])
    diversity_weight = tunable([0.2, 0.3, 0.4])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    # Normalize priorities to [0, 1] scale
    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + epsilon)

    return priorities

call llm times: 100
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -209.6; space size: 531441; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin using an advanced hybrid approach.
    
    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness
    5. Context-aware penalty mechanisms
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
        
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0
    
    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and global memory
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    min_remaining = max(min_remaining, tunable([0.15, 0.2, 0.25]))  # Minimum absolute threshold
    
    # Adaptive exponent based on remaining capacity distribution
    exponent = tunable([3.0, 4.0, 5.0])
    if np.mean(remaining_capacity[valid_bins]) < min_remaining:
        exponent = tunable([1.0, 1.5, 2.0])  # Lower exponent when capacity is tight
    
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )
    
    # Future potential component: Reward bins with remaining capacity suitable for future items
    future_potential = np.zeros_like(bins, dtype=np.float64)
    
    # Calculate expected future item size using weighted average of recent items
    if bins.size > tunable([10, 20, 30]):  # Only calculate when enough history is available
        recent_bins = bins[-tunable([10, 20, 30]):]  # Look at last N bins
        recent_items = recent_bins - np.roll(recent_bins, 1)  # Estimate recent items added
        recent_items = recent_items[recent_items > 0]  # Filter valid items
        if recent_items.size > 0:
            avg_future_size = np.mean(recent_items) * tunable([0.9, 0.95, 1.0])  # Discount factor
        else:
            avg_future_size = tunable([0.5, 0.6, 0.7])  # Fallback to default
    else:
        avg_future_size = tunable([0.5, 0.6, 0.7])
    
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.1, 0.2, 0.3])  # Decay rate for large remaining capacities
    
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )
    
    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.8, 0.85, 0.9, 0.95])  # Adaptive target utilization
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))
    
    # Diversity component: Encourage bins with varied remaining capacities using clustering
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        rc_values = remaining_capacity[valid_bins]
        if rc_values.size > 0:
            # Cluster remaining capacities
            num_clusters = tunable([2, 3, 4])
            cluster_centers = np.linspace(rc_values.min(), rc_values.max(), num_clusters)
            distances = np.abs(rc_values[:, np.newaxis] - cluster_centers)
            cluster_assignments = np.argmin(distances, axis=1)
            
            # Reward bins in less crowded clusters
            cluster_counts = np.bincount(cluster_assignments, minlength=num_clusters)
            cluster_weights = 1.0 / (1.0 + cluster_counts[cluster_assignments])
            diversity_score[valid_bins] = cluster_weights
        
        # Apply additional penalty for bins too similar to the best bin
        best_bin = np.argmax(remaining_capacity)
        best_bin_diffs = np.abs(remaining_capacity - remaining_capacity[best_bin])
        diversity_score = np.where(
            best_bin_diffs < tunable([0.2, 0.3, 0.4]),
            diversity_score * tunable([0.5, 0.6, 0.7]),
            diversity_score
        )
    
    # Combine components with tunable weights
    spatial_weight = tunable([0.8, 0.9, 1.0])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    diversity_weight = tunable([0.1, 0.2, 0.3])
    
    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero
    
    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score
    
    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity
    
    # Apply penalties for edge cases
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)
    
    # Additional penalty for bins that are too full
    full_penalty_threshold = tunable([0.9, 0.95, 1.0])
    full_penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(bins > full_penalty_threshold, priorities * full_penalty_factor, priorities)
    
    # Bin refresh mechanism to prevent stagnation
    if np.random.rand() < tunable([0.01, 0.02, 0.05]):
        priorities = priorities * (1 + np.random.normal(0, tunable([0.05, 0.1, 0.2]), bins.shape))
    
    return priorities

call llm times: 101
-------------------



launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -209.6; space size: 3389154437772; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 3389154437772; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 3389154437772; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 3389154437772; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -209.6; space size: 3389154437772; measure cnt: 320
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and tunable options
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.15  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.6
    utilization_weight = 0.5
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and tunable options
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.15  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.6
    utilization_weight = 0.5
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and tunable options
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.15  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.6
    utilization_weight = 0.5
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...request...
-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable options
    min_remaining = 0.2 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.4  # Minimum acceptable remaining capacity
    decay_rate = 0.05  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.8
    diversity_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable options
    min_remaining = 0.4 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 2.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.2  # Minimum acceptable remaining capacity
    decay_rate = 0.15  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.8  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 1.0
    future_weight = 0.7
    utilization_weight = 0.6
    diversity_weight = 0.3

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.2
    penalty_factor = 0.4
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


-----------------------
-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size with tunable options
    min_remaining = 0.2 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.4  # Minimum acceptable remaining capacity
    decay_rate = 0.05  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.8
    future_weight = 0.7
    utilization_weight = 0.8
    diversity_weight = 0.4

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero

    # Dynamic minimum remaining capacity based on item size and global memory
    min_remaining = 0.2 * item
    min_remaining = max(min_remaining, 0.2)  # Minimum absolute threshold

    # Adaptive exponent based on remaining capacity distribution
    exponent = 3.0
    if np.mean(remaining_capacity[valid_bins]) < min_remaining:
        exponent = 1.5  # Use lower exponent when capacity is tight

    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.5)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    if bins.size > 15:  # Only calculate when enough history is available
        recent_bins = bins[-10:]  # Look at last N bins
        recent_items = recent_bins - np.roll(recent_bins, 1)  # Estimate recent items added
        recent_items = recent_items[recent_items > 0]  # Filter valid items
        if recent_items.size > 0:
            avg_future_size = np.mean(recent_items) * 0.9
        else:
            avg_future_size = 0.5  # Fallback to default
    else:
        avg_future_size = 0.5

    min_remaining_future = 0.25  # Minimum acceptable remaining capacity
    decay_rate = 0.15  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        rc_values = remaining_capacity[valid_bins]
        # Calculate diversity based on distribution uniqueness
        sigma = 0.2  # Tunable sigma for diversity calculation
        pairwise_diffs = np.abs(rc_values - rc_values[:, np.newaxis])
        similarities = np.exp(-pairwise_diffs ** 2 / (2 * sigma ** 2))
        sum_similarities = np.sum(similarities, axis=1)
        diversity_score[valid_bins] = 1.0 / (1.0 + sum_similarities)

        # Apply additional penalty for bins that are too similar to the best bin
        best_bin = np.argmax(remaining_capacity)
        best_bin_diffs = np.abs(remaining_capacity - remaining_capacity[best_bin])
        diversity_score = np.where(
            best_bin_diffs < 0.3,
            diversity_score * 0.5,
            diversity_score
        )

    # Combine components with tunable weights
    spatial_weight = 0.85
    future_weight = 0.7
    utilization_weight = 0.4
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalties for edge cases
    penalty_threshold = 0.2
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    # Additional penalty for bins that are too full
    full_penalty_threshold = 0.9
    full_penalty_factor = 0.7
    priorities = np.where(bins > full_penalty_threshold, priorities * full_penalty_factor, priorities)

    # Bin refresh mechanism to prevent stagnation
    if np.random.rand() < 0.02:
        priorities = priorities * (1 + np.random.normal(0, 0.05, bins.shape))

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size and tunable options
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.7  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.15  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.3
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.6
    utilization_weight = 0.5
    diversity_weight = 0.2

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.5
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Adaptive exponent based on item size
    exponent = 2.0 if item > 0.7 else 1.5
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** exponent),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.5  # Expected average size of future items
    min_remaining_future = 0.25  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-0.3 * np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.5
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.6
    utilization_weight = 0.6
    diversity_weight = 0.05

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.3
    penalty_factor = 0.7
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = 0.3 * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 3.0),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** 1.0)
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = 0.6  # Expected average size of future items
    min_remaining_future = 0.3  # Minimum acceptable remaining capacity
    decay_rate = 0.1  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = 0.95  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    diversity_weight = 0.4
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = 0.9
    future_weight = 0.5
    utilization_weight = 0.5
    diversity_weight = 0.1

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = 0.25
    penalty_factor = 0.6
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, using an advanced hybrid approach.

    This function combines:
    1. Dynamic spatial fit analysis with adaptive thresholds
    2. Future packing potential estimation with expected item size consideration
    3. Utilization balance with dynamic target
    4. Diversity encouragement with distribution awareness

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0

    # Spatial fit component: Reward bins where item fits well with dynamic thresholds
    spatial_fit = np.zeros_like(bins, dtype=np.float64)
    epsilon = 1e-10  # Small value to avoid division by zero
    
    # Dynamic minimum remaining capacity based on item size
    min_remaining = tunable([0.2, 0.3, 0.4]) * item
    
    # Calculate spatial fit with adaptive decay
    spatial_fit[valid_bins] = np.where(
        remaining_capacity[valid_bins] < min_remaining,
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([2.0, 3.0, 4.0])),
        1.0 / (1.0 + (remaining_capacity[valid_bins] + epsilon) ** tunable([1.0, 1.5, 2.0]))
    )

    # Future potential component: Reward bins with remaining capacity suitable for future items
    avg_future_size = tunable([0.5, 0.6, 0.7])  # Expected average size of future items
    min_remaining_future = tunable([0.2, 0.3, 0.4])  # Minimum acceptable remaining capacity
    decay_rate = tunable([0.05, 0.1, 0.15])  # Decay rate for large remaining capacities

    future_potential = np.zeros_like(bins, dtype=np.float64)
    future_potential[valid_bins] = np.where(
        remaining_capacity[valid_bins] > min_remaining_future,
        (1.0 / (1.0 + np.exp(-(remaining_capacity[valid_bins] - avg_future_size)))) * 
        np.exp(-decay_rate * remaining_capacity[valid_bins]),
        0.0
    )

    # Utilization score component: Prefer bins near optimal utilization with dynamic target
    target_utilization = tunable([0.9, 0.95, 0.98])  # Target utilization level
    utilization = bins / np.max(bins)  # Normalize by max bin capacity
    utilization_score = np.exp(-np.abs(utilization - target_utilization))

    # Diversity component: Encourage bins with varied remaining capacities
    diversity_score = np.zeros_like(bins, dtype=np.float64)
    if len(bins) > 1:
        # Calculate diversity based on the distribution of remaining capacities
        diversity = 1.0 / (1.0 + np.var(remaining_capacity[valid_bins]))
        diversity_score[valid_bins] = diversity

    # Combine components with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.6, 0.7, 0.8])
    diversity_weight = tunable([0.3, 0.4, 0.5])

    # Ensure numerical stability and normalize weights
    total_weight = spatial_weight + future_weight + utilization_weight + diversity_weight
    if total_weight == 0:
        total_weight = 1.0  # Avoid division by zero

    normalized_spatial = (spatial_weight / total_weight) * spatial_fit
    normalized_future = (future_weight / total_weight) * future_potential
    normalized_utilization = (utilization_weight / total_weight) * utilization_score
    normalized_diversity = (diversity_weight / total_weight) * diversity_score

    # Calculate final priority scores
    priorities = normalized_spatial + normalized_future + normalized_utilization + normalized_diversity

    # Apply penalty for bins with too little remaining space
    penalty_threshold = tunable([0.2, 0.25, 0.3])
    penalty_factor = tunable([0.5, 0.6, 0.7])
    priorities = np.where(remaining_capacity < penalty_threshold, priorities * penalty_factor, priorities)

    return priorities

call llm times: 102
-------------------



current thread_i 1
launch 64 evaluate tasks
current thread_i 4
current thread_i 9
current thread_i 3
current thread_i 2
current thread_i 8
this best socre: -213.25; best score: -213.25; global score: -209.6; space size: 1594323; measure cnt: 64

launch 64 evaluate tasks
