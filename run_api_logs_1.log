+ python -u funsearch_bin_packing_llm_api.py
launch 1 evaluate tasks
INFO:absl:Best score increased to -500.0
current thread_i 0
current thread_i 1
current thread_i 2
current thread_i 3
current thread_i 4
current thread_icurrent thread_i 6
 5
current thread_i 7
current thread_i 8
current thread_i 9
request...
request...-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


-----------------------
-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
request...request...
-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

----------------------------------------------request...
-----------------------

-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------request...
-----------------------request...
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.



-----------------------

-----------------------
-----------------------
-------------------
    """Returns priority with which we want to add item to each bin.
    
    This version uses a combination of spatial fit and future packing potential.
    It considers:
    1. How well the item fits into the bin (spatial fit)
    2. The remaining capacity in the bin (future potential)
    3. The number of items already in the bin (flexibility)
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
        
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate spatial fit: higher values mean better fit
    fit_ratio = item / bins
    
    # Calculate remaining capacity ratio: higher values mean more space left
    remaining_capacity = bins - item
    remaining_ratio = remaining_capacity / bins
    
    # Penalize bins with higher item counts (fewer items mean more flexibility)
    item_counts = np.array([len(b) for b in bins])  # Assuming bins are represented with their item counts
    count_penalty = np.exp(-tunable([0.1, 0.2, 0.3]) * item_counts)
    
    # Combine fit and remaining capacity with tunable weights
    weight_fit = tunable([0.7, 0.8, 0.9])
    weight_remaining = tunable([0.3, 0.2, 0.1])
    
    # Use exponential scaling to emphasize better fits and more remaining space
    fit_score = np.exp(tunable([1.0, 1.5, 2.0]) * fit_ratio)
    remaining_score = np.exp(tunable([1.0, 1.5, 2.0]) * remaining_ratio)
    
    # Combine all components into the final priority
    priorities = weight_fit * fit_score + weight_remaining * remaining_score * count_penalty
    
    return priorities

call llm times: 1
-------------------


.......
launch 64 evaluate tasks
current thread_i 7
this best socre: -10000000000.0; best score: -10000000000.0; global score: -10000000000.0; space size: 243; measure cnt: 64
...........................................
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -10000000000.0; space size: 243; measure cnt: 128
...........................................................................................................................
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -10000000000.0; space size: 243; measure cnt: 192
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Calculate remaining capacities
    remaining = bins - item
    
    # Identify bins that can fit the item
    valid_bins = remaining >= 0
    
    # Tunable parameters
    weight_spatial = tunable([0.5, 0.6, 0.7])  # Weight for spatial fit component
    weight_future = tunable([0.5, 0.4, 0.3])   # Weight for future potential component
    optimal_remaining = tunable([0.1, 0.2, 0.3]) * bins  # Optimal remaining capacity for future items
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Calculate spatial fit score
            # Prefer bins that have some remaining space but not too much
            r = remaining[i]
            max_capacity = bins[i]
            
            # Normalize remaining space to [0,1]
            normalized_r = r / max_capacity
            
            # Spatial fit score: favors medium remaining space, penalizes too little or too much
            spatial_score = -np.abs(normalized_r - tunable([0.3, 0.4, 0.5]))
            
            # Calculate future potential score
            # How well does the remaining space match the expected future items?
            future_score = np.exp(-np.abs(r - optimal_remaining[i]) / (max_capacity * tunable([0.1, 0.2])))
            
            # Combine scores with tunable weights
            total_score = weight_spatial * spatial_score + weight_future * future_score
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    return priorities

call llm times: 2
-------------------


..............
launch 64 evaluate tasks
current thread_i 6
this best socre: -213.3; best score: -213.3; global score: -213.3; space size: 162; measure cnt: 64
..................................................................................current thread_i 2
.........................
launch 64 evaluate tasks
this best socre: -213.3; best score: -213.3; global score: -213.3; space size: 162; measure cnt: 128
......................................................................................................................................................................................................................................................................
launch 29 evaluate tasks
this best socre: -213.3; best score: -213.3; global score: -213.3; space size: 162; measure cnt: 157
................................................................
launch 0 evaluate tasks
this best socre: -10000000000.0; best score: -213.3; global score: -213.3; space size: 162; measure cnt: 157
sampler suggest should end sample, break
INFO:absl:Best score increased to -213.3
-------------------
    """Returns priority with which we want to add item to each bin.
    
    The priority strategy balances:
    1. Spatial Fit: How well the item fits into the bin
    2. Future Potential: How much capacity remains for future items
    3. Utilization Bonus: Preference for bins that are well-utilized
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    
    # Filter out bins that cannot accommodate the item
    valid_bins = remaining > 0
    
    # Spatial fit metric: How well the item fits into the bin
    # Higher ratio means better fit, but leaves less room for future items
    spatial_fit = (item / (bins + tunable([1e-5, 1e-4])))  # Add small epsilon to prevent division by zero
    
    # Future potential metric: How much capacity remains after placing the item
    # We prefer bins that leave enough room for future items
    future_potential = (remaining / bins) * tunable([0.8, 0.9, 1.0])
    
    # Utilization bonus: Preference for bins that are well-utilized
    # This helps prevent "wasteful" bins that are neither full nor empty
    utilization_bonus = np.minimum((bins - remaining) / bins, tunable([0.95, 0.98, 1.0]))
    
    # Combine metrics with tunable weights
    # Lower priority score means higher priority
    priorities = (
        (spatial_fit * tunable([0.7, 0.6, 0.8])) + 
        ((1 - future_potential) * tunable([0.3, 0.4, 0.2])) + 
        (utilization_bonus * tunable([0.1, 0.15, 0.2]))
    )
    
    # Penalize bins with very small remaining capacity to avoid fragmentation
    small_remaining_penalty = tunable([0.0, 0.1, 0.2])
    priorities += np.where(remaining < tunable([0.2, 0.1, 0.15]) * bins, small_remaining_penalty, 0)
    
    # Ensure valid bins have priority over invalid ones
    priorities[~valid_bins] = float('inf')
    
    return priorities

call llm times: 3
-------------------



launch 64 evaluate tasks
this best socre: -212.0; best score: -212.0; global score: -212.0; space size: 4374; measure cnt: 64
.
launch 64 evaluate tasks
current thread_i 4
this best socre: -212.0; best score: -212.0; global score: -212.0; space size: 4374; measure cnt: 128
.....
launch 64 evaluate tasks
this best socre: -212.0; best score: -212.0; global score: -212.0; space size: 4374; measure cnt: 192
..
launch 64 evaluate tasks
this best socre: -212.0; best score: -212.0; global score: -212.0; space size: 4374; measure cnt: 256
sampler suggest should end sample, break
INFO:absl:Best score increased to -212.0
-------------------
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future packing potential."""
    
    # Calculate remaining capacity if the item is placed in each bin
    remaining_capacity = bins - item
    
    # Avoid negative remaining capacities (though bins should have sufficient capacity)
    remaining_capacity = np.maximum(remaining_capacity, 0)
    
    # Spatial efficiency: how well the item fits into the bin relative to bin capacity
    spatial_efficiency = item / bins
    
    # Future potential: based on remaining capacity and expected future items
    # Using a tunable parameter for expected future item size
    expected_future_item = tunable([0.5, 0.3, 0.7])  # Example tunable parameter
    
    # Calculate future potential score
    future_potential = remaining_capacity / (expected_future_item + 1e-9)  # Avoid division by zero
    
    # Combine the metrics with tunable weights
    weight_spatial = tunable([0.5, 0.4, 0.6])
    weight_remaining = tunable([0.3, 0.4, 0.2])
    weight_future = tunable([0.2, 0.2, 0.2])
    
    # Normalize each component to prevent one metric from dominating
    spatial_norm = spatial_efficiency / np.max(spatial_efficiency)
    remaining_norm = remaining_capacity / np.max(remaining_capacity)
    future_norm = future_potential / np.max(future_potential)
    
    # Calculate priority as a weighted sum
    priorities = (
        weight_spatial * spatial_norm +
        weight_remaining * remaining_norm +
        weight_future * future_norm
    )
    
    return priorities

call llm times: 4
-------------------


......................................................
launch 64 evaluate tasks
this best socre: -311.45; best score: -311.45; global score: -212.0; space size: 81; measure cnt: 64
..................................................................................................................................
launch 14 evaluate tasks
this best socre: -311.45; best score: -311.45; global score: -212.0; space size: 81; measure cnt: 78
............................................................................................................................................
launch 3 evaluate tasks
this best socre: -311.45; best score: -311.45; global score: -212.0; space size: 81; measure cnt: 81
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Calculate remaining capacities
    remaining = bins - item
    
    # Identify bins that can fit the item
    valid_bins = remaining >= 0
    
    # Tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.5   # Weight for future potential component
    optimal_remaining = 0.3 * bins  # Optimal remaining capacity for future items
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Calculate spatial fit score
            # Prefer bins that have some remaining space but not too much
            r = remaining[i]
            max_capacity = bins[i]
            
            # Normalize remaining space to [0,1]
            normalized_r = r / max_capacity
            
            # Spatial fit score: favors medium remaining space, penalizes too little or too much
            spatial_score = -np.abs(normalized_r - 0.5)
            
            # Calculate future potential score
            # How well does the remaining space match the expected future items?
            future_score = np.exp(-np.abs(r - optimal_remaining[i]) / (max_capacity * 0.2))
            
            # Combine scores with tunable weights
            total_score = weight_spatial * spatial_score + weight_future * future_score
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin.
    
    The priority strategy balances:
    1. Spatial Fit: How well the item fits into the bin
    2. Future Potential: How much capacity remains for future items
    3. Utilization Bonus: Preference for bins that are well-utilized
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    
    # Filter out bins that cannot accommodate the item
    valid_bins = remaining > 0
    
    # Spatial fit metric: How well the item fits into the bin
    # Higher ratio means better fit, but leaves less room for future items
    spatial_fit = (item / (bins + 1e-4))  # Add small epsilon to prevent division by zero
    
    # Future potential metric: How much capacity remains after placing the item
    # We prefer bins that leave enough room for future items
    future_potential = (remaining / bins) * 0.9
    
    # Utilization bonus: Preference for bins that are well-utilized
    # This helps prevent "wasteful" bins that are neither full nor empty
    utilization_bonus = np.minimum((bins - remaining) / bins, 0.98)
    
    # Combine metrics with tunable weights
    # Lower priority score means higher priority
    priorities = (
        (spatial_fit * 0.8) + 
        ((1 - future_potential) * 0.2) + 
        (utilization_bonus * 0.2)
    )
    
    # Penalize bins with very small remaining capacity to avoid fragmentation
    small_remaining_penalty = 0.0
    priorities += np.where(remaining < 0.1 * bins, small_remaining_penalty, 0)
    
    # Ensure valid bins have priority over invalid ones
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Calculate remaining capacities
    remaining = bins - item
    
    # Identify bins that can fit the item
    valid_bins = remaining >= 0
    
    # Tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.5   # Weight for future potential component
    optimal_remaining = 0.3 * bins  # Optimal remaining capacity for future items
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Calculate spatial fit score
            # Prefer bins that have some remaining space but not too much
            r = remaining[i]
            max_capacity = bins[i]
            
            # Normalize remaining space to [0,1]
            normalized_r = r / max_capacity
            
            # Spatial fit score: favors medium remaining space, penalizes too little or too much
            spatial_score = -np.abs(normalized_r - 0.5)
            
            # Calculate future potential score
            # How well does the remaining space match the expected future items?
            future_score = np.exp(-np.abs(r - optimal_remaining[i]) / (max_capacity * 0.2))
            
            # Combine scores with tunable weights
            total_score = weight_spatial * spatial_score + weight_future * future_score
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin.
    
    The priority strategy balances:
    1. Spatial Fit: How well the item fits into the bin
    2. Future Potential: How much capacity remains for future items
    3. Utilization Bonus: Preference for bins that are well-utilized
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    
    # Filter out bins that cannot accommodate the item
    valid_bins = remaining > 0
    
    # Spatial fit metric: How well the item fits into the bin
    # Higher ratio means better fit, but leaves less room for future items
    spatial_fit = (item / (bins + 1e-4))  # Add small epsilon to prevent division by zero
    
    # Future potential metric: How much capacity remains after placing the item
    # We prefer bins that leave enough room for future items
    future_potential = (remaining / bins) * 0.9
    
    # Utilization bonus: Preference for bins that are well-utilized
    # This helps prevent "wasteful" bins that are neither full nor empty
    utilization_bonus = np.minimum((bins - remaining) / bins, 0.98)
    
    # Combine metrics with tunable weights
    # Lower priority score means higher priority
    priorities = (
        (spatial_fit * 0.8) + 
        ((1 - future_potential) * 0.2) + 
        (utilization_bonus * 0.2)
    )
    
    # Penalize bins with very small remaining capacity to avoid fragmentation
    small_remaining_penalty = 0.0
    priorities += np.where(remaining < 0.1 * bins, small_remaining_penalty, 0)
    
    # Ensure valid bins have priority over invalid ones
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Returns priority with which we want to add item to each bin.
    
    The priority strategy balances:
    1. Spatial Fit: How well the item fits into the bin
    2. Future Potential: How much capacity remains for future items
    3. Utilization Bonus: Preference for bins that are well-utilized
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    
    # Filter out bins that cannot accommodate the item
    valid_bins = remaining > 0
    
    # Spatial fit metric: How well the item fits into the bin
    # Higher ratio means better fit, but leaves less room for future items
    spatial_fit = (item / (bins + 1e-4))  # Add small epsilon to prevent division by zero
    
    # Future potential metric: How much capacity remains after placing the item
    # We prefer bins that leave enough room for future items
    future_potential = (remaining / bins) * 0.9
    
    # Utilization bonus: Preference for bins that are well-utilized
    # This helps prevent "wasteful" bins that are neither full nor empty
    utilization_bonus = np.minimum((bins - remaining) / bins, 0.98)
    
    # Combine metrics with tunable weights
    # Lower priority score means higher priority
    priorities = (
        (spatial_fit * 0.8) + 
        ((1 - future_potential) * 0.2) + 
        (utilization_bonus * 0.2)
    )
    
    # Penalize bins with very small remaining capacity to avoid fragmentation
    small_remaining_penalty = 0.0
    priorities += np.where(remaining < 0.1 * bins, small_remaining_penalty, 0)
    
    # Ensure valid bins have priority over invalid ones
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------
-------------------
    """Advanced priority strategy for online bin-packing.
    
    This function calculates the priority score for placing an item into each bin,
    considering both spatial fit and future packing potential. It uses tunable
    parameters to allow for dynamic adjustments.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Spatial fit metric: item / bin, scaled by tunable weight
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    
    # Future potential metric: remaining / bin, scaled by tunable weight
    future_potential_weight = tunable([0.3, 0.4, 0.5])
    future_potential = (remaining / bins) * future_potential_weight
    
    # Utilization bonus: preference for bins near ideal utilization
    ideal_utilization = tunable([0.7, 0.8, 0.9])
    utilization_bonus_weight = tunable([0.1, 0.2, 0.3])
    used = bins - remaining
    utilization = used / bins
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))
    
    # Fragmentation penalty: penalize very small remaining capacities
    fragmentation_threshold = tunable([0.1, 0.2, 0.3])
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15])
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold * bins,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )
    
    # Combine metrics into priority score
    priorities = spatial_fit + (1 - future_potential) + utilization_bonus + fragmentation_penalty
    
    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')
    
    return priorities

call llm times: 5
-------------------


.....current thread_i 4

launch 64 evaluate tasks
current thread_i 6
current thread_i 9
current thread_i 2
this best socre: -212.0; best score: -212.0; global score: -212.0; space size: 729; measure cnt: 64
............
launch 64 evaluate tasks
this best socre: -212.0; best score: -212.0; global score: -212.0; space size: 729; measure cnt: 128
............
launch 64 evaluate tasks
this best socre: -212.0; best score: -212.0; global score: -212.0; space size: 729; measure cnt: 192
............................
launch 64 evaluate tasks
this best socre: -212.0; best score: -212.0; global score: -212.0; space size: 729; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = tunable([0.4, 0.5, 0.6])  # Weight for spatial fit component
    weight_future = tunable([0.3, 0.4, 0.5])   # Weight for future potential component
    weight_util = tunable([0.2, 0.3, 0.4])     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = tunable([0.2, 0.3, 0.4]) * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], tunable([0.95, 0.98]))
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= tunable([1.0, 1.1, 1.2]) if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.0, 0.1, 0.2]) * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities

call llm times: 6
-------------------


..
launch 64 evaluate tasks
this best socre: -211.4; best score: -211.4; global score: -211.4; space size: 1458; measure cnt: 64
.......
launch 64 evaluate tasks
this best socre: -211.4; best score: -211.4; global score: -211.4; space size: 1458; measure cnt: 128
........
launch 64 evaluate tasks
this best socre: -211.4; best score: -211.4; global score: -211.4; space size: 1458; measure cnt: 192
...............
launch 64 evaluate tasks
this best socre: -211.4; best score: -211.4; global score: -211.4; space size: 1458; measure cnt: 256
sampler suggest should end sample, break
INFO:absl:Best score increased to -211.4
-------------------
    """Improved priority function considering spatial fit and future packing potential."""
    rem = bins - item
    
    # Tunable parameters
    threshold_multiplier = tunable([0.5, 1.0, 1.5])
    threshold = threshold_multiplier * item
    below_threshold = rem < threshold
    
    # Calculate spatial fit and remaining capacity ratio
    spatial_fit = item / bins
    rem_ratio = rem / bins
    
    # Combine with tunable weights
    alpha = tunable([0.5, 0.7, 0.9])  # Weight for spatial fit
    beta = tunable([0.5, 0.3, 0.1])   # Weight for remaining capacity
    priority = alpha * spatial_fit + beta * rem_ratio
    
    # Penalize bins where remaining capacity is below threshold
    priority[below_threshold] = -np.inf
    
    return priority

call llm times: 7
-------------------


............................................................................................................................................
launch 27 evaluate tasks
this best socre: -237.5; best score: -237.5; global score: -211.4; space size: 27; measure cnt: 27
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin.
    
    The priority strategy balances:
    1. Spatial Fit: How well the item fits into the bin
    2. Future Potential: How much capacity remains for future items
    3. Utilization Bonus: Preference for bins that are well-utilized
    4. Dynamic Weights: Adjust weights based on current bin utilization
    5. Look-ahead Heuristic: Simple prediction of future item sizes
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Calculate remaining capacities
    remaining = bins - item
    
    # Filter out bins that cannot accommodate the item
    valid_bins = remaining > 0
    
    # Calculate average remaining capacity across all bins
    avg_remaining = np.mean(remaining[valid_bins]) if np.any(valid_bins) else 0
    
    # Look-ahead heuristic: predict future item size (e.g., average of past items)
    # For demonstration, we'll assume future items are similar to the current item
    future_item_size = tunable([item, np.mean([item, np.min(bins)])])
    
    # Spatial fit metric: How well the item fits into the bin
    # Prefer bins where the item takes up a significant but not excessive portion of the bin
    spatial_fit = (item / (bins + 1e-4))  # Add small epsilon to prevent division by zero
    spatial_score = -np.abs(spatial_fit - tunable([0.6, 0.7]))  # Favor ~60-70% fit
    
    # Future potential metric: How much capacity remains after placing the item
    # Optimal remaining capacity is a tunable parameter
    optimal_remaining = tunable([0.3 * bins, 0.2 * bins])
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2))
    
    # Utilization bonus: Preference for bins that are well-utilized
    utilization = (bins - remaining) / bins
    utilization_bonus = np.exp(-np.abs(utilization - tunable([0.8, 0.85])))
    
    # Dynamic weights based on average remaining capacity
    if avg_remaining > tunable([0.2 * np.max(bins), 0.3 * np.max(bins)]):
        weight_spatial = tunable([0.5, 0.6])
        weight_future = tunable([0.4, 0.5])
    else:
        weight_spatial = tunable([0.4, 0.5])
        weight_future = tunable([0.6, 0.7])
    
    # Combine metrics with dynamic weights
    total_score = (
        weight_spatial * spatial_score +
        weight_future * future_potential +
        0.1 * utilization_bonus  # Fixed weight for utilization bonus
    )
    
    # Penalize bins with very small remaining capacity to avoid fragmentation
    small_remaining_penalty = tunable([-0.1, -0.2])
    total_score += np.where(remaining < tunable([0.1 * bins, 0.05 * bins]), small_remaining_penalty, 0)
    
    # Ensure valid bins have priority over invalid ones
    total_score[~valid_bins] = -np.inf
    
    # Normalize scores to a 0-1 range for better comparability
    if np.any(valid_bins):
        min_score = np.min(total_score[valid_bins])
        max_score = np.max(total_score[valid_bins])
        if max_score != min_score:
            priorities[valid_bins] = (total_score[valid_bins] - min_score) / (max_score - min_score)
        else:
            priorities[valid_bins] = 0.5  # Assign neutral priority if all scores are equal
    else:
        priorities[:] = -np.inf  # All bins are invalid
    
    return priorities

call llm times: 8
-------------------



launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -211.4; space size: 3072; measure cnt: 64
...
launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -211.4; space size: 3072; measure cnt: 128
..
launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -211.4; space size: 3072; measure cnt: 192
............
launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -211.4; space size: 3072; measure cnt: 256
sampler suggest should end sample, break
request...
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing.
    
    This function calculates the priority score for placing an item into each bin,
    considering both spatial fit and future packing potential. It uses tunable
    parameters to allow for dynamic adjustments.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Spatial fit metric: item / bin, scaled by tunable weight
    spatial_fit_weight = 0.7
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    
    # Future potential metric: remaining / bin, scaled by tunable weight
    future_potential_weight = 0.3
    future_potential = (remaining / bins) * future_potential_weight
    
    # Utilization bonus: preference for bins near ideal utilization
    ideal_utilization = 0.8
    utilization_bonus_weight = 0.2
    used = bins - remaining
    utilization = used / bins
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))
    
    # Fragmentation penalty: penalize very small remaining capacities
    fragmentation_threshold = 0.3
    fragmentation_penalty_weight = 0.1
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold * bins,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )
    
    # Combine metrics into priority score
    priorities = spatial_fit + (1 - future_potential) + utilization_bonus + fragmentation_penalty
    
    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing.
    
    This function calculates the priority score for placing an item into each bin,
    considering both spatial fit and future packing potential. It uses tunable
    parameters to allow for dynamic adjustments.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Spatial fit metric: item / bin, scaled by tunable weight
    spatial_fit_weight = 0.7
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    
    # Future potential metric: remaining / bin, scaled by tunable weight
    future_potential_weight = 0.3
    future_potential = (remaining / bins) * future_potential_weight
    
    # Utilization bonus: preference for bins near ideal utilization
    ideal_utilization = 0.8
    utilization_bonus_weight = 0.2
    used = bins - remaining
    utilization = used / bins
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))
    
    # Fragmentation penalty: penalize very small remaining capacities
    fragmentation_threshold = 0.3
    fragmentation_penalty_weight = 0.1
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold * bins,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )
    
    # Combine metrics into priority score
    priorities = spatial_fit + (1 - future_potential) + utilization_bonus + fragmentation_penalty
    
    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin.
    
    The priority strategy balances:
    1. Spatial Fit: How well the item fits into the bin
    2. Future Potential: How much capacity remains for future items
    3. Utilization Bonus: Preference for bins that are well-utilized
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    
    # Filter out bins that cannot accommodate the item
    valid_bins = remaining > 0
    
    # Spatial fit metric: How well the item fits into the bin
    # Higher ratio means better fit, but leaves less room for future items
    spatial_fit = (item / (bins + 1e-4))  # Add small epsilon to prevent division by zero
    
    # Future potential metric: How much capacity remains after placing the item
    # We prefer bins that leave enough room for future items
    future_potential = (remaining / bins) * 0.9
    
    # Utilization bonus: Preference for bins that are well-utilized
    # This helps prevent "wasteful" bins that are neither full nor empty
    utilization_bonus = np.minimum((bins - remaining) / bins, 0.98)
    
    # Combine metrics with tunable weights
    # Lower priority score means higher priority
    priorities = (
        (spatial_fit * 0.8) + 
        ((1 - future_potential) * 0.2) + 
        (utilization_bonus * 0.2)
    )
    
    # Penalize bins with very small remaining capacity to avoid fragmentation
    small_remaining_penalty = 0.0
    priorities += np.where(remaining < 0.1 * bins, small_remaining_penalty, 0)
    
    # Ensure valid bins have priority over invalid ones
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing.
    
    This function calculates the priority score for placing an item into each bin,
    considering both spatial fit and future packing potential. It uses tunable
    parameters to allow for dynamic adjustments.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Spatial fit metric: item / bin, scaled by tunable weight
    spatial_fit_weight = 0.7
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    
    # Future potential metric: remaining / bin, scaled by tunable weight
    future_potential_weight = 0.3
    future_potential = (remaining / bins) * future_potential_weight
    
    # Utilization bonus: preference for bins near ideal utilization
    ideal_utilization = 0.8
    utilization_bonus_weight = 0.2
    used = bins - remaining
    utilization = used / bins
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))
    
    # Fragmentation penalty: penalize very small remaining capacities
    fragmentation_threshold = 0.3
    fragmentation_penalty_weight = 0.1
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold * bins,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )
    
    # Combine metrics into priority score
    priorities = spatial_fit + (1 - future_potential) + utilization_bonus + fragmentation_penalty
    
    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
response.status_code 500 {"error":{"code":"InternalServiceError","message":"The service encountered an unexpected internal error. Request id: 0217416086728496d9c1aef8f6a3ce0a02e1cd1f3f5c7b4e9a99a","param":"","type":"InternalServerError"}}
errr111__0
request net error
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Returns priority with which we want to add item to each bin, considering both fit and future potential."""
    # Calculate the fit ratio for each bin (item / bin)
    fit = np.where(bins >= item, item / bins, 0)
    
    # Calculate the remaining capacity ratio for each bin ((bin - item) / bin)
    remaining = bins - item
    remaining_ratio = np.where(bins >= item, remaining / bins, 0)
    
    # Get tunable parameters for weights
    alpha = tunable([1.0, 2.0, 0.5])
    beta = tunable([1.0, 0.5, 2.0])
    
    # Compute the priority as a weighted sum
    priorities = alpha * fit + beta * remaining_ratio
    
    return priorities

call llm times: 9
-------------------


.................................................................................................
launch 9 evaluate tasks
current thread_i 7
this best socre: -212.0; best score: -212.0; global score: -211.4; space size: 9; measure cnt: 9
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both fit and future potential."""
    # Calculate the fit ratio for each bin (item / bin)
    fit = np.where(bins >= item, item / bins, 0)
    
    # Calculate the remaining capacity ratio for each bin ((bin - item) / bin)
    remaining = bins - item
    remaining_ratio = np.where(bins >= item, remaining / bins, 0)
    
    # Get tunable parameters for weights
    alpha = 2.0
    beta = 1.0
    
    # Compute the priority as a weighted sum
    priorities = alpha * fit + beta * remaining_ratio
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = tunable([0.4, 0.5, 0.6])  # Weight for spatial fit component
    weight_future = tunable([0.3, 0.4, 0.5])   # Weight for future potential component
    weight_util = tunable([0.2, 0.3, 0.4])     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = tunable([0.2, 0.3, 0.4]) * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * tunable([0.1, 0.2, 0.3])))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], tunable([0.9, 0.95, 1.0]))
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > tunable([0.7, 0.8]):
                total_score *= tunable([1.0, 1.1, 1.2])
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.1, 0.2, 0.3]) * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities

call llm times: 10
-------------------


.current thread_i 6

launch 64 evaluate tasks
this best socre: -211.4; best score: -211.4; global score: -211.4; space size: 13122; measure cnt: 64

launch 64 evaluate tasks
current thread_i 1
current thread_i 2
current thread_i 0
this best socre: -211.4; best score: -211.4; global score: -211.4; space size: 13122; measure cnt: 128
.
launch 64 evaluate tasks
response.status_code 500 {"error":{"code":"InternalServiceError","message":"The service encountered an unexpected internal error. Request id: 02174160867287120d7cff2795961aae00fce54df1e26da8e1663","param":"","type":"InternalServerError"}}
errr111__0
request net error
current thread_i 9
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
this best socre: -211.4; best score: -211.4; global score: -211.4; space size: 13122; measure cnt: 192
..
launch 64 evaluate tasks
this best socre: -211.4; best score: -211.4; global score: -211.4; space size: 13122; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin.

    This version improves upon `priority_v0` by considering both the spatial fit
    of the item into the bin and the future potential of the bin to accommodate
    subsequent items. The priority is a weighted sum of two components:
    1. Fit Score: Higher when the item fits the bin well (small remaining space).
    2. Future Score: Higher when the bin leaves enough space for future items.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    remaining = bins - item
    valid = remaining > 0
    remaining[~valid] = 0  # Items that can't fit have zero priority

    # Fit score: Higher when remaining space is smaller (better fit)
    fit_score = np.exp(-remaining)
    fit_score[~valid] = 0

    # Future score: Higher when remaining space is above a tunable threshold
    threshold = tunable([0.2, 0.5])
    future_score = np.where(remaining > threshold, remaining, 0)

    # Combine fit and future scores with tunable weights
    weight_fit = tunable([0.7, 0.5, 0.8])
    weight_future = tunable([0.3, 0.5, 0.2])

    priorities = weight_fit * fit_score + weight_future * future_score

    return priorities

call llm times: 11
-------------------


...........................................................................................
launch 17 evaluate tasks
this best socre: -500.0; best score: -500.0; global score: -211.4; space size: 18; measure cnt: 17
............................................................................................................................
launch 1 evaluate tasks
this best socre: -500.0; best score: -500.0; global score: -211.4; space size: 18; measure cnt: 18
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin, considering:
    1. Spatial fit: How well the item fits into the bin.
    2. Future potential: The impact on future packing efficiency.
    3. Dynamic weight adjustments based on current bin state.
    4. Lookahead mechanism to simulate future placements.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    
    # Initialize priority array
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Tunable parameters
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.3, 0.4])
    utilization_bonus_weight = tunable([0.2, 0.3])
    fragmentation_threshold = tunable([0.2, 0.3])
    lookahead_depth = tunable([1, 2, 3])
    
    # Calculate basic metrics
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = item / bins[i]
            
            # Future potential metric: Consider remaining capacity and its impact on future items
            remaining_ratio = remaining[i] / bins[i]
            future_potential = np.exp(-np.abs(remaining_ratio - 0.4))  # Optimal remaining ratio around 40%
            
            # Utilization bonus: Prefer bins that are well-utilized
            utilization = (bins[i] - remaining[i]) / bins[i]
            utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - 0.8))
            
            # Fragmentation penalty
            fragmentation_penalty = 0.0
            if remaining[i] < fragmentation_threshold * bins[i]:
                fragmentation_penalty = 0.1 * (1 - (remaining[i] / bins[i]))
            
            # Lookahead: Simulate placing the item and evaluate future potential
            # This is a simplified lookahead; in practice, it could involve more complex simulations
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_score = np.mean(priority_v1(item, simulated_bins))  # Example using previous version
            
            # Combine metrics with dynamic weights
            total_score = (
                spatial_fit_weight * spatial_fit +
                future_potential_weight * future_potential +
                utilization_bonus +
                fragmentation_penalty +
                0.1 * future_score  # Weight future score
            )
            
            priorities[i] = total_score
        else:
            priorities[i] = float('inf')  # Invalid bins have infinite priority (lowest preference)
    
    # Apply global adjustments based on bin usage
    global_usage = np.mean(bins - remaining) / np.mean(bins)
    if global_usage > 0.8:
        # If bins are mostly full, prioritize fragmentation reduction
        priorities += 0.2 * np.where(remaining < bins * 0.3, 1.0, 0.0)
    
    return priorities

call llm times: 12
-------------------


................................................................................................
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.4; space size: 72; measure cnt: 64
...............................................................................................................................................................................................................................
launch 7 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.4; space size: 72; measure cnt: 71
...................................................................................................
launch 1 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.4; space size: 72; measure cnt: 72
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering both immediate fit and future potential."""
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0  # Only consider bins that can fit the item
    
    # Calculate the ratio of item size to remaining capacity
    ratios = np.full_like(bins, np.nan)
    ratios[valid_bins] = item / remaining_capacity[valid_bins]
    
    # Immediate fit score: Penalize very small and very large ratios
    target_ratio = tunable([0.5, 0.6, 0.7])  # Target ratio for optimal fit
    fit_score = -np.abs(ratios - target_ratio)
    
    # Future potential score: Reward remaining capacity above a certain threshold
    min_remaining = tunable([0.1, 0.2, 0.3])  # Minimum desired remaining capacity
    future_score = np.zeros_like(bins)
    future_score[valid_bins] = remaining_capacity[valid_bins] - min_remaining
    future_score[future_score < 0] = 0  # No reward for remaining below threshold
    
    # Combine scores with tunable weights
    fit_weight = tunable([0.5, 0.6, 0.7])  # Weight for immediate fit
    future_weight = 1 - fit_weight
    
    total_score = fit_weight * fit_score + future_weight * future_score
    total_score[~valid_bins] = 0  # Invalid bins have zero priority
    
    # Ensure numerical stability and convert to priority (higher is better)
    priorities = total_score
    return priorities

call llm times: 13
-------------------


.........................................................................................................................................................
launch 27 evaluate tasks
current thread_i 5
this best socre: -500.0; best score: -500.0; global score: -211.4; space size: 27; measure cnt: 27
sampler suggest should end sample, break
-------------------
    """Improved priority function for online bin-packing with dynamic strategies.
    
    This version implements an advanced strategy that balances spatial fit with future potential,
    utilizing dynamic weights and tunable parameters for optimal performance across scenarios.
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priorities
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = tunable([0.4, 0.5, 0.6])  # Weight for spatial fit component
    weight_future = tunable([0.3, 0.4, 0.5])   # Weight for future potential component
    weight_util = tunable([0.2, 0.3, 0.4])     # Weight for utilization bonus
    
    optimal_remaining_ratio = tunable([0.1, 0.2, 0.3])  # Optimal remaining capacity ratio
    small_remaining_penalty = tunable([0.05, 0.1, 0.15])  # Penalty threshold
    
    # Calculate global metrics
    avg_bin_usage = np.mean((bins - remaining) / bins) if n_bins > 0 else 0
    
    # Dynamic weight adjustment based on global bin usage
    if avg_bin_usage < 0.6:
        # Emphasize utilization when bins are underutilized
        weight_util = tunable([0.3, 0.4, 0.5])
    elif avg_bin_usage > 0.8:
        # Emphasize future potential when bins are heavily utilized
        weight_future = tunable([0.4, 0.5, 0.6])
    
    # Calculate optimal remaining capacity
    optimal_remaining = bins * optimal_remaining_ratio
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = item / bins[i]
            
            # Future potential metric: How close remaining is to optimal
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with dynamic weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply penalty for very small remaining capacity
            if remaining[i] < bins[i] * small_remaining_penalty:
                total_score *= 0.5  # Reduce priority
            
            priorities[i] = total_score
        else:
            # Invalid bins get a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.1, 0.2, 0.3]) * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities

call llm times: 14
-------------------



launch 64 evaluate tasks
this best socre: -212.95; best score: -212.95; global score: -211.4; space size: 6561; measure cnt: 64
..
launch 64 evaluate tasks
this best socre: -212.95; best score: -212.95; global score: -211.4; space size: 6561; measure cnt: 128
.
launch 64 evaluate tasks
current thread_i 8
this best socre: -212.95; best score: -212.95; global score: -211.4; space size: 6561; measure cnt: 192
..
launch 64 evaluate tasks
this best socre: -212.95; best score: -212.95; global score: -211.4; space size: 6561; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Improved version of `priority_v0` that considers both current fit and future potential."""
    # Calculate the ratio of item size to remaining bin capacity
    ratios = item / bins
    
    # Calculate fit score using negative log of ratios
    fit_score = -np.log(ratios)
    
    # Calculate future score as the remaining capacity after adding the item
    remaining_after = bins - item
    future_score = remaining_after / bins  # Normalize future score
    
    # Get tunable weights for fit and future scores
    alpha = tunable([0.5, 0.7, 0.9])  # Weight for fit score
    beta = tunable([0.5, 0.3, 0.1])   # Weight for future score
    
    # Combine fit and future scores
    priorities = alpha * fit_score + beta * future_score
    
    # Apply a tunable threshold to penalize bins leaving too little space
    threshold = tunable([0.2, 0.5])  # Fraction of bin's capacity to leave
    penalty_mask = remaining_after < threshold * bins
    priorities[penalty_mask] *= 0.5  # Reduce priority for bins below threshold
    
    # Ensure bins that cannot fit the item have zero priority
    priorities[bins < item] = 0
    
    return priorities

call llm times: 15
-------------------


......................................................................................
launch 18 evaluate tasks
this best socre: -500.0; best score: -500.0; global score: -211.4; space size: 18; measure cnt: 18
sampler suggest should end sample, break
-------------------
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    # Filter out bins that cannot accommodate the item
    valid_bins = bins >= item
    valid_indices = np.where(valid_bins)[0]
    
    # Calculate spatial fit metric: inverse of the ratio of item to bin capacity
    ratios = item / bins[valid_bins]
    spatial_fit = 1.0 / ratios
    
    # Calculate remaining capacity after placing the item
    remaining_capacity = bins[valid_bins] - item
    
    # Future potential metric: remaining capacity scaled by a tunable factor
    future_scale = tunable([0.5, 0.75, 1.0])
    future_potential = remaining_capacity * future_scale
    
    # Combine spatial fit and future potential with tunable weights
    spatial_weight = tunable([0.7, 0.8, 0.9])
    future_weight = tunable([0.3, 0.2, 0.1])
    combined_score = (spatial_weight * spatial_fit) + (future_weight * future_potential)
    
    # Apply penalty for bins that would be filled beyond a tunable threshold
    penalty_threshold = tunable([0.8, 0.9, 0.95])
    utilization = (item / bins[valid_bins])
    penalty = np.where(utilization > penalty_threshold, tunable([0.1, 0.2, 0.3]), 0)
    combined_score -= penalty
    
    # Create an array of priorities with invalid bins set to a very low value
    priorities = np.zeros_like(bins, dtype=float)
    priorities[valid_indices] = combined_score
    
    return priorities

call llm times: 16
-------------------


..............
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.4; space size: 243; measure cnt: 64
.........................................
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.4; space size: 243; measure cnt: 128
..............................................................................................................................
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.4; space size: 243; measure cnt: 192
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.1))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.7:
                total_score *= 1.2
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.1))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.7:
                total_score *= 1.2
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...
-----------------------
-----------------------request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.1))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.7:
                total_score *= 1.2
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...
import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.1))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.7:
                total_score *= 1.2
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.



-----------------------
-----------------------
-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.1))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.7:
                total_score *= 1.2
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.1))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.7:
                total_score *= 1.2
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
request...
-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.1))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.7:
                total_score *= 1.2
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Advanced priority function for online bin-packing with dynamic strategies."""
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    valid_bins = bins >= item
    remaining = bins - item

    # Tunable parameters
    weight_spatial = tunable([0.4, 0.5, 0.6])  # Weight for spatial fit
    weight_future = tunable([0.3, 0.4, 0.5])   # Weight for future potential
    weight_util = tunable([0.1, 0.2, 0.3])     # Weight for utilization
    optimal_remaining_frac = tunable([0.1, 0.2, 0.3])  # Optimal remaining capacity fraction
    diversity_weight = tunable([0.05, 0.1, 0.15])  # Weight for diversity component
    low_remaining_threshold = tunable([0.2, 0.3, 0.4])  # Threshold for low remaining capacity

    # Calculate global statistics
    avg_remaining = np.mean(remaining[valid_bins])
    std_remaining = np.std(remaining[valid_bins])
    global_usage = np.mean(bins - remaining) / np.mean(bins)

    # Adjust weights based on global state
    if global_usage > tunable([0.6, 0.7]):
        weight_future = tunable([0.5, 0.6, 0.7])
        weight_spatial = tunable([0.3, 0.4, 0.5])
    else:
        weight_future = tunable([0.2, 0.3, 0.4])
        weight_spatial = tunable([0.5, 0.6, 0.7])

    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = item / bins[i]

            # Future potential metric: prefers remaining capacity near optimal
            optimal_remaining = bins[i] * optimal_remaining_frac
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * 0.1))

            # Utilization bonus: prefers bins that are well-used but not too full
            utilization = (bins[i] - remaining[i]) / bins[i]
            utilization_bonus = utilization if utilization < 0.95 else 0.95

            # Diversity component: prefers bins with remaining capacity that's less common
            # Calculate how unique the remaining capacity is
            diversity_score = 1.0 - np.mean(np.abs(remaining - remaining[i])) / (bins[i] * 0.1)
            diversity_score = np.clip(diversity_score, 0.0, 1.0)

            # Combine metrics with dynamic weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus +
                diversity_weight * diversity_score
            )

            # Apply bonus for bins with remaining capacity above a certain threshold
            if remaining[i] > bins[i] * tunable([0.3, 0.4]):
                total_score *= tunable([1.1, 1.2])

            priorities[i] = total_score
        else:
            priorities[i] = -np.inf

    # Apply diversity bonus based on overall distribution
    diversity_bonus = diversity_weight * (std_remaining / (np.mean(bins) * 0.1))
    priorities += diversity_bonus

    # Penalize bins with very low remaining capacity to prevent overstuffing
    low_remaining_mask = remaining < bins * low_remaining_threshold
    priorities[low_remaining_mask] *= tunable([0.9, 0.8])

    return priorities

call llm times: 17
-------------------


current thread_i 7

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.4; space size: 944784; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.4; space size: 944784; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -211.4; space size: 944784; measure cnt: 192
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.1))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.7:
                total_score *= 1.2
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = tunable([0.6, 0.7, 0.8])
    future_potential_base_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_base_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_base_weight = tunable([0.1, 0.2, 0.3])
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.7, 0.8]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.8, 0.9])
        future_potential_weight = future_potential_base_weight * tunable([1.2, 1.3])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.2, 1.3])
        future_potential_weight = future_potential_base_weight * tunable([0.8, 0.9])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = tunable([0.2, 0.3, 0.4]) * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.7, 0.8, 0.9])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = tunable([0.2, 0.3, 0.4]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.1, 0.2, 0.3]) * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 18
-------------------



current thread_i 4
launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -211.05; space size: 209952; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.95; space size: 209952; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.95; space size: 209952; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.95; space size: 209952; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.95; space size: 209952; measure cnt: 320
sampler suggest should end sample, break
INFO:absl:Best score increased to -210.95
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both fit and future potential."""
    # Calculate the fit ratio for each bin (item / bin)
    fit = np.where(bins >= item, item / bins, 0)
    
    # Calculate the remaining capacity ratio for each bin ((bin - item) / bin)
    remaining = bins - item
    remaining_ratio = np.where(bins >= item, remaining / bins, 0)
    
    # Get tunable parameters for weights
    alpha = 2.0
    beta = 1.0
    
    # Compute the priority as a weighted sum
    priorities = alpha * fit + beta * remaining_ratio
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Advanced priority function for online bin-packing with a novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to encourage balanced bin usage
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = tunable([0.5, 0.6, 0.7])  # Weight for spatial fit component
    weight_future = tunable([0.4, 0.5, 0.6])   # Weight for future potential component
    weight_util = tunable([0.2, 0.3, 0.4])     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining_multiplier = tunable([0.1, 0.2, 0.3])
    optimal_remaining = optimal_remaining_multiplier * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            # Using a more sophisticated decay function
            decay_rate = tunable([0.1, 0.2, 0.3])
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * decay_rate))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], tunable([0.85, 0.9, 0.95]))
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > tunable([0.6, 0.7, 0.8]):
                total_score *= tunable([1.1, 1.2, 1.3])
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus_multiplier = tunable([0.1, 0.2, 0.3])
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities

call llm times: 19
-------------------



current thread_i 6
launch 64 evaluate tasks
current thread_i 5
current thread_i 2
current thread_i 7
current thread_i 9
current thread_i 8
this best socre: -212.5; best score: -212.5; global score: -210.95; space size: 19683; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.45; best score: -212.45; global score: -210.95; space size: 19683; measure cnt: 128

launch 64 evaluate tasks
current thread_i 0
this best socre: -212.45; best score: -212.45; global score: -210.95; space size: 19683; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.45; best score: -212.45; global score: -210.95; space size: 19683; measure cnt: 256
.
launch 64 evaluate tasks
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 19683; measure cnt: 320
.
launch 64 evaluate tasks
current thread_i 4
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 19683; measure cnt: 384
..
launch 64 evaluate tasks
current thread_i 3
errrrrrr launch_llm Can not find core code.
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 19683; measure cnt: 448
.
launch 64 evaluate tasks
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 19683; measure cnt: 512
sampler suggest should end sample, break
request...request...
request...
request...-----------------------
request...
import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function for online bin-packing.
    
    This version implements a novel "Dynamic Capacity Balancing" strategy that:
    1. Considers both immediate fit and long-term capacity management
    2. Uses a hybrid approach combining spatial fit with future potential
    3. Implements adaptive weight tuning based on bin utilization patterns
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Calculate basic metrics
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.2     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.2))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.95)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            total_score *= 1.0 if global_usage < 0.7 else 1.0
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both fit and future potential."""
    # Calculate the fit ratio for each bin (item / bin)
    fit = np.where(bins >= item, item / bins, 0)
    
    # Calculate the remaining capacity ratio for each bin ((bin - item) / bin)
    remaining = bins - item
    remaining_ratio = np.where(bins >= item, remaining / bins, 0)
    
    # Get tunable parameters for weights
    alpha = 2.0
    beta = 1.0
    
    # Compute the priority as a weighted sum
    priorities = alpha * fit + beta * remaining_ratio
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...
request...-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future packing potential."""
    
    # Calculate remaining capacity if the item is placed in each bin
    remaining_capacity = bins - item
    
    # Avoid negative remaining capacities (though bins should have sufficient capacity)
    remaining_capacity = np.maximum(remaining_capacity, 0)
    
    # Spatial efficiency: how well the item fits into the bin relative to bin capacity
    spatial_efficiency = item / bins
    
    # Future potential: based on remaining capacity and expected future items
    # Using a tunable parameter for expected future item size
    expected_future_item = 0.3  # Example tunable parameter
    
    # Calculate future potential score
    future_potential = remaining_capacity / (expected_future_item + 1e-9)  # Avoid division by zero
    
    # Combine the metrics with tunable weights
    weight_spatial = 0.4
    weight_remaining = 0.2
    weight_future = 0.2
    
    # Normalize each component to prevent one metric from dominating
    spatial_norm = spatial_efficiency / np.max(spatial_efficiency)
    remaining_norm = remaining_capacity / np.max(remaining_capacity)
    future_norm = future_potential / np.max(future_potential)
    
    # Calculate priority as a weighted sum
    priorities = (
        weight_spatial * spatial_norm +
        weight_remaining * remaining_norm +
        weight_future * future_norm
    )
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both immediate fit and future potential."""
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0  # Only consider bins that can fit the item
    
    # Calculate the ratio of item size to remaining capacity
    ratios = np.full_like(bins, np.nan)
    ratios[valid_bins] = item / remaining_capacity[valid_bins]
    
    # Immediate fit score: Penalize very small and very large ratios
    target_ratio = 0.5  # Target ratio for optimal fit
    fit_score = -np.abs(ratios - target_ratio)
    
    # Future potential score: Reward remaining capacity above a certain threshold
    min_remaining = 0.3  # Minimum desired remaining capacity
    future_score = np.zeros_like(bins)
    future_score[valid_bins] = remaining_capacity[valid_bins] - min_remaining
    future_score[future_score < 0] = 0  # No reward for remaining below threshold
    
    # Combine scores with tunable weights
    fit_weight = 0.7  # Weight for immediate fit
    future_weight = 1 - fit_weight
    
    total_score = fit_weight * fit_score + future_weight * future_score
    total_score[~valid_bins] = 0  # Invalid bins have zero priority
    
    # Ensure numerical stability and convert to priority (higher is better)
    priorities = total_score
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------

-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved version of `priority_v0` that considers both current fit and future potential."""
    # Calculate the ratio of item size to remaining bin capacity
    ratios = item / bins
    
    # Calculate fit score using negative log of ratios
    fit_score = -np.log(ratios)
    
    # Calculate future score as the remaining capacity after adding the item
    remaining_after = bins - item
    future_score = remaining_after / bins  # Normalize future score
    
    # Get tunable weights for fit and future scores
    alpha = 0.5  # Weight for fit score
    beta = 0.1   # Weight for future score
    
    # Combine fit and future scores
    priorities = alpha * fit_score + beta * future_score
    
    # Apply a tunable threshold to penalize bins leaving too little space
    threshold = 0.5  # Fraction of bin's capacity to leave
    penalty_mask = remaining_after < threshold * bins
    priorities[penalty_mask] *= 0.5  # Reduce priority for bins below threshold
    
    # Ensure bins that cannot fit the item have zero priority
    priorities[bins < item] = 0
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Improved priority function considering spatial fit and future packing potential."""
    rem = bins - item
    
    # Tunable parameters
    threshold_multiplier = 1.5
    threshold = threshold_multiplier * item
    below_threshold = rem < threshold
    
    # Calculate spatial fit and remaining capacity ratio
    spatial_fit = item / bins
    rem_ratio = rem / bins
    
    # Combine with tunable weights
    alpha = 0.5  # Weight for spatial fit
    beta = 0.1   # Weight for remaining capacity
    priority = alpha * spatial_fit + beta * rem_ratio
    
    # Penalize bins where remaining capacity is below threshold
    priority[below_threshold] = -np.inf
    
    return priority


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------


-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin.
    
    The priority strategy balances:
    1. Spatial Fit: How well the item fits into the bin
    2. Future Potential: How much capacity remains for future items
    3. Utilization Bonus: Preference for bins that are well-utilized
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    
    # Filter out bins that cannot accommodate the item
    valid_bins = remaining > 0
    
    # Spatial fit metric: How well the item fits into the bin
    # Higher ratio means better fit, but leaves less room for future items
    spatial_fit = (item / (bins + 1e-4))  # Add small epsilon to prevent division by zero
    
    # Future potential metric: How much capacity remains after placing the item
    # We prefer bins that leave enough room for future items
    future_potential = (remaining / bins) * 0.9
    
    # Utilization bonus: Preference for bins that are well-utilized
    # This helps prevent "wasteful" bins that are neither full nor empty
    utilization_bonus = np.minimum((bins - remaining) / bins, 0.98)
    
    # Combine metrics with tunable weights
    # Lower priority score means higher priority
    priorities = (
        (spatial_fit * 0.8) + 
        ((1 - future_potential) * 0.2) + 
        (utilization_bonus * 0.2)
    )
    
    # Penalize bins with very small remaining capacity to avoid fragmentation
    small_remaining_penalty = 0.0
    priorities += np.where(remaining < 0.1 * bins, small_remaining_penalty, 0)
    
    # Ensure valid bins have priority over invalid ones
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------request...

-------------------
    """Advanced priority function for online bin-packing using the AFFB strategy.
    
    This version implements the "Adaptive Fit and Future Balance" (AFFB) strategy that:
    1. Combines spatial fit with future packing potential dynamically
    2. Uses adaptive weights based on bin utilization patterns and item size
    3. Implements a diversity bonus to encourage balanced bin usage
    4. Includes tunable parameters for easy optimization
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial_base = tunable([0.5, 0.6, 0.7])  # Base weight for spatial fit component
    weight_future_base = tunable([0.3, 0.4, 0.5])   # Base weight for future potential component
    weight_util_base = tunable([0.2, 0.3, 0.4])     # Base weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins]) if np.any(valid_bins) else 0
    optimal_remaining = tunable([0.1, 0.2, 0.3]) * bins
    
    # Calculate item size relative to average bin capacity
    avg_bin_capacity = np.mean(bins)
    item_size_ratio = item / avg_bin_capacity
    
    # Adaptive weight adjustment based on item size
    weight_spatial = weight_spatial_base * (1 - tunable([0.1, 0.2]) * item_size_ratio)
    weight_future = weight_future_base * (1 + tunable([0.1, 0.2]) * item_size_ratio)
    weight_util = weight_util_base
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * tunable([0.1, 0.2])))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], tunable([0.8, 0.9]))
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > tunable([0.6, 0.7]):
                total_score *= 1 + tunable([0.1, 0.2])
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.1, 0.2]) * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities

call llm times: 20
-------------------


-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future potential."""
    n_bins = len(bins)
    priorities = np.zeros(n_bins)
    
    # Calculate remaining capacities
    remaining = bins - item
    
    # Identify bins that can fit the item
    valid_bins = remaining >= 0
    
    # Tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.5   # Weight for future potential component
    optimal_remaining = 0.3 * bins  # Optimal remaining capacity for future items
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Calculate spatial fit score
            # Prefer bins that have some remaining space but not too much
            r = remaining[i]
            max_capacity = bins[i]
            
            # Normalize remaining space to [0,1]
            normalized_r = r / max_capacity
            
            # Spatial fit score: favors medium remaining space, penalizes too little or too much
            spatial_score = -np.abs(normalized_r - 0.5)
            
            # Calculate future potential score
            # How well does the remaining space match the expected future items?
            future_score = np.exp(-np.abs(r - optimal_remaining[i]) / (max_capacity * 0.2))
            
            # Combine scores with tunable weights
            total_score = weight_spatial * spatial_score + weight_future * future_score
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

launch 64 evaluate tasks
current thread_i 1
this best socre: -212.55; best score: -212.55; global score: -210.95; space size: 10368; measure cnt: 64
...
launch 64 evaluate tasks
current thread_i 4
this best socre: -212.4; best score: -212.4; global score: -210.95; space size: 10368; measure cnt: 128
..
launch 64 evaluate tasks
this best socre: -212.4; best score: -212.4; global score: -210.95; space size: 10368; measure cnt: 192
..
launch 64 evaluate tasks
current thread_i 5
current thread_i 9
current thread_i 8
this best socre: -212.4; best score: -212.4; global score: -210.95; space size: 10368; measure cnt: 256
..
launch 64 evaluate tasks
current thread_i 2
this best socre: -212.4; best score: -212.4; global score: -210.95; space size: 10368; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority function for online bin-packing with dynamic adaptive strategy.
    
    This version implements a "Dynamic Adaptive Bin Selection" strategy that:
    1. Combines spatial fit with future packing potential
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements congestion penalties and diversity bonuses
    4. Includes dynamic adjustment of parameters based on global bin state
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = tunable([0.5, 0.6, 0.7])  # Weight for spatial fit component
    weight_future = tunable([0.3, 0.4, 0.5])   # Weight for future potential component
    weight_util = tunable([0.2, 0.3, 0.4])     # Weight for utilization bonus
    weight_congestion = tunable([0.1, 0.2, 0.3])  # Weight for congestion penalty
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins]) if np.any(valid_bins) else 0
    optimal_remaining = tunable([0.1, 0.2, 0.3]) * bins
    
    # Calculate global metrics
    global_usage = np.mean(bins - remaining) / np.mean(bins)
    congestion_threshold = tunable([0.1, 0.15, 0.2]) * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * tunable([0.1, 0.2, 0.3])))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], tunable([0.9, 0.95, 1.0]))
            
            # Congestion penalty: Penalize bins nearing capacity
            congestion_penalty = 0.0
            if remaining[i] < congestion_threshold[i]:
                congestion_penalty = tunable([0.1, 0.2, 0.3]) * (1 - remaining[i] / bins[i])
            
            # Adaptive weights based on global state
            if global_usage > tunable([0.7, 0.8]):
                weight_spatial = tunable([0.6, 0.7])
                weight_future = tunable([0.2, 0.3])
            else:
                weight_spatial = tunable([0.5, 0.6])
                weight_future = tunable([0.4, 0.5])
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus -
                weight_congestion * congestion_penalty
            )
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.1, 0.15, 0.2]) * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities

call llm times: 21
-------------------



launch 64 evaluate tasks
this best socre: -212.45; best score: -212.45; global score: -210.95; space size: 1889568; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.4; best score: -212.4; global score: -210.95; space size: 1889568; measure cnt: 128

launch 64 evaluate tasks
current thread_i 0
this best socre: -212.4; best score: -212.4; global score: -210.95; space size: 1889568; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.4; best score: -212.4; global score: -210.95; space size: 1889568; measure cnt: 256

launch 64 evaluate tasks
this best socre: -212.4; best score: -212.4; global score: -210.95; space size: 1889568; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority function for online bin-packing with novel strategies.
    
    This version implements a "Dynamic Bin Ecosystem" strategy that:
    1. Combines spatial fit with future packing potential
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to encourage balanced bin usage
    4. Introduces a novel Bin Ecosystem Health metric to maintain optimal bin distribution
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = tunable([0.5, 0.6, 0.7])  # Weight for spatial fit component
    weight_future = tunable([0.3, 0.4, 0.5])   # Weight for future potential component
    weight_util = tunable([0.2, 0.3, 0.4])     # Weight for utilization bonus
    weight_diversity = tunable([0.1, 0.15, 0.2])  # Weight for diversity bonus
    optimal_remaining_pct = tunable([0.15, 0.2, 0.25])  # Optimal remaining percentage
    diversity_bonus_factor = tunable([0.1, 0.15, 0.2])  # Diversity bonus factor
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = bins * optimal_remaining_pct
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * tunable([0.1, 0.15, 0.2])))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], tunable([0.9, 0.95, 1.0]))
            
            # Bin ecosystem health: How adding this item affects overall bin distribution
            current_usage = (bins[i] - remaining[i]) / bins[i]
            usage_variance = np.var((bins - remaining) / bins)
            ecosystem_health = np.exp(-usage_variance / tunable([0.05, 0.1, 0.15]))
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus +
                weight_diversity * ecosystem_health
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > tunable([0.7, 0.75, 0.8]):
                total_score *= tunable([1.1, 1.2, 1.3])
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities

call llm times: 22
-------------------



launch 64 evaluate tasks
current thread_i 7
current thread_i 6
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 177147; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 177147; measure cnt: 128

launch 64 evaluate tasks
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 177147; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 177147; measure cnt: 256
sampler suggest should end sample, break
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin.
    
    The priority strategy balances:
    1. Spatial Fit: How well the item fits into the bin
    2. Future Potential: How much capacity remains for future items
    3. Utilization Bonus: Preference for bins that are well-utilized
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities
    remaining = bins - item
    
    # Filter out bins that cannot accommodate the item
    valid_bins = remaining > 0
    
    # Spatial fit metric: How well the item fits into the bin
    # Higher ratio means better fit, but leaves less room for future items
    spatial_fit = (item / (bins + 1e-4))  # Add small epsilon to prevent division by zero
    
    # Future potential metric: How much capacity remains after placing the item
    # We prefer bins that leave enough room for future items
    future_potential = (remaining / bins) * 0.9
    
    # Utilization bonus: Preference for bins that are well-utilized
    # This helps prevent "wasteful" bins that are neither full nor empty
    utilization_bonus = np.minimum((bins - remaining) / bins, 0.98)
    
    # Combine metrics with tunable weights
    # Lower priority score means higher priority
    priorities = (
        (spatial_fit * 0.8) + 
        ((1 - future_potential) * 0.2) + 
        (utilization_bonus * 0.2)
    )
    
    # Penalize bins with very small remaining capacity to avoid fragmentation
    small_remaining_penalty = 0.0
    priorities += np.where(remaining < 0.1 * bins, small_remaining_penalty, 0)
    
    # Ensure valid bins have priority over invalid ones
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------request...

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with dynamic adaptive strategy.
    
    This version implements a "Dynamic Adaptive Bin Selection" strategy that:
    1. Combines spatial fit with future packing potential
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements congestion penalties and diversity bonuses
    4. Includes dynamic adjustment of parameters based on global bin state
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    weight_congestion = 0.1  # Weight for congestion penalty
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins]) if np.any(valid_bins) else 0
    optimal_remaining = 0.1 * bins
    
    # Calculate global metrics
    global_usage = np.mean(bins - remaining) / np.mean(bins)
    congestion_threshold = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.3))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 1.0)
            
            # Congestion penalty: Penalize bins nearing capacity
            congestion_penalty = 0.0
            if remaining[i] < congestion_threshold[i]:
                congestion_penalty = 0.2 * (1 - remaining[i] / bins[i])
            
            # Adaptive weights based on global state
            if global_usage > 0.7:
                weight_spatial = 0.6
                weight_future = 0.3
            else:
                weight_spatial = 0.5
                weight_future = 0.4
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus -
                weight_congestion * congestion_penalty
            )
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

-----------------------request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
request...
-----------------------

-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both immediate fit and future potential."""
    remaining_capacity = bins - item
    valid_bins = remaining_capacity > 0  # Only consider bins that can fit the item
    
    # Calculate the ratio of item size to remaining capacity
    ratios = np.full_like(bins, np.nan)
    ratios[valid_bins] = item / remaining_capacity[valid_bins]
    
    # Immediate fit score: Penalize very small and very large ratios
    target_ratio = 0.5  # Target ratio for optimal fit
    fit_score = -np.abs(ratios - target_ratio)
    
    # Future potential score: Reward remaining capacity above a certain threshold
    min_remaining = 0.3  # Minimum desired remaining capacity
    future_score = np.zeros_like(bins)
    future_score[valid_bins] = remaining_capacity[valid_bins] - min_remaining
    future_score[future_score < 0] = 0  # No reward for remaining below threshold
    
    # Combine scores with tunable weights
    fit_weight = 0.7  # Weight for immediate fit
    future_weight = 1 - fit_weight
    
    total_score = fit_weight * fit_score + future_weight * future_score
    total_score[~valid_bins] = 0  # Invalid bins have zero priority
    
    # Ensure numerical stability and convert to priority (higher is better)
    priorities = total_score
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
request...-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------
import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing.
    
    This function calculates the priority score for placing an item into each bin,
    considering both spatial fit and future packing potential. It uses tunable
    parameters to allow for dynamic adjustments.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Spatial fit metric: item / bin, scaled by tunable weight
    spatial_fit_weight = 0.7
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    
    # Future potential metric: remaining / bin, scaled by tunable weight
    future_potential_weight = 0.3
    future_potential = (remaining / bins) * future_potential_weight
    
    # Utilization bonus: preference for bins near ideal utilization
    ideal_utilization = 0.8
    utilization_bonus_weight = 0.2
    used = bins - remaining
    utilization = used / bins
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))
    
    # Fragmentation penalty: penalize very small remaining capacities
    fragmentation_threshold = 0.3
    fragmentation_penalty_weight = 0.1
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold * bins,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )
    
    # Combine metrics into priority score
    priorities = spatial_fit + (1 - future_potential) + utilization_bonus + fragmentation_penalty
    
    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.



import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    ratios = item / bins
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategies.
    
    This version implements a "Dynamic Bin Ecosystem" strategy that:
    1. Combines spatial fit with future packing potential
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to encourage balanced bin usage
    4. Introduces a novel Bin Ecosystem Health metric to maintain optimal bin distribution
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.5  # Weight for spatial fit component
    weight_future = 0.5   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    weight_diversity = 0.1  # Weight for diversity bonus
    optimal_remaining_pct = 0.15  # Optimal remaining percentage
    diversity_bonus_factor = 0.2  # Diversity bonus factor
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = bins * optimal_remaining_pct
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.15))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Bin ecosystem health: How adding this item affects overall bin distribution
            current_usage = (bins[i] - remaining[i]) / bins[i]
            usage_variance = np.var((bins - remaining) / bins)
            ecosystem_health = np.exp(-usage_variance / 0.1)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus +
                weight_diversity * ecosystem_health
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.75:
                total_score *= 1.1
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...-------------------
    """Advanced priority function for online bin-packing with dynamic strategy.
    
    This version implements a "Dynamic Adaptive Packing" strategy that:
    1. Combines spatial fit with future potential using adaptive weights
    2. Incorporates a utilization bonus and diversity score
    3. Uses dynamic adjustment based on global bin state
    4. Exposes tunable parameters for optimization
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Calculate global metrics
    avg_remaining = np.mean(remaining[valid_bins])
    avg_utilization = np.mean((bins - remaining) / bins)
    
    # Get tunable parameters
    weight_spatial = tunable([0.5, 0.6, 0.7])  # Weight for spatial fit component
    weight_future = tunable([0.3, 0.4, 0.5])   # Weight for future potential component
    weight_util = tunable([0.2, 0.3, 0.4])     # Weight for utilization bonus
    weight_diversity = tunable([0.1, 0.15, 0.2])  # Weight for diversity bonus
    
    # Adaptive weight adjustment based on average utilization
    if avg_utilization < tunable([0.4, 0.5]):
        weight_spatial = tunable([0.7, 0.8])
        weight_future = tunable([0.2, 0.3])
    elif avg_utilization > tunable([0.7, 0.8]):
        weight_spatial = tunable([0.3, 0.4])
        weight_future = tunable([0.6, 0.7])
    
    # Calculate optimal remaining capacity based on current distribution
    optimal_remaining = tunable([0.2, 0.25, 0.3]) * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = item / bins[i]
            
            # Future potential metric
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * tunable([0.1, 0.15])))
            
            # Utilization bonus
            utilization = (bins[i] - remaining[i]) / bins[i]
            utilization_bonus = np.minimum(utilization / tunable([0.8, 0.9]), 1.0)
            
            # Diversity score: prefer bins with remaining capacity closer to the average
            diversity_score = np.exp(-np.abs(remaining[i] - avg_remaining) / (bins[i] * tunable([0.2, 0.25])))
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus +
                weight_diversity * diversity_score
            )
            
            # Apply dynamic adjustment based on global bin state
            if avg_utilization > tunable([0.6, 0.7]):
                total_score *= tunable([1.1, 1.2])
            elif avg_utilization < tunable([0.4, 0.5]):
                total_score *= tunable([0.9, 0.8])
            
            priorities[i] = total_score
        else:
            priorities[i] = -np.inf
    
    # Apply global diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.1, 0.15, 0.2]) * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities

call llm times: 23
-------------------



-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.1))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.7:
                total_score *= 1.2
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.8
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

launch 64 evaluate tasks
this best socre: -211.95; best score: -211.95; global score: -210.95; space size: 5971968; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.95; best score: -211.95; global score: -210.95; space size: 5971968; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.95; best score: -211.95; global score: -210.95; space size: 5971968; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.95; best score: -211.95; global score: -210.95; space size: 5971968; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority function for online bin-packing with dynamic strategy.
    
    This version implements a "Dynamic Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus and bin pressure mechanism
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array and tracking variables
    priorities = np.zeros_like(bins, dtype=np.float64)
    n_bins = len(bins)
    
    # Tunable parameters
    weight_spatial = tunable([0.4, 0.5, 0.6])  # Weight for spatial fit component
    weight_future = tunable([0.3, 0.4, 0.5])   # Weight for future potential component
    weight_util = tunable([0.2, 0.3, 0.4])     # Weight for utilization bonus
    weight_pressure = tunable([0.1, 0.15, 0.2]) # Weight for bin pressure penalty
    
    # Dynamic parameters based on current state
    avg_item_size = tunable([np.mean(bins - remaining), 0.8])  # Estimate of average item size
    pressure_decay = tunable([0.95, 0.97, 0.99])              # Decay rate for bin pressure
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = item / (remaining[i] + item)  # Reward bins where item takes a significant portion
            
            # Future potential metric
            future_space = remaining[i] - item
            future_potential = future_space / (avg_item_size + 1e-9)  # Avoid division by zero
            future_potential = np.exp(-np.abs(future_potential - 1.0))  # Penalize deviations from fitting one future item
            
            # Utilization bonus
            utilization = (bins[i] - remaining[i]) / bins[i]
            utilization_bonus = np.minimum(utilization, 0.95)  # Cap utilization bonus
            
            # Bin pressure penalty (assuming bin_pressures is a global tracking array)
            bin_pressures = np.load('bin_pressures.npy') if 'bin_pressures.npy' else np.zeros(n_bins)
            pressure_penalty = np.exp(-bin_pressures[i] * 0.1)  # Penalize frequently used bins
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus -
                weight_pressure * pressure_penalty
            )
            
            priorities[i] = total_score
        else:
            priorities[i] = -np.inf
    
    # Apply diversity bonus
    diversity_bonus = tunable([0.1, 0.15, 0.2]) * np.std(priorities)
    priorities += diversity_bonus
    
    # Update bin pressures (assuming global tracking)
    if 'bin_pressures.npy' in globals():
        bin_pressures = np.load('bin_pressures.npy')
        bin_pressures = bin_pressures * pressure_decay
        np.save('bin_pressures.npy', bin_pressures)
    
    return priorities

call llm times: 24
-------------------


...
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.95; space size: 1458; measure cnt: 64
.....
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.95; space size: 1458; measure cnt: 128
.......
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.95; space size: 1458; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Advanced priority function for online bin-packing with a novel "Dynamic Spatial-Future" strategy.
    
    This version implements:
    1. Dynamic optimal remaining capacity based on item size distribution
    2. Adaptive weights for spatial fit, future potential, and utilization
    3. Enhanced diversity bonus to promote balanced bin usage
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = tunable([0.5, 0.6, 0.7])  # Weight for spatial fit component
    weight_future = tunable([0.3, 0.4, 0.5])   # Weight for future potential component
    weight_util = tunable([0.2, 0.3, 0.4])     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    # The optimal remaining is a fraction of the bin's capacity, with the fraction determined by tunable options
    optimal_remaining_fraction = tunable([0.1, 0.2, 0.3])
    optimal_remaining = optimal_remaining_fraction * bins
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            # Using a more aggressive decay factor for better future capacity management
            decay_factor = tunable([0.1, 0.15, 0.2])
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * decay_factor))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], tunable([0.9, 0.95, 0.98]))
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > tunable([0.6, 0.7, 0.8]):
                total_score *= tunable([1.0, 1.1, 1.2])
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Enhanced diversity bonus to encourage balanced bin usage
    # The bonus is proportional to the standard deviation of priorities, scaled by a tunable factor
    diversity_bonus_scale = tunable([0.1, 0.15, 0.2])
    diversity_bonus = diversity_bonus_scale * np.std(priorities)
    priorities += diversity_bonus
    
    # Optional: Normalize priorities to a 0-1 scale for better interpretability
    # This step is optional and can be tuned based on specific needs
    if np.max(priorities) != np.min(priorities):
        priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities))
    
    return priorities

call llm times: 25
-------------------



launch 64 evaluate tasks
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 19683; measure cnt: 64
.
launch 64 evaluate tasks
current thread_i 1
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 19683; measure cnt: 128

launch 64 evaluate tasks
current thread_i 6
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 19683; measure cnt: 192

launch 64 evaluate tasks
current thread_i 4
current thread_i 5
current thread_i 7
this best socre: -212.35; best score: -212.35; global score: -210.95; space size: 19683; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_weight = tunable([0.1, 0.2, 0.3])
    diversity_bonus_multiplier = tunable([0.05, 0.1, 0.15])
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = tunable([0.2, 0.3, 0.4]) * bins
    average_item_size = tunable([0.4, 0.5, 0.6]) * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 26
-------------------


....
launch 64 evaluate tasks
current thread_i 9
this best socre: -210.7; best score: -210.7; global score: -210.7; space size: 2187; measure cnt: 64
....
launch 64 evaluate tasks
current thread_i 0
this best socre: -210.4; best score: -210.4; global score: -210.4; space size: 2187; measure cnt: 128
.........
launch 64 evaluate tasks
this best socre: -210.4; best score: -210.4; global score: -210.4; space size: 2187; measure cnt: 192
...........
launch 64 evaluate tasks
this best socre: -210.3; best score: -210.3; global score: -210.3; space size: 2187; measure cnt: 256
.........
launch 64 evaluate tasks
this best socre: -210.3; best score: -210.3; global score: -210.3; space size: 2187; measure cnt: 320
....
launch 64 evaluate tasks
this best socre: -210.3; best score: -210.3; global score: -210.3; space size: 2187; measure cnt: 384
..................
launch 64 evaluate tasks
this best socre: -210.3; best score: -210.3; global score: -210.3; space size: 2187; measure cnt: 448
sampler suggest should end sample, break
INFO:absl:Best score increased to -210.3
-------------------
    """Advanced priority function for online bin-packing with novel strategy."""
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0

    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)

    # Get tunable parameters
    weight_spatial = tunable([0.5, 0.6, 0.7])
    weight_future = tunable([0.3, 0.4, 0.5])
    weight_util = tunable([0.2, 0.3, 0.4])
    optimal_factor = tunable([0.1, 0.2, 0.3])
    scaling_factor = tunable([0.1, 0.2, 0.3])
    utilization_cap = tunable([0.8, 0.9, 0.95])
    diversity_bonus_factor = tunable([0.1, 0.2, 0.3])
    global_usage_threshold = tunable([0.7, 0.8])
    global_usage_multiplier = tunable([1.1, 1.2])

    # Calculate dynamic optimal remaining capacity based on current bin distribution
    if np.any(valid_bins):
        avg_remaining = np.mean(remaining[valid_bins])
        optimal_remaining = optimal_factor * avg_remaining
    else:
        optimal_remaining = 0  # No valid bins, shouldn't affect as valid_bins is checked

    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]

            # Future potential metric: How well remaining capacity aligns with optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * scaling_factor))

            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], utilization_cap)

            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )

            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > global_usage_threshold:
                total_score *= global_usage_multiplier

            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus

    return priorities

call llm times: 27
-------------------



launch 64 evaluate tasks
current thread_i 2
this best socre: -210.9; best score: -210.9; global score: -210.3; space size: 8748; measure cnt: 64
..
launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.3; space size: 8748; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.3; space size: 8748; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.3; space size: 8748; measure cnt: 256
.
launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.3; space size: 8748; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel heuristics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = tunable([0.6, 0.7, 0.8])
    future_potential_base_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_base_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_base_weight = tunable([0.1, 0.2, 0.3])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.7, 0.8]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.8])
        future_potential_weight = future_potential_base_weight * tunable([1.3, 1.2])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.2, 1.1])
        future_potential_weight = future_potential_base_weight * tunable([0.8, 0.7])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit score
    max_capacity = bins
    normalized_r = remaining / max_capacity
    optimal_normalized_r = tunable([0.4, 0.5])
    spatial_score = np.exp(-np.abs(normalized_r - optimal_normalized_r) / tunable([0.2, 0.15]))
    spatial_score *= spatial_fit_weight

    # Calculate future potential score with lookahead heuristic
    expected_future_item_size = tunable([0.3, 0.4]) * np.mean(bins)
    optimal_remaining = expected_future_item_size + tunable([0.1, 0.2]) * bins
    future_score = np.exp(-np.abs(remaining - optimal_remaining) / (max_capacity * tunable([0.2, 0.15])))
    future_score *= future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.75, 0.8])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = tunable([0.25, 0.3]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_score + future_score + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 28
-------------------



launch 64 evaluate tasks
this best socre: -216.45; best score: -216.45; global score: -210.3; space size: 995328; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -216.45; best score: -216.45; global score: -210.3; space size: 995328; measure cnt: 128

launch 64 evaluate tasks
this best socre: -216.45; best score: -216.45; global score: -210.3; space size: 995328; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -216.45; best score: -216.45; global score: -210.3; space size: 995328; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters using tunable wrapper
    spatial_fit_base_weight = tunable([0.5, 0.6, 0.7])
    future_potential_base_weight = tunable([0.2, 0.3, 0.4])
    utilization_bonus_base_weight = tunable([0.1, 0.15, 0.2])
    fragmentation_penalty_base_weight = tunable([0.05, 0.1, 0.15])
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.7, 0.8]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.95])
        future_potential_weight = future_potential_base_weight * tunable([1.2, 1.3])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.1, 1.2])
        future_potential_weight = future_potential_base_weight * tunable([0.7, 0.8])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit with improved metric
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = tunable([0.3, 0.4]) * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * tunable([0.15, 0.2]))) 
    future_potential *= future_potential_weight

    # Calculate utilization bonus with improved metric
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.75, 0.8])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with improved metric
    fragmentation_threshold = tunable([0.25, 0.3]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = (
        spatial_fit 
        + future_potential 
        + utilization_bonus 
        + fragmentation_penalty
    )

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.05, 0.1]) * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 29
-------------------



launch 64 evaluate tasks
this best socre: -211.4; best score: -211.4; global score: -210.3; space size: 82944; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.1; best score: -211.1; global score: -210.3; space size: 82944; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.1; best score: -211.1; global score: -210.3; space size: 82944; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.1; best score: -211.1; global score: -210.3; space size: 82944; measure cnt: 256

launch 64 evaluate tasks
this best socre: -211.1; best score: -211.1; global score: -210.3; space size: 82944; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.3, 0.5, 0.7])
    future_potential_weight = tunable([0.2, 0.4, 0.6])
    utilization_weight = tunable([0.1, 0.2, 0.3])
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15])
    optimal_remaining_threshold = tunable([0.2, 0.3, 0.4]) * bins

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential
    future_potential = np.exp(-np.abs(remaining - optimal_remaining_threshold) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    utilization_bonus = utilization_weight * utilization

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < (bins * tunable([0.1, 0.2, 0.25])),
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.05, 0.1, 0.15]) * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 30
-------------------



launch 64 evaluate tasks
current thread_i 8
this best socre: -211.05; best score: -211.05; global score: -210.3; space size: 2187; measure cnt: 64
.....
launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.3; space size: 2187; measure cnt: 128
......
launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -210.3; space size: 2187; measure cnt: 192
..........
launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -210.3; space size: 2187; measure cnt: 256
.....
launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -210.3; space size: 2187; measure cnt: 320
........
launch 64 evaluate tasks
this best socre: -210.8; best score: -210.8; global score: -210.3; space size: 2187; measure cnt: 384
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Calculate basic metrics
    spatial_fit = item / (bins + 1e-4)
    utilization = (bins - remaining) / bins
    fragmentation = remaining / bins
    
    # Dynamic weight adjustment based on system state
    global_utilization = np.mean(utilization)
    if global_utilization > tunable([0.7, 0.8]):
        spatial_weight = tunable([0.4, 0.5, 0.6])
        future_weight = tunable([0.3, 0.4])
    else:
        spatial_weight = tunable([0.6, 0.7])
        future_weight = tunable([0.2, 0.25])
    
    # Calculate future potential with adaptive lookahead
    # Lookahead considers both current and potential future items
    future_potential = np.exp(-np.abs(remaining - tunable([0.3, 0.4, 0.5]) * bins))
    
    # Calculate utilization bonus with ideal utilization zone
    ideal_utilization = tunable([0.6, 0.7, 0.8])
    utilization_bonus = 1 - np.abs(utilization - ideal_utilization)
    
    # Calculate fragmentation penalty with adaptive threshold
    fragmentation_penalty = np.where(
        fragmentation < tunable([0.2, 0.25, 0.3]),
        1 - fragmentation,
        0
    )
    
    # Combine metrics into priority score
    priorities = (
        spatial_weight * spatial_fit +
        future_weight * future_potential +
        tunable([0.1, 0.15]) * utilization_bonus +
        tunable([0.05, 0.1]) * fragmentation_penalty
    )
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.05, 0.1]) * np.std(priorities)
    priorities += diversity_bonus
    
    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')
    
    return priorities

call llm times: 31
-------------------



launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.3; space size: 10368; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.3; space size: 10368; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.3; space size: 10368; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.3; space size: 10368; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and diversity.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = tunable([0.6, 0.7, 0.8])
    future_potential_base_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_base_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_base_weight = tunable([0.1, 0.2, 0.3])
    diversity_bonus_base_weight = tunable([0.05, 0.1, 0.15])
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.8, 0.7]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.85])
        future_potential_weight = future_potential_base_weight * tunable([1.3, 1.2])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.2, 1.1])
        future_potential_weight = future_potential_base_weight * tunable([0.8, 0.75])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    diversity_bonus_weight = diversity_bonus_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = tunable([0.4, 0.35, 0.45]) * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * tunable([0.2, 0.15])))
    future_potential *= future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.8, 0.75])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = tunable([0.4, 0.35]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Calculate diversity bonus based on bin usage diversity
    bin_usage = bins - remaining
    usage_variance = np.var(bin_usage)
    diversity_bonus = diversity_bonus_weight * (1 / (usage_variance + 1e-4))

    # Combine metrics into priority score
    priorities = (
        spatial_fit 
        + future_potential 
        + utilization_bonus 
        + fragmentation_penalty 
        - diversity_bonus  # Subtract to encourage diversity
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 32
-------------------



launch 64 evaluate tasks
this best socre: -211.1; best score: -211.1; global score: -210.3; space size: 186624; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.1; best score: -211.1; global score: -210.3; space size: 186624; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.1; best score: -211.1; global score: -210.3; space size: 186624; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -211.1; best score: -211.1; global score: -210.3; space size: 186624; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and diversity.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = tunable([0.6, 0.7, 0.8])
    future_potential_base_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_base_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_base_weight = tunable([0.1, 0.2, 0.3])
    diversity_bonus_base_weight = tunable([0.05, 0.1, 0.15])
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.7, 0.8]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.95])
        future_potential_weight = future_potential_base_weight * tunable([1.2, 1.3])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.1, 1.2])
        future_potential_weight = future_potential_base_weight * tunable([0.8, 0.9])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    diversity_bonus_weight = diversity_bonus_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = tunable([0.3, 0.4, 0.5]) * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * tunable([0.2, 0.25]))) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.7, 0.8, 0.85])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = tunable([0.3, 0.4, 0.5]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Calculate diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)

    # Combine metrics into priority score
    priorities = (
        spatial_fit +
        future_potential +
        utilization_bonus +
        fragmentation_penalty +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 33
-------------------



launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.3; space size: 419904; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.3; space size: 419904; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.3; space size: 419904; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.3; space size: 419904; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and diversity.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = tunable([0.6, 0.7, 0.8])
    future_potential_base_weight = tunable([0.3, 0.4])
    utilization_bonus_base_weight = tunable([0.2, 0.3])
    fragmentation_penalty_base_weight = tunable([0.1, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1])
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.7, 0.8]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.8])
        future_potential_weight = future_potential_base_weight * tunable([1.3, 1.2])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.2, 1.1])
        future_potential_weight = future_potential_base_weight * tunable([0.8, 0.7])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = tunable([0.4, 0.35, 0.45]) * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * tunable([0.2, 0.25]))) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.8, 0.75, 0.85])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = tunable([0.4, 0.3, 0.5]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = tunable([2, 3])
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            # Simulate placing the item in bin i
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Assume next items are similar in size (simplified lookahead)
            next_item_size = tunable([item * 0.9, item * 1.1])
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            # Reward bins that still have good future potential
            lookahead_bonus[i] = np.sum(future_valid) * tunable([0.1, 0.05])

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty - lookahead_bonus

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 34
-------------------



launch 64 evaluate tasks
this best socre: -211.65; best score: -211.65; global score: -210.3; space size: 663552; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.65; best score: -211.65; global score: -210.3; space size: 663552; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.45; best score: -211.45; global score: -210.3; space size: 663552; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.45; best score: -211.45; global score: -210.3; space size: 663552; measure cnt: 256

launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.3; space size: 663552; measure cnt: 320

launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.3; space size: 663552; measure cnt: 384

launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.3; space size: 663552; measure cnt: 448

launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.3; space size: 663552; measure cnt: 512
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential. It uses tunable parameters for dynamic
    adjustments.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = tunable([0.6, 0.7, 0.8])
    future_potential_base_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_base_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_base_weight = tunable([0.1, 0.2, 0.3])
    lookahead_depth = tunable([3, 5, 7])
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.8, 0.85, 0.9]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.85, 0.8])
        future_potential_weight = future_potential_base_weight * tunable([1.3, 1.2, 1.1])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.2, 1.15, 1.1])
        future_potential_weight = future_potential_base_weight * tunable([0.8, 0.75, 0.7])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = tunable([0.4, 0.35, 0.3]) * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * tunable([0.2, 0.25, 0.3]))) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.8, 0.75, 0.7])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = tunable([0.4, 0.45, 0.5]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: Estimate future packing potential based on next items
    # Assume we have access to the next 'lookahead_depth' items' sizes
    # For demonstration, using random sizes; in practice, this would be actual upcoming items
    next_items = np.random.rand(tunable([3, 5, 7])) * tunable([0.1, 0.2, 0.3]) * bins.mean()
    lookahead_scores = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            current_remaining = remaining[i]
            # Simulate placing the next items
            simulated_remaining = current_remaining
            for size in next_items:
                if simulated_remaining >= size:
                    simulated_remaining -= size
                else:
                    break
            lookahead_scores[i] = simulated_remaining
    lookahead_bonus = tunable([0.1, 0.15, 0.2]) * (lookahead_scores / bins)

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty - lookahead_bonus

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.1, 0.15, 0.2]) * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 35
-------------------



launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.3; space size: 387420489; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.3; space size: 387420489; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.3; space size: 387420489; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.3; space size: 387420489; measure cnt: 256

launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.3; space size: 387420489; measure cnt: 320

launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.3; space size: 387420489; measure cnt: 384
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and diversity.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.8
    future_potential_base_weight = 0.5
    utilization_bonus_base_weight = 0.4
    fragmentation_penalty_base_weight = 0.2
    diversity_bonus_base_weight = 0.05
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.95
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.1
        future_potential_weight = future_potential_base_weight * 0.9
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    diversity_bonus_weight = diversity_bonus_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.3 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Calculate diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)

    # Combine metrics into priority score
    priorities = (
        spatial_fit +
        future_potential +
        utilization_bonus +
        fragmentation_penalty +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = 0.8
    future_potential_weight = 0.3
    utilization_bonus_weight = 0.4
    fragmentation_penalty_weight = 0.1
    diversity_bonus_multiplier = 0.15
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.4 * bins
    average_item_size = 0.6 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and diversity.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.8
    future_potential_base_weight = 0.5
    utilization_bonus_base_weight = 0.4
    fragmentation_penalty_base_weight = 0.2
    diversity_bonus_base_weight = 0.05
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.95
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.1
        future_potential_weight = future_potential_base_weight * 0.9
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    diversity_bonus_weight = diversity_bonus_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.3 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Calculate diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)

    # Combine metrics into priority score
    priorities = (
        spatial_fit +
        future_potential +
        utilization_bonus +
        fragmentation_penalty +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = 0.8
    future_potential_weight = 0.3
    utilization_bonus_weight = 0.4
    fragmentation_penalty_weight = 0.1
    diversity_bonus_multiplier = 0.15
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.4 * bins
    average_item_size = 0.6 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and diversity.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.8
    future_potential_base_weight = 0.5
    utilization_bonus_base_weight = 0.4
    fragmentation_penalty_base_weight = 0.2
    diversity_bonus_base_weight = 0.05
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.95
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.1
        future_potential_weight = future_potential_base_weight * 0.9
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    diversity_bonus_weight = diversity_bonus_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.3 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Calculate diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)

    # Combine metrics into priority score
    priorities = (
        spatial_fit +
        future_potential +
        utilization_bonus +
        fragmentation_penalty +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = 0.8
    future_potential_weight = 0.3
    utilization_bonus_weight = 0.4
    fragmentation_penalty_weight = 0.1
    diversity_bonus_multiplier = 0.15
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.4 * bins
    average_item_size = 0.6 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...request...
-----------------------request...

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.5
    future_potential_weight = 0.2
    utilization_weight = 0.2
    fragmentation_penalty_weight = 0.15
    optimal_remaining_threshold = 0.4 * bins

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential
    future_potential = np.exp(-np.abs(remaining - optimal_remaining_threshold) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    utilization_bonus = utilization_weight * utilization

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < (bins * 0.1),
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.15 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = 0.8
    future_potential_weight = 0.3
    utilization_bonus_weight = 0.4
    fragmentation_penalty_weight = 0.1
    diversity_bonus_multiplier = 0.15
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.4 * bins
    average_item_size = 0.6 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy."""
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0

    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)

    # Get tunable parameters
    weight_spatial = 0.6
    weight_future = 0.5
    weight_util = 0.4
    optimal_factor = 0.3
    scaling_factor = 0.1
    utilization_cap = 0.8
    diversity_bonus_factor = 0.1
    global_usage_threshold = 0.7
    global_usage_multiplier = 1.2

    # Calculate dynamic optimal remaining capacity based on current bin distribution
    if np.any(valid_bins):
        avg_remaining = np.mean(remaining[valid_bins])
        optimal_remaining = optimal_factor * avg_remaining
    else:
        optimal_remaining = 0  # No valid bins, shouldn't affect as valid_bins is checked

    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]

            # Future potential metric: How well remaining capacity aligns with optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * scaling_factor))

            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], utilization_cap)

            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )

            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > global_usage_threshold:
                total_score *= global_usage_multiplier

            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = 0.8
    future_potential_weight = 0.3
    utilization_bonus_weight = 0.4
    fragmentation_penalty_weight = 0.1
    diversity_bonus_multiplier = 0.15
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.4 * bins
    average_item_size = 0.6 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy."""
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0

    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)

    # Get tunable parameters
    weight_spatial = 0.6
    weight_future = 0.5
    weight_util = 0.4
    optimal_factor = 0.3
    scaling_factor = 0.1
    utilization_cap = 0.8
    diversity_bonus_factor = 0.1
    global_usage_threshold = 0.7
    global_usage_multiplier = 1.2

    # Calculate dynamic optimal remaining capacity based on current bin distribution
    if np.any(valid_bins):
        avg_remaining = np.mean(remaining[valid_bins])
        optimal_remaining = optimal_factor * avg_remaining
    else:
        optimal_remaining = 0  # No valid bins, shouldn't affect as valid_bins is checked

    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]

            # Future potential metric: How well remaining capacity aligns with optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * scaling_factor))

            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], utilization_cap)

            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )

            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > global_usage_threshold:
                total_score *= global_usage_multiplier

            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = 0.8
    future_potential_weight = 0.3
    utilization_bonus_weight = 0.4
    fragmentation_penalty_weight = 0.1
    diversity_bonus_multiplier = 0.15
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.4 * bins
    average_item_size = 0.6 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.5
    future_potential_weight = 0.2
    utilization_weight = 0.2
    fragmentation_penalty_weight = 0.15
    optimal_remaining_threshold = 0.4 * bins

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential
    future_potential = np.exp(-np.abs(remaining - optimal_remaining_threshold) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    utilization_bonus = utilization_weight * utilization

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < (bins * 0.1),
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.15 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = 0.8
    future_potential_weight = 0.3
    utilization_bonus_weight = 0.4
    fragmentation_penalty_weight = 0.1
    diversity_bonus_multiplier = 0.15
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.4 * bins
    average_item_size = 0.6 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------
request...
request...-------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy."""
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0

    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)

    # Get tunable parameters
    weight_spatial = 0.6
    weight_future = 0.5
    weight_util = 0.4
    optimal_factor = 0.3
    scaling_factor = 0.1
    utilization_cap = 0.8
    diversity_bonus_factor = 0.1
    global_usage_threshold = 0.7
    global_usage_multiplier = 1.2

    # Calculate dynamic optimal remaining capacity based on current bin distribution
    if np.any(valid_bins):
        avg_remaining = np.mean(remaining[valid_bins])
        optimal_remaining = optimal_factor * avg_remaining
    else:
        optimal_remaining = 0  # No valid bins, shouldn't affect as valid_bins is checked

    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]

            # Future potential metric: How well remaining capacity aligns with optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * scaling_factor))

            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], utilization_cap)

            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )

            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > global_usage_threshold:
                total_score *= global_usage_multiplier

            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = 0.8
    future_potential_weight = 0.3
    utilization_bonus_weight = 0.4
    fragmentation_penalty_weight = 0.1
    diversity_bonus_multiplier = 0.15
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.4 * bins
    average_item_size = 0.6 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.3, 0.4, 0.5])
    utilization_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_weight = tunable([0.1, 0.2, 0.3])
    
    target_ratio = tunable([0.4, 0.5, 0.6])
    target_remaining = tunable([0.3, 0.4, 0.5]) * bins
    ideal_utilization = tunable([0.7, 0.8, 0.9])
    fragmentation_threshold = tunable([0.2, 0.3, 0.4]) * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * tunable([0.9, 1.0, 1.1]) for _ in range(5)]  # Simulate next 5 items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * tunable([0.1, 0.2, 0.3])

    # Combine all scores into total priority
    priorities = spatial_fit_score + future_potential_score + utilization_score + fragmentation_penalty + lookahead_score
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    return priorities

call llm times: 36
-------------------




import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.5
    future_potential_weight = 0.2
    utilization_weight = 0.2
    fragmentation_penalty_weight = 0.15
    optimal_remaining_threshold = 0.4 * bins

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential
    future_potential = np.exp(-np.abs(remaining - optimal_remaining_threshold) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    utilization_bonus = utilization_weight * utilization

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < (bins * 0.1),
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.15 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = 0.8
    future_potential_weight = 0.3
    utilization_bonus_weight = 0.4
    fragmentation_penalty_weight = 0.1
    diversity_bonus_multiplier = 0.15
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.4 * bins
    average_item_size = 0.6 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

launch 64 evaluate tasks
current thread_i 5
current thread_i 8
current thread_i 0
current thread_i 9
current thread_i 4
current thread_i 2
this best socre: -210.6; best score: -210.6; global score: -210.3; space size: 59049; measure cnt: 64
.
launch 64 evaluate tasks
current thread_i 7
current thread_i 6
current thread_i 1
this best socre: -210.6; best score: -210.6; global score: -210.3; space size: 59049; measure cnt: 128
...
launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -210.3; space size: 59049; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -210.2; space size: 59049; measure cnt: 256
..
launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -210.2; space size: 59049; measure cnt: 320
.
launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -210.2; space size: 59049; measure cnt: 384

launch 64 evaluate tasks
this best socre: -210.2; best score: -210.2; global score: -210.2; space size: 59049; measure cnt: 448
sampler suggest should end sample, break
INFO:absl:Best score increased to -210.2
-------------------
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements an "Adaptive Lookahead" strategy that:
    1. Combines spatial fit with future packing potential using dynamic weights
    2. Incorporates item size categorization for adaptive bin matching
    3. Implements dynamic threshold adjustments based on bin state
    4. Uses a diversity bonus to encourage balanced bin usage
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    
    # Initialize priority array
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Get tunable parameters
    spatial_fit_base_weight = tunable([0.5, 0.6, 0.7])
    future_potential_base_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_base_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_base_weight = tunable([0.1, 0.2, 0.3])
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.7, 0.8]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.95])
        future_potential_weight = future_potential_base_weight * tunable([1.1, 1.2])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.1, 1.2])
        future_potential_weight = future_potential_base_weight * tunable([0.9, 0.95])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    
    # Item categorization for adaptive bin matching
    item_category = 'small' if item < tunable([0.2, 0.3]) * np.max(bins) else \
                   'medium' if item < tunable([0.5, 0.6]) * np.max(bins) else 'large'
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = item / bins[i]
            
            # Future potential metric with adaptive lookahead
            optimal_remaining = tunable([0.3, 0.4, 0.5]) * bins[i]
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * tunable([0.1, 0.2])))
            
            # Utilization bonus
            utilization = (bins[i] - remaining[i]) / bins[i]
            ideal_utilization = tunable([0.7, 0.8])
            utilization_bonus = 1 - np.abs(utilization - ideal_utilization)
            
            # Fragmentation penalty
            fragmentation_threshold = tunable([0.2, 0.3]) * bins[i]
            fragmentation_penalty = 0
            if remaining[i] < fragmentation_threshold:
                fragmentation_penalty = 1 - (remaining[i] / bins[i])
            
            # Apply item category-specific weights
            if item_category == 'small':
                spatial_fit *= tunable([1.2, 1.3])
                future_potential *= tunable([0.8, 0.9])
            elif item_category == 'large':
                spatial_fit *= tunable([0.8, 0.9])
                future_potential *= tunable([1.2, 1.3])
            
            # Combine metrics with adaptive weights
            total_score = (
                spatial_fit_weight * spatial_fit +
                future_potential_weight * future_potential +
                utilization_bonus_weight * utilization_bonus -
                fragmentation_penalty_weight * fragmentation_penalty
            )
            
            priorities[i] = total_score
        else:
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.1, 0.2]) * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities

call llm times: 37
-------------------



launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.2; space size: 7962624; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.2; space size: 7962624; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.2; space size: 7962624; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.2; space size: 7962624; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and
    reinforcement learning-based adjustments. It uses tunable parameters for dynamic
    optimizations and includes a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = tunable([0.5, 0.6, 0.7])
    future_potential_base_weight = tunable([0.3, 0.4])
    utilization_bonus_base_weight = tunable([0.2, 0.3])
    fragmentation_penalty_base_weight = tunable([0.1, 0.2])
    reinforcement_learning_weight = tunable([0.1, 0.15])
    lookahead_depth = tunable([3, 5, 7])
    diversity_bonus_factor = tunable([0.05, 0.1])

    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.7, 0.8]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.8])
        future_potential_weight = future_potential_base_weight * tunable([1.3, 1.2])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.2, 1.1])
        future_potential_weight = future_potential_base_weight * tunable([0.8, 0.7])

    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit with dynamic adjustment
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    spatial_fit = np.where(spatial_fit > tunable([0.9, 1.0]), 
                          spatial_fit * tunable([0.8, 0.9]),
                          spatial_fit)

    # Calculate future potential with lookahead heuristic
    optimal_remaining = tunable([0.3, 0.4, 0.5]) * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * tunable([0.15, 0.2])))
    future_potential = future_potential * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.75, 0.8])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))
    
    # Calculate fragmentation penalty
    fragmentation_threshold = tunable([0.25, 0.3]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Reinforcement learning component
    # (This would typically be updated based on past performance)
    rl_adjustment = np.random.normal(0, 0.1, n_bins) * reinforcement_learning_weight

    # Combine metrics into priority score
    priorities = (spatial_fit + 
                 future_potential + 
                 utilization_bonus + 
                 fragmentation_penalty + 
                 rl_adjustment)

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 38
-------------------



launch 64 evaluate tasks
this best socre: -211.25; best score: -211.25; global score: -210.2; space size: 884736; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.2; best score: -211.2; global score: -210.2; space size: 884736; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.1; best score: -211.1; global score: -210.2; space size: 884736; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -210.2; space size: 884736; measure cnt: 256

launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -210.2; space size: 884736; measure cnt: 320

launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -210.2; space size: 884736; measure cnt: 384

launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -210.2; space size: 884736; measure cnt: 448
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements an "Adaptive Lookahead" strategy that:
    1. Combines spatial fit with future packing potential using dynamic weights
    2. Incorporates item size categorization for adaptive bin matching
    3. Implements dynamic threshold adjustments based on bin state
    4. Uses a diversity bonus to encourage balanced bin usage
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    
    # Initialize priority array
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Get tunable parameters
    spatial_fit_base_weight = 0.5
    future_potential_base_weight = 0.4
    utilization_bonus_base_weight = 0.3
    fragmentation_penalty_base_weight = 0.3
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.95
        future_potential_weight = future_potential_base_weight * 1.1
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.1
        future_potential_weight = future_potential_base_weight * 0.9
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    
    # Item categorization for adaptive bin matching
    item_category = 'small' if item < 0.3 * np.max(bins) else\
                   'medium' if item < 0.5 * np.max(bins) else 'large'
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = item / bins[i]
            
            # Future potential metric with adaptive lookahead
            optimal_remaining = 0.5 * bins[i]
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * 0.2))
            
            # Utilization bonus
            utilization = (bins[i] - remaining[i]) / bins[i]
            ideal_utilization = 0.8
            utilization_bonus = 1 - np.abs(utilization - ideal_utilization)
            
            # Fragmentation penalty
            fragmentation_threshold = 0.3 * bins[i]
            fragmentation_penalty = 0
            if remaining[i] < fragmentation_threshold:
                fragmentation_penalty = 1 - (remaining[i] / bins[i])
            
            # Apply item category-specific weights
            if item_category == 'small':
                spatial_fit *= 1.3
                future_potential *= 0.8
            elif item_category == 'large':
                spatial_fit *= 0.8
                future_potential *= 1.3
            
            # Combine metrics with adaptive weights
            total_score = (
                spatial_fit_weight * spatial_fit +
                future_potential_weight * future_potential +
                utilization_bonus_weight * utilization_bonus -
                fragmentation_penalty_weight * fragmentation_penalty
            )
            
            priorities[i] = total_score
        else:
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_weight = 0.6
    future_potential_weight = 0.5
    utilization_weight = 0.4
    fragmentation_penalty_weight = 0.1
    
    target_ratio = 0.4
    target_remaining = 0.5 * bins
    ideal_utilization = 0.9
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * 0.9 for _ in range(5)]  # Simulate next 5 items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * 0.2

    # Combine all scores into total priority
    priorities = spatial_fit_score + future_potential_score + utilization_score + fragmentation_penalty + lookahead_score
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...request...

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements an "Adaptive Lookahead" strategy that:
    1. Combines spatial fit with future packing potential using dynamic weights
    2. Incorporates item size categorization for adaptive bin matching
    3. Implements dynamic threshold adjustments based on bin state
    4. Uses a diversity bonus to encourage balanced bin usage
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    
    # Initialize priority array
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Get tunable parameters
    spatial_fit_base_weight = 0.5
    future_potential_base_weight = 0.4
    utilization_bonus_base_weight = 0.3
    fragmentation_penalty_base_weight = 0.3
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.95
        future_potential_weight = future_potential_base_weight * 1.1
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.1
        future_potential_weight = future_potential_base_weight * 0.9
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    
    # Item categorization for adaptive bin matching
    item_category = 'small' if item < 0.3 * np.max(bins) else\
                   'medium' if item < 0.5 * np.max(bins) else 'large'
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = item / bins[i]
            
            # Future potential metric with adaptive lookahead
            optimal_remaining = 0.5 * bins[i]
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * 0.2))
            
            # Utilization bonus
            utilization = (bins[i] - remaining[i]) / bins[i]
            ideal_utilization = 0.8
            utilization_bonus = 1 - np.abs(utilization - ideal_utilization)
            
            # Fragmentation penalty
            fragmentation_threshold = 0.3 * bins[i]
            fragmentation_penalty = 0
            if remaining[i] < fragmentation_threshold:
                fragmentation_penalty = 1 - (remaining[i] / bins[i])
            
            # Apply item category-specific weights
            if item_category == 'small':
                spatial_fit *= 1.3
                future_potential *= 0.8
            elif item_category == 'large':
                spatial_fit *= 0.8
                future_potential *= 1.3
            
            # Combine metrics with adaptive weights
            total_score = (
                spatial_fit_weight * spatial_fit +
                future_potential_weight * future_potential +
                utilization_bonus_weight * utilization_bonus -
                fragmentation_penalty_weight * fragmentation_penalty
            )
            
            priorities[i] = total_score
        else:
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_weight = 0.6
    future_potential_weight = 0.5
    utilization_weight = 0.4
    fragmentation_penalty_weight = 0.1
    
    target_ratio = 0.4
    target_remaining = 0.5 * bins
    ideal_utilization = 0.9
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * 0.9 for _ in range(5)]  # Simulate next 5 items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * 0.2

    # Combine all scores into total priority
    priorities = spatial_fit_score + future_potential_score + utilization_score + fragmentation_penalty + lookahead_score
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters using tunable wrapper
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.2
    utilization_bonus_base_weight = 0.15
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.2
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.7
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit with improved metric
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) 
    future_potential *= future_potential_weight

    # Calculate utilization bonus with improved metric
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.75
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with improved metric
    fragmentation_threshold = 0.25 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = (
        spatial_fit 
        + future_potential 
        + utilization_bonus 
        + fragmentation_penalty
    )

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_weight = 0.6
    future_potential_weight = 0.5
    utilization_weight = 0.4
    fragmentation_penalty_weight = 0.1
    
    target_ratio = 0.4
    target_remaining = 0.5 * bins
    ideal_utilization = 0.9
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * 0.9 for _ in range(5)]  # Simulate next 5 items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * 0.2

    # Combine all scores into total priority
    priorities = spatial_fit_score + future_potential_score + utilization_score + fragmentation_penalty + lookahead_score
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
request...-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters using tunable wrapper
    spatial_fit_base_weight = 0.6
    future_potential_base_weight = 0.2
    utilization_bonus_base_weight = 0.15
    fragmentation_penalty_base_weight = 0.1
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.2
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.7
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit with improved metric
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.4 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) 
    future_potential *= future_potential_weight

    # Calculate utilization bonus with improved metric
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.75
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with improved metric
    fragmentation_threshold = 0.25 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = (
        spatial_fit 
        + future_potential 
        + utilization_bonus 
        + fragmentation_penalty
    )

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_weight = 0.6
    future_potential_weight = 0.5
    utilization_weight = 0.4
    fragmentation_penalty_weight = 0.1
    
    target_ratio = 0.4
    target_remaining = 0.5 * bins
    ideal_utilization = 0.9
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * 0.9 for _ in range(5)]  # Simulate next 5 items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * 0.2

    # Combine all scores into total priority
    priorities = spatial_fit_score + future_potential_score + utilization_score + fragmentation_penalty + lookahead_score
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and
    reinforcement learning-based adjustments. It uses tunable parameters for dynamic
    optimizations and includes a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.5
    future_potential_base_weight = 0.4
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    reinforcement_learning_weight = 0.15
    lookahead_depth = 3
    diversity_bonus_factor = 0.1

    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.8
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.7

    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit with dynamic adjustment
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    spatial_fit = np.where(spatial_fit > 0.9, 
                          spatial_fit * 0.8,
                          spatial_fit)

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2))
    future_potential = future_potential * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.75
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))
    
    # Calculate fragmentation penalty
    fragmentation_threshold = 0.25 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Reinforcement learning component
    # (This would typically be updated based on past performance)
    rl_adjustment = np.random.normal(0, 0.1, n_bins) * reinforcement_learning_weight

    # Combine metrics into priority score
    priorities = (spatial_fit + 
                 future_potential + 
                 utilization_bonus + 
                 fragmentation_penalty + 
                 rl_adjustment)

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_weight = 0.6
    future_potential_weight = 0.5
    utilization_weight = 0.4
    fragmentation_penalty_weight = 0.1
    
    target_ratio = 0.4
    target_remaining = 0.5 * bins
    ideal_utilization = 0.9
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * 0.9 for _ in range(5)]  # Simulate next 5 items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * 0.2

    # Combine all scores into total priority
    priorities = spatial_fit_score + future_potential_score + utilization_score + fragmentation_penalty + lookahead_score
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and diversity.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.7
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.3
    fragmentation_penalty_base_weight = 0.2
    diversity_bonus_weight = 0.05
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.8
        future_potential_weight = future_potential_base_weight * 1.2
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.1
        future_potential_weight = future_potential_base_weight * 0.7
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.45 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.85
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.5 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            # Simulate placing the item in bin i
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Assume next items are similar in size (simplified lookahead)
            next_item_size = item * 1.1
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            # Reward bins that still have good future potential
            lookahead_bonus[i] = np.sum(future_valid) * 0.1

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty - lookahead_bonus

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_weight = 0.6
    future_potential_weight = 0.5
    utilization_weight = 0.4
    fragmentation_penalty_weight = 0.1
    
    target_ratio = 0.4
    target_remaining = 0.5 * bins
    ideal_utilization = 0.9
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * 0.9 for _ in range(5)]  # Simulate next 5 items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * 0.2

    # Combine all scores into total priority
    priorities = spatial_fit_score + future_potential_score + utilization_score + fragmentation_penalty + lookahead_score
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...request...

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements an "Adaptive Lookahead" strategy that:
    1. Combines spatial fit with future packing potential using dynamic weights
    2. Incorporates item size categorization for adaptive bin matching
    3. Implements dynamic threshold adjustments based on bin state
    4. Uses a diversity bonus to encourage balanced bin usage
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    
    # Initialize priority array
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Get tunable parameters
    spatial_fit_base_weight = 0.5
    future_potential_base_weight = 0.4
    utilization_bonus_base_weight = 0.3
    fragmentation_penalty_base_weight = 0.3
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.95
        future_potential_weight = future_potential_base_weight * 1.1
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.1
        future_potential_weight = future_potential_base_weight * 0.9
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    
    # Item categorization for adaptive bin matching
    item_category = 'small' if item < 0.3 * np.max(bins) else\
                   'medium' if item < 0.5 * np.max(bins) else 'large'
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = item / bins[i]
            
            # Future potential metric with adaptive lookahead
            optimal_remaining = 0.5 * bins[i]
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * 0.2))
            
            # Utilization bonus
            utilization = (bins[i] - remaining[i]) / bins[i]
            ideal_utilization = 0.8
            utilization_bonus = 1 - np.abs(utilization - ideal_utilization)
            
            # Fragmentation penalty
            fragmentation_threshold = 0.3 * bins[i]
            fragmentation_penalty = 0
            if remaining[i] < fragmentation_threshold:
                fragmentation_penalty = 1 - (remaining[i] / bins[i])
            
            # Apply item category-specific weights
            if item_category == 'small':
                spatial_fit *= 1.3
                future_potential *= 0.8
            elif item_category == 'large':
                spatial_fit *= 0.8
                future_potential *= 1.3
            
            # Combine metrics with adaptive weights
            total_score = (
                spatial_fit_weight * spatial_fit +
                future_potential_weight * future_potential +
                utilization_bonus_weight * utilization_bonus -
                fragmentation_penalty_weight * fragmentation_penalty
            )
            
            priorities[i] = total_score
        else:
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_weight = 0.6
    future_potential_weight = 0.5
    utilization_weight = 0.4
    fragmentation_penalty_weight = 0.1
    
    target_ratio = 0.4
    target_remaining = 0.5 * bins
    ideal_utilization = 0.9
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * 0.9 for _ in range(5)]  # Simulate next 5 items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * 0.2

    # Combine all scores into total priority
    priorities = spatial_fit_score + future_potential_score + utilization_score + fragmentation_penalty + lookahead_score
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
------------------------------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function implements a novel "Adaptive Spatial-Future Balance" strategy that:
    1. Combines spatial fit with future packing potential
    2. Uses dynamic weight adjustments based on bin state
    3. Implements diversity bonuses and fragmentation penalties
    4. Includes lookahead heuristics for improved packing efficiency
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = tunable([0.5, 0.6, 0.7])  # Weight for spatial fit component
    future_potential_base_weight = tunable([0.3, 0.4, 0.5])  # Weight for future potential component
    utilization_bonus_base_weight = tunable([0.2, 0.3, 0.4])  # Weight for utilization bonus
    fragmentation_penalty_base_weight = tunable([0.1, 0.2, 0.3])  # Weight for fragmentation penalty
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.7, 0.8]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.8])
        future_potential_weight = future_potential_base_weight * tunable([1.2, 1.3])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.1, 1.2])
        future_potential_weight = future_potential_base_weight * tunable([0.9, 0.8])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit with tunable parameters
    spatial_fit = (item / (bins + tunable([1e-4, 1e-3]))) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = tunable([0.3, 0.4, 0.5]) * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * tunable([0.2, 0.3]))) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.7, 0.8])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable thresholds
    fragmentation_threshold = tunable([0.2, 0.3, 0.4]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.1, 0.2]) * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 39
-------------------


-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and diversity.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.7
    future_potential_base_weight = 0.3
    utilization_bonus_base_weight = 0.3
    fragmentation_penalty_base_weight = 0.2
    diversity_bonus_weight = 0.05
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.8
        future_potential_weight = future_potential_base_weight * 1.2
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.1
        future_potential_weight = future_potential_base_weight * 0.7
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.45 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.85
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = 0.5 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            # Simulate placing the item in bin i
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Assume next items are similar in size (simplified lookahead)
            next_item_size = item * 1.1
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            # Reward bins that still have good future potential
            lookahead_bonus[i] = np.sum(future_valid) * 0.1

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty - lookahead_bonus

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_weight = 0.6
    future_potential_weight = 0.5
    utilization_weight = 0.4
    fragmentation_penalty_weight = 0.1
    
    target_ratio = 0.4
    target_remaining = 0.5 * bins
    ideal_utilization = 0.9
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * 0.9 for _ in range(5)]  # Simulate next 5 items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * 0.2

    # Combine all scores into total priority
    priorities = spatial_fit_score + future_potential_score + utilization_score + fragmentation_penalty + lookahead_score
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and
    reinforcement learning-based adjustments. It uses tunable parameters for dynamic
    optimizations and includes a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.5
    future_potential_base_weight = 0.4
    utilization_bonus_base_weight = 0.2
    fragmentation_penalty_base_weight = 0.1
    reinforcement_learning_weight = 0.15
    lookahead_depth = 3
    diversity_bonus_factor = 0.1

    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.8
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.2
        future_potential_weight = future_potential_base_weight * 0.7

    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit with dynamic adjustment
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    spatial_fit = np.where(spatial_fit > 0.9, 
                          spatial_fit * 0.8,
                          spatial_fit)

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2))
    future_potential = future_potential * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.75
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))
    
    # Calculate fragmentation penalty
    fragmentation_threshold = 0.25 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Reinforcement learning component
    # (This would typically be updated based on past performance)
    rl_adjustment = np.random.normal(0, 0.1, n_bins) * reinforcement_learning_weight

    # Combine metrics into priority score
    priorities = (spatial_fit + 
                 future_potential + 
                 utilization_bonus + 
                 fragmentation_penalty + 
                 rl_adjustment)

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_weight = 0.6
    future_potential_weight = 0.5
    utilization_weight = 0.4
    fragmentation_penalty_weight = 0.1
    
    target_ratio = 0.4
    target_remaining = 0.5 * bins
    ideal_utilization = 0.9
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * 0.9 for _ in range(5)]  # Simulate next 5 items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * 0.2

    # Combine all scores into total priority
    priorities = spatial_fit_score + future_potential_score + utilization_score + fragmentation_penalty + lookahead_score
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

launch 64 evaluate tasks
this best socre: -210.6; best score: -210.6; global score: -210.2; space size: 373248; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -210.2; space size: 373248; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -210.2; space size: 373248; measure cnt: 192

launch 64 evaluate tasks
current thread_i 4
this best socre: -210.25; best score: -210.25; global score: -210.2; space size: 373248; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -210.2; space size: 373248; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, and fragmentation.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    from tunable import tunable
    
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Global bin state analysis
    global_usage = np.mean((bins - remaining) / bins)
    bin_fullness_variance = np.var((bins - remaining) / bins)
    
    # Dynamic weight adjustment based on global state
    base_weights = {
        'spatial_fit': tunable([0.4, 0.5, 0.6]),
        'future_potential': tunable([0.3, 0.4, 0.5]),
        'utilization': tunable([0.2, 0.3, 0.4]),
        'fragmentation': tunable([0.1, 0.2, 0.3])
    }
    
    if global_usage > 0.8:
        adjusted_weights = {
            'spatial_fit': base_weights['spatial_fit'] * 0.9,
            'future_potential': base_weights['future_potential'] * 1.2,
            'utilization': base_weights['utilization'] * 1.1,
            'fragmentation': base_weights['fragmentation'] * 1.5
        }
    else:
        adjusted_weights = base_weights

    # Calculate spatial fit metric
    spatial_fit = (item / (bins + 1e-4)) 
    spatial_fit = np.where(spatial_fit > 1, 0, spatial_fit)
    
    # Future potential with lookahead heuristic
    optimal_remaining_pct = tunable([0.1, 0.15, 0.2])
    optimal_remaining = bins * optimal_remaining_pct
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.15))
    
    # Utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.7, 0.8, 0.9])
    utilization_bonus = 1 - np.abs(utilization - ideal_utilization)
    
    # Fragmentation penalty
    fragmentation_threshold = tunable([0.25, 0.3, 0.35]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        1 - (remaining / bins),
        0
    )
    
    # Combine metrics with dynamic weights
    total_score = (
        adjusted_weights['spatial_fit'] * spatial_fit +
        adjusted_weights['future_potential'] * future_potential +
        adjusted_weights['utilization'] * utilization_bonus -
        adjusted_weights['fragmentation'] * fragmentation_penalty
    )
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.05, 0.1, 0.15]) * np.std(total_score)
    total_score += diversity_bonus
    
    # Penalize bins that are too full or too empty
    fullness_penalty = np.where(
        utilization > tunable([0.95, 0.98, 1.0]),
        tunable([0.1, 0.2, 0.3]),
        0
    )
    emptiness_penalty = np.where(
        utilization < tunable([0.1, 0.2, 0.3]),
        tunable([0.05, 0.1, 0.15]),
        0
    )
    total_score -= fullness_penalty + emptiness_penalty
    
    # Ensure invalid bins have infinite priority (lowest preference)
    total_score[~valid_bins] = float('inf')
    
    return total_score

call llm times: 40
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 531441; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin, considering:
    - Spatial fit: How well the item fits into the bin.
    - Future potential: How much capacity remains for future items, with a lookahead heuristic.
    - Utilization bonus: Preference for bins that are well-utilized.
    - Fragmentation penalty: Discourages bins with very small remaining capacity.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
        lookahead_size: Optional, size of the next expected item for lookahead heuristic.
        
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Tunable parameters
    spatial_fit_base_weight = tunable([0.6, 0.7, 0.8])
    future_potential_base_weight = tunable([0.3, 0.4])
    utilization_bonus_base_weight = tunable([0.2, 0.25])
    fragmentation_penalty_base_weight = tunable([0.1, 0.15])
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.7, 0.8]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.85])
        future_potential_weight = future_potential_base_weight * tunable([1.2, 1.3])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.1, 1.2])
        future_potential_weight = future_potential_base_weight * tunable([0.7, 0.8])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    
    # Calculate spatial fit
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    
    # Calculate future potential with lookahead heuristic
    if lookahead_size is None:
        lookahead_size = np.mean(bins) * tunable([0.3, 0.4])
    optimal_remaining = lookahead_size + item * tunable([0.1, 0.2])
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * tunable([0.2, 0.25]))) * future_potential_weight
    
    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.75, 0.8])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))
    
    # Calculate fragmentation penalty
    fragmentation_threshold = bins * tunable([0.2, 0.25])
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )
    
    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.05, 0.1]) * np.std(priorities)
    priorities += diversity_bonus
    
    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')
    
    return priorities

call llm times: 41
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 49152; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 49152; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -210.2; space size: 49152; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and diversity.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options
    spatial_fit_base_weight = tunable([0.6, 0.7, 0.8])
    future_potential_base_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_base_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_base_weight = tunable([0.1, 0.2, 0.3])
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.8, 0.85]):
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.9, 0.85])
        future_potential_weight = future_potential_base_weight * tunable([1.3, 1.2])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.2, 1.1])
        future_potential_weight = future_potential_base_weight * tunable([0.8, 0.7])
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit with improved formula
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with enhanced lookahead heuristic
    optimal_remaining = tunable([0.4, 0.45, 0.5]) * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * tunable([0.2, 0.25]))) * future_potential_weight

    # Calculate utilization bonus with adaptive ideal utilization
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.8, 0.85])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with dynamic threshold
    fragmentation_threshold = tunable([0.4, 0.45, 0.5]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score with adaptive combination
    priorities = (
        spatial_fit +
        future_potential +
        utilization_bonus +
        fragmentation_penalty
    )

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.1, 0.15, 0.2]) * np.std(priorities)
    priorities += diversity_bonus

    # Penalize bins that are too full or too empty
    fullness_penalty = np.where(
        utilization > tunable([0.9, 0.95]),
        tunable([0.05, 0.1]) * (utilization - tunable([0.9, 0.95])),
        0
    )
    emptiness_penalty = np.where(
        utilization < tunable([0.1, 0.2]),
        tunable([0.05, 0.1]) * (tunable([0.1, 0.2]) - utilization),
        0
    )
    priorities += fullness_penalty + emptiness_penalty

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 42
-------------------



launch 64 evaluate tasks
this best socre: -211.0; best score: -211.0; global score: -210.2; space size: 17915904; measure cnt: 64

launch 64 evaluate tasks
current thread_i 6
current thread_i 7
current thread_i 1
current thread_i 8
current thread_i 2
this best socre: -210.9; best score: -210.9; global score: -210.2; space size: 17915904; measure cnt: 128

launch 64 evaluate tasks
current thread_i 0
current thread_i 5
this best socre: -210.9; best score: -210.9; global score: -210.2; space size: 17915904; measure cnt: 192

launch 64 evaluate tasks
current thread_i 9
this best socre: -210.9; best score: -210.9; global score: -210.2; space size: 17915904; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.9; best score: -210.9; global score: -210.2; space size: 17915904; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Calculate basic metrics
    spatial_fit_base = tunable([0.6, 0.7, 0.8])
    future_potential_base = tunable([0.3, 0.4, 0.5])
    utilization_bonus_base = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_base = tunable([0.1, 0.2, 0.3])

    # Dynamic adjustment based on item size relative to average
    avg_item_size = np.mean(bins - remaining) if n_bins > 0 else 0
    item_size_ratio = item / (avg_item_size + 1e-4)

    # Adaptive weight adjustment
    if item_size_ratio > tunable([1.5, 2.0]):
        spatial_fit_weight = spatial_fit_base * tunable([1.2, 1.5])
        future_potential_weight = future_potential_base * tunable([0.8, 1.0])
    else:
        spatial_fit_weight = spatial_fit_base * tunable([0.9, 1.1])
        future_potential_weight = future_potential_base * tunable([1.1, 1.3])

    utilization_bonus_weight = utilization_bonus_base
    fragmentation_penalty_weight = fragmentation_penalty_base

    # Spatial fit metric
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Future potential with lookahead heuristic
    optimal_remaining = tunable([0.3, 0.4, 0.5]) * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * tunable([0.2, 0.3]))) * future_potential_weight

    # Utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.7, 0.8, 0.9])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Fragmentation penalty
    fragmentation_threshold = tunable([0.2, 0.3, 0.4]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.05, 0.1, 0.15]) * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 43
-------------------



launch 64 evaluate tasks
this best socre: -210.9; best score: -210.9; global score: -210.2; space size: 419904; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -210.2; space size: 419904; measure cnt: 128

launch 64 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -210.2; space size: 419904; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -210.2; space size: 419904; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -210.2; space size: 419904; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and diversity.
    It uses tunable parameters for dynamic adjustments and includes a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    optimal_remaining_frac = tunable([0.2, 0.3, 0.4])
    ideal_utilization = tunable([0.7, 0.8, 0.9])
    fragmentation_threshold_frac = tunable([0.1, 0.2, 0.3])
    
    spatial_fit_weight = tunable([0.5, 0.6, 0.7])
    future_potential_weight = tunable([0.2, 0.3, 0.4])
    utilization_weight = tunable([0.1, 0.2, 0.3])
    fragmentation_weight = tunable([0.1, 0.2, 0.3])
    diversity_bonus_factor = tunable([0.05, 0.1, 0.15])

    # Calculate optimal remaining space
    optimal_remaining = optimal_remaining_frac * bins

    # Spatial fit cost: lower when remaining is close to optimal
    spatial_fit_cost = np.abs(remaining - optimal_remaining) / (bins + 1e-4)
    spatial_fit_cost = spatial_fit_cost * spatial_fit_weight

    # Future potential cost: lower when remaining is suitable for future items
    future_potential_cost = 1 - np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2))
    future_potential_cost = future_potential_cost * future_potential_weight

    # Utilization cost: lower when utilization is close to ideal
    utilization = (bins - remaining) / bins
    utilization_cost = np.abs(utilization - ideal_utilization) * utilization_weight

    # Fragmentation cost: higher when remaining is too small
    fragmentation_cost = np.where(
        remaining < fragmentation_threshold_frac * bins,
        (1 - (remaining / bins)) * fragmentation_weight,
        0
    )

    # Combine costs into priority score
    priorities = spatial_fit_cost + future_potential_cost + utilization_cost + fragmentation_cost

    # Diversity bonus: encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 44
-------------------



launch 64 evaluate tasks
this best socre: -242.3; best score: -242.3; global score: -210.2; space size: 6561; measure cnt: 64
.................................................................................................................................................................................
launch 64 evaluate tasks
this best socre: -242.3; best score: -242.3; global score: -210.2; space size: 6561; measure cnt: 128
...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 61 evaluate tasks
this best socre: -242.3; best score: -242.3; global score: -210.2; space size: 6561; measure cnt: 189
...........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 64 evaluate tasks
this best socre: -242.3; best score: -242.3; global score: -210.2; space size: 6561; measure cnt: 253
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with multiple options
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.2, 0.3, 0.4])
    utilization_bonus_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = tunable([0.3, 0.4, 0.5]) * bins
    optimal_remaining = tunable([0.2, 0.3, 0.4]) * bins
    ideal_utilization = tunable([0.7, 0.8, 0.9])

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Calculate diversity bonus based on remaining capacity distribution
    diversity_bonus = diversity_bonus_weight * np.std(remaining)

    # Combine metrics into priority score
    priorities = (
        spatial_fit +
        future_potential +
        utilization_bonus +
        fragmentation_penalty +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 45
-------------------


.
launch 64 evaluate tasks
this best socre: -211.65; best score: -211.65; global score: -210.2; space size: 6561; measure cnt: 64
..
launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -210.2; space size: 6561; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -210.2; space size: 6561; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -210.2; space size: 6561; measure cnt: 256
.
launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -210.2; space size: 6561; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with novel metrics and tunable parameters."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with multiple options
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.25, 0.3, 0.35])
    utilization_bonus_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    diversity_bonus_multiplier = tunable([0.1, 0.15, 0.2])
    
    # Dynamic thresholds based on tunable parameters
    optimal_remaining_threshold = tunable([0.3, 0.4, 0.5]) * bins
    fragmentation_threshold = tunable([0.2, 0.25, 0.3]) * bins
    average_item_size = tunable([0.5, 0.6, 0.7]) * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.7, 0.75, 0.8])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Calculate bin diversity bonus to encourage balanced usage
    bin_usage = 1 - (remaining / bins)
    diversity_score = 1 / (1 + np.exp(-(bin_usage - 0.5) * tunable([2, 3, 4])))
    diversity_bonus = diversity_bonus_multiplier * (1 - diversity_score)

    # Combine metrics into priority score
    priorities = (
        spatial_fit 
        + future_potential 
        + utilization_bonus 
        + fragmentation_penalty 
        + diversity_bonus
    )

    # Apply additional adjustments based on remaining space distribution
    remaining_order = np.argsort(remaining)
    priorities[remaining_order[:tunable([1, 2, 3])]] += tunable([0.05, 0.1, 0.15])

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 46
-------------------



launch 64 evaluate tasks
this best socre: -211.65; best score: -211.65; global score: -210.2; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.5; best score: -211.5; global score: -210.2; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.45; best score: -211.45; global score: -210.2; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.4; best score: -211.4; global score: -210.2; space size: 531441; measure cnt: 256

launch 64 evaluate tasks
this best socre: -211.2; best score: -211.2; global score: -210.2; space size: 531441; measure cnt: 320

launch 64 evaluate tasks
this best socre: -211.2; best score: -211.2; global score: -210.2; space size: 531441; measure cnt: 384

launch 64 evaluate tasks
this best socre: -211.2; best score: -211.2; global score: -210.2; space size: 531441; measure cnt: 448

launch 64 evaluate tasks
this best socre: -211.2; best score: -211.2; global score: -210.2; space size: 531441; measure cnt: 512
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with novel metrics and tunable parameters."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.2, 0.3, 0.4])
    variety_bonus_weight = tunable([0.1, 0.15, 0.2])
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15])
    diversity_bonus_multiplier = tunable([0.1, 0.15, 0.2])

    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = tunable([0.2, 0.3, 0.4]) * bins
    average_item_size = tunable([0.5, 0.6, 0.7]) * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate variety bonus: preference for bins that can still fit a variety of items
    variety_score = np.exp(-np.abs(remaining - (bins * 0.5)) / (bins * 0.15))
    variety_bonus = variety_bonus_weight * variety_score

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + variety_bonus - fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Apply penalties to bins that are too fragmented or cannot fit the item
    fragmentation_penalty_mask = remaining < (bins * tunable([0.1, 0.2, 0.3]))
    priorities[fragmentation_penalty_mask] -= tunable([0.5, 0.7, 1.0])

    # Ensure invalid bins have very low priority
    priorities[~valid_bins] = -np.inf

    return priorities

call llm times: 47
-------------------



launch 64 evaluate tasks
this best socre: -218.75; best score: -218.75; global score: -210.2; space size: 19683; measure cnt: 64
......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 50 evaluate tasks
this best socre: -218.75; best score: -218.75; global score: -210.2; space size: 19683; measure cnt: 114
........................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 64 evaluate tasks
this best socre: -218.75; best score: -218.75; global score: -210.2; space size: 19683; measure cnt: 178
.....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 64 evaluate tasks
this best socre: -218.1; best score: -218.1; global score: -210.2; space size: 19683; measure cnt: 242
.............................................................................................
launch 64 evaluate tasks
this best socre: -218.1; best score: -218.1; global score: -210.2; space size: 19683; measure cnt: 306
.................................................................................................
launch 64 evaluate tasks
this best socre: -218.1; best score: -218.1; global score: -210.2; space size: 19683; measure cnt: 370
.......................................................................................................................................................
launch 64 evaluate tasks
this best socre: -218.1; best score: -218.1; global score: -210.2; space size: 19683; measure cnt: 434
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.7, 0.9])
    future_potential_weight = tunable([0.3, 0.4, 0.2])
    utilization_bonus_weight = tunable([0.4, 0.5, 0.3])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.05])
    diversity_bonus_multiplier = tunable([0.15, 0.2, 0.1])
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = tunable([0.4, 0.3, 0.5]) * bins
    average_item_size = tunable([0.6, 0.7, 0.5]) * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * tunable([0.2, 0.3, 0.1])))
    future_potential *= future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.8, 0.75, 0.85])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus - fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 48
-------------------



launch 64 evaluate tasks
this best socre: -211.0; best score: -211.0; global score: -210.2; space size: 19683; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.2; space size: 19683; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -210.95; best score: -210.95; global score: -210.2; space size: 19683; measure cnt: 192

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -210.2; space size: 19683; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -210.2; space size: 19683; measure cnt: 320
.
launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -210.2; space size: 19683; measure cnt: 384
.
launch 64 evaluate tasks
this best socre: -210.55; best score: -210.55; global score: -210.2; space size: 19683; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and introduces a novel lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Calculate dynamic parameters based on current state
    average_item_size = tunable([0.6, 0.7, 0.8]) * np.mean(bins)
    global_usage = np.mean((bins - remaining) / bins)
    
    # Tunable parameters with dynamic adjustments
    spatial_fit_weight = tunable([0.8, 0.75, 0.85])
    future_potential_weight = tunable([0.5, 0.6, 0.4])
    utilization_bonus_weight = tunable([0.4, 0.35, 0.45])
    fragmentation_penalty_weight = tunable([0.2, 0.15, 0.25])
    diversity_bonus_weight = tunable([0.05, 0.07, 0.03])
    
    # Dynamic thresholds
    fragmentation_threshold = tunable([0.4, 0.35, 0.45]) * bins
    ideal_remaining = tunable([0.3, 0.25, 0.35]) * bins
    
    # 1. Calculate spatial fit with dynamic normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    
    # 2. Calculate future potential with lookahead heuristic
    # Prioritize bins that leave space close to the average item size
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight
    
    # 3. Calculate utilization bonus
    utilization = (bins - remaining) / bins
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - tunable([0.8, 0.75, 0.85])))
    
    # 4. Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )
    
    # 5. Calculate diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    
    # 6. Combine metrics into priority score with dynamic weight adjustments
    priorities = (
        spatial_fit +
        future_potential +
        utilization_bonus +
        fragmentation_penalty +
        diversity_bonus
    )
    
    # Apply dynamic weight adjustments based on global usage
    if global_usage > tunable([0.7, 0.65, 0.75]):
        priorities *= tunable([1.1, 1.05, 1.15])
    
    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')
    
    return priorities

call llm times: 49
-------------------



launch 64 evaluate tasks
this best socre: -211.4; best score: -211.4; global score: -210.2; space size: 177147; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.2; space size: 177147; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.2; space size: 177147; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.2; space size: 177147; measure cnt: 256

launch 64 evaluate tasks
this best socre: -211.35; best score: -211.35; global score: -210.2; space size: 177147; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_weight = tunable([0.5, 0.6, 0.7])
    fragmentation_penalty_weight = tunable([0.1, 0.2, 0.3])
    diversity_bonus_multiplier = tunable([0.15, 0.2, 0.25])
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = tunable([0.3, 0.4, 0.5]) * bins
    average_item_size = tunable([0.5, 0.6, 0.7]) * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * tunable([0.15, 0.2, 0.25])))
    future_potential *= future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.75, 0.8, 0.85])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus - fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Apply global adjustment based on overall bin usage
    global_usage = np.mean(bins - remaining) / np.mean(bins)
    if global_usage > tunable([0.6, 0.7, 0.8]):
        priorities *= tunable([1.1, 1.2, 1.3])

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 50
-------------------



launch 64 evaluate tasks
this best socre: -211.5; best score: -211.5; global score: -210.2; space size: 177147; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.0; best score: -211.0; global score: -210.2; space size: 177147; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.0; best score: -211.0; global score: -210.2; space size: 177147; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.0; best score: -211.0; global score: -210.2; space size: 177147; measure cnt: 256

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.2; space size: 177147; measure cnt: 320

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.2; space size: 177147; measure cnt: 384

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.2; space size: 177147; measure cnt: 448

launch 64 evaluate tasks
this best socre: -210.75; best score: -210.75; global score: -210.2; space size: 177147; measure cnt: 512
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.7, 0.9])
    future_potential_weight = tunable([0.3, 0.4, 0.2])
    utilization_bonus_weight = tunable([0.4, 0.5, 0.3])
    fragmentation_penalty_weight = tunable([0.1, 0.2, 0.05])
    diversity_bonus_multiplier = tunable([0.15, 0.2, 0.1])

    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = tunable([0.4, 0.35, 0.45]) * bins
    average_item_size = tunable([0.6, 0.7, 0.5]) * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * tunable([0.2, 0.25, 0.15]))) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.8, 0.75, 0.85])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 51
-------------------



launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 19683; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 19683; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 19683; measure cnt: 192
...
launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 19683; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])  # Weight for spatial fit metric
    future_potential_weight = tunable([0.3, 0.4, 0.5])  # Weight for future potential metric
    utilization_bonus_weight = tunable([0.5, 0.6, 0.7])  # Weight for utilization bonus
    fragmentation_penalty_weight = tunable([0.2, 0.3, 0.4])  # Weight for fragmentation penalty
    diversity_bonus_multiplier = tunable([0.1, 0.15, 0.2])  # Multiplier for diversity bonus

    # Dynamic thresholds based on tunable parameters
    ideal_fit_ratio = tunable([0.5, 0.6, 0.7])  # Ideal ratio of item size to bin capacity
    average_item_size = tunable([0.5, 0.6, 0.7]) * bins  # Heuristic based on bin capacity
    ideal_utilization = tunable([0.7, 0.8, 0.9])  # Ideal utilization level
    fragmentation_threshold = tunable([0.3, 0.4, 0.5]) * bins  # Threshold for fragmentation penalty

    # Calculate spatial fit with improved normalization
    fit_ratio = item / (bins + 1e-4)
    spatial_fit = (1 - np.abs(fit_ratio - ideal_fit_ratio)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 52
-------------------



launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -210.2; space size: 19683; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -210.2; space size: 19683; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -210.2; space size: 19683; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -210.2; space size: 19683; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.7, 0.9])
    future_potential_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_weight = tunable([0.4, 0.5, 0.6])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    diversity_bonus_multiplier = tunable([0.15, 0.2, 0.25])
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = tunable([0.4, 0.3, 0.5]) * bins
    average_item_size = tunable([0.6, 0.7, 0.5]) * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * tunable([0.2, 0.15, 0.25]))) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.8, 0.75, 0.85])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 53
-------------------



launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 19683; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 19683; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 19683; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.3; best score: -211.3; global score: -210.2; space size: 19683; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential. Parameters are tunable for different scenarios.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    weight_adjustment_factor = 0.9 if global_usage > 0.7 else 1.1

    # Tunable parameters
    spatial_fit_base_weight = tunable([0.5, 0.6, 0.7])
    future_potential_base_weight = tunable([0.3, 0.4, 0.5])
    utilization_bonus_base_weight = tunable([0.1, 0.2])
    fragmentation_penalty_base_weight = tunable([0.05, 0.1])

    # Apply dynamic adjustment
    spatial_fit_weight = spatial_fit_base_weight * weight_adjustment_factor
    future_potential_weight = future_potential_base_weight / weight_adjustment_factor
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit with target ratio
    target_ratio = tunable([0.3, 0.4, 0.5])
    ideal_remaining = tunable([0.4, 0.5, 0.6]) * bins
    spatial_fit = np.abs(item / (bins + 1e-4) - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with improved lookahead
    future_items_count = tunable([3, 5, 7])
    future_item_size_factor = tunable([0.8, 0.9, 1.0])
    future_items = [item * future_item_size_factor for _ in range(future_items_count)]
    
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = bins.copy()
            temp_bins[i] -= item
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    future_potential_score = lookahead_score * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = tunable([0.7, 0.8, 0.9])
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = tunable([0.2, 0.25, 0.3]) * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine all metrics into total priority
    priorities = (
        spatial_fit_score 
        + future_potential_score 
        + utilization_bonus 
        + fragmentation_penalty
    )

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.05, 0.1, 0.15]) * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 54
-------------------



launch 64 evaluate tasks
this best socre: -215.95; best score: -215.95; global score: -210.2; space size: 78732; measure cnt: 64
.........................................................................................
launch 64 evaluate tasks
this best socre: -215.95; best score: -215.95; global score: -210.2; space size: 78732; measure cnt: 128
............................................................................................................................................................................
launch 64 evaluate tasks
this best socre: -215.95; best score: -215.95; global score: -210.2; space size: 78732; measure cnt: 192
......................................................................................................................................................................
launch 64 evaluate tasks
this best socre: -215.95; best score: -215.95; global score: -210.2; space size: 78732; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1])
    
    target_ratio = tunable([0.4, 0.45, 0.5])
    target_remaining = tunable([0.45, 0.5, 0.55]) * bins
    ideal_utilization = tunable([0.85, 0.9, 0.95])
    fragmentation_threshold = tunable([0.2, 0.3]) * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = tunable([2, 3, 4])
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * tunable([1.05, 1.1, 1.15])
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * tunable([0.1, 0.15])

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 55
-------------------



launch 64 evaluate tasks
this best socre: -209.4; best score: -209.4; global score: -209.4; space size: 104976; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.4; best score: -209.4; global score: -209.4; space size: 104976; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.05; best score: -209.05; global score: -209.05; space size: 104976; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -209.05; best score: -209.05; global score: -209.05; space size: 104976; measure cnt: 256

launch 64 evaluate tasks
this best socre: -208.9; best score: -208.9; global score: -208.9; space size: 104976; measure cnt: 320
.
launch 64 evaluate tasks
this best socre: -208.9; best score: -208.9; global score: -208.9; space size: 104976; measure cnt: 384

launch 64 evaluate tasks
this best socre: -208.9; best score: -208.9; global score: -208.9; space size: 104976; measure cnt: 448

launch 64 evaluate tasks
this best socre: -208.9; best score: -208.9; global score: -208.9; space size: 104976; measure cnt: 512
sampler suggest should end sample, break
INFO:absl:Best score increased to -208.9
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    target_remaining_ratio = tunable([0.4, 0.5, 0.6])  # Target remaining space ratio
    target_item_ratio = tunable([0.3, 0.4, 0.5])      # Target item size ratio to bin capacity
    lookahead_depth = tunable([3, 5, 7])              # Number of future items to simulate
    utilization_weight = tunable([0.3, 0.4, 0.5])     # Weight for utilization score
    fragmentation_penalty = tunable([0.1, 0.2, 0.3])  # Penalty weight for fragmentation
    diversity_bonus = tunable([0.05, 0.1, 0.15])      # Bonus for encouraging balanced bin usage

    # Calculate spatial fit score
    ideal_bin_size = item / target_item_ratio
    spatial_fit = np.abs(bins - ideal_bin_size)
    spatial_fit_score = 1.0 / (spatial_fit + 1e-4)  # Higher when closer to ideal
    spatial_fit_score = np.where(valid_bins, spatial_fit_score, 0)

    # Calculate future potential using lookahead
    future_items = [item * (1.0 - i/10.0) for i in range(lookahead_depth)]
    future_items += [item * (1.0 + i/10.0) for i in range(lookahead_depth)]
    future_items = np.clip(future_items, 1e-4, 2*item)

    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = bins.copy()
            temp_bins[i] -= item
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    lookahead_score = lookahead_score * 0.3  # Weight the lookahead score

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1.0 - np.abs(utilization - 0.75))

    # Calculate fragmentation penalty
    fragmentation_threshold = tunable([0.2, 0.25, 0.3]) * bins
    fragmentation_penalty_score = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty * (1.0 - (remaining / bins)),
        0.0
    )

    # Combine all scores into total priority
    priorities = (
        spatial_fit_score +
        lookahead_score +
        utilization_score +
        fragmentation_penalty_score
    )

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus_score = diversity_bonus * np.std(priorities)
    priorities += diversity_bonus_score

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 56
-------------------


.
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.9; space size: 2187; measure cnt: 64
....
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.9; space size: 2187; measure cnt: 128
...
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.9; space size: 2187; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with lookahead and adaptive metrics.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Tunable parameters
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    fragmentation_penalty_weight = tunable([0.1, 0.2, 0.3])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])
    
    target_ratio = tunable([0.4, 0.45, 0.5])
    ideal_remaining = tunable([0.4, 0.5, 0.6]) * bins
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold = tunable([0.2, 0.25, 0.3]) * bins
    lookahead_depth = tunable([3, 5, 7])
    
    # Item categorization
    max_bin = np.max(bins)
    if item < 0.3 * max_bin:
        item_category = 'small'
    elif item < 0.6 * max_bin:
        item_category = 'medium'
    else:
        item_category = 'large'
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = np.abs(item / bins[i] - target_ratio)
            spatial_score = (1 - spatial_fit) * spatial_fit_weight
            
            # Future potential metric with lookahead
            future_bins = bins.copy()
            future_bins[i] -= item
            placed = 0
            for _ in range(lookahead_depth):
                future_item = tunable([item * 0.8, item * 0.9, item * 1.0])
                best_bin = np.argmax(future_bins - future_item > 0)
                if best_bin >= 0:
                    future_bins[best_bin] -= future_item
                    placed += 1
            future_potential = placed / lookahead_depth
            future_score = future_potential * future_potential_weight
            
            # Utilization metric
            utilization = (bins[i] - remaining[i]) / bins[i]
            utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))
            
            # Fragmentation penalty
            fragmentation_penalty = 0
            if remaining[i] < fragmentation_threshold[i]:
                fragmentation_penalty = fragmentation_penalty_weight * (1 - (remaining[i] / bins[i]))
            
            # Combine metrics
            total_score = spatial_score + future_score + utilization_score - fragmentation_penalty
            
            # Apply item category-specific adjustments
            if item_category == 'small':
                total_score *= tunable([1.1, 1.2])
            elif item_category == 'large':
                total_score *= tunable([0.9, 0.8])
            
            priorities[i] = total_score
        else:
            priorities[i] = float('inf')  # Invalid bins have infinite priority
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities

call llm times: 57
-------------------



launch 64 evaluate tasks
this best socre: -219.55; best score: -219.55; global score: -208.9; space size: 708588; measure cnt: 64

launch 64 evaluate tasks
this best socre: -219.55; best score: -219.55; global score: -208.9; space size: 708588; measure cnt: 128

launch 64 evaluate tasks
this best socre: -219.55; best score: -219.55; global score: -208.9; space size: 708588; measure cnt: 192

launch 64 evaluate tasks
this best socre: -219.55; best score: -219.55; global score: -208.9; space size: 708588; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential. It uses tunable parameters for dynamic
    optimizations and includes a diversity bonus to encourage balanced bin usage.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    lookahead_depth = tunable([3, 5, 7])
    diversity_bonus_factor = tunable([0.05, 0.1, 0.15])

    target_ratio = tunable([0.4, 0.5, 0.6])
    ideal_utilization = tunable([0.75, 0.8, 0.85])
    fragmentation_threshold = tunable([0.2, 0.25, 0.3]) * bins

    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.7, 0.8]):
        spatial_fit_weight = tunable([0.5, 0.6]) * spatial_fit_weight
        future_potential_weight = tunable([1.2, 1.3]) * future_potential_weight

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_item_sizes = np.random.normal(item, item * 0.2, lookahead_depth)
    future_item_sizes = np.clip(future_item_sizes, 0.1 * item, 2 * item)
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_item_sizes:
                possible_bins = temp_bins - future_item
                best_bin = np.argmax(possible_bins)
                if possible_bins[best_bin] > 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / lookahead_depth

    lookahead_score = lookahead_score * future_potential_weight

    # Combine all scores into total priority
    priorities = spatial_fit_score + utilization_score + fragmentation_penalty + lookahead_score

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 58
-------------------



launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -208.9; space size: 157464; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -208.9; space size: 157464; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -208.9; space size: 157464; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -208.9; space size: 157464; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    
    target_ratio = tunable([0.4, 0.45, 0.5])
    target_remaining = tunable([0.5, 0.6, 0.7]) * bins
    ideal_utilization = tunable([0.75, 0.8, 0.85])
    fragmentation_threshold = tunable([0.2, 0.25, 0.3]) * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * tunable([0.8, 0.9, 1.0]) for _ in range(tunable([3, 5, 7]))]  # Simulate next few items
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * tunable([0.1, 0.15, 0.2])

    # Combine all scores into total priority
    priorities = (
        spatial_fit_score 
        + future_potential_score 
        + utilization_score 
        + fragmentation_penalty 
        + lookahead_score
    )

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.05, 0.1, 0.15]) * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 59
-------------------



launch 64 evaluate tasks
this best socre: -212.05; best score: -212.05; global score: -208.9; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.05; best score: -212.05; global score: -208.9; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -212.05; best score: -212.05; global score: -208.9; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.05; best score: -212.05; global score: -208.9; space size: 531441; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic lookahead and tunable parameters."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    fragmentation_penalty_weight = tunable([0.1, 0.2, 0.3])
    lookahead_depth = tunable([5, 10, 15])
    future_item_size_factors = tunable([[0.9, 0.8, 0.7], [0.95, 0.9, 0.85]])

    target_ratio = tunable([0.4, 0.5])
    ideal_utilization = tunable([0.85, 0.9])
    fragmentation_threshold = tunable([0.2, 0.3]) * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = tunable([0.4, 0.5, 0.6]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and check future potential
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * factor for factor in future_item_size_factors for _ in range(lookahead_depth // len(future_item_size_factors))]
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * tunable([0.1, 0.2])

    # Combine all scores into total priority
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        lookahead_score -
        fragmentation_penalty
    )
    priorities[~valid_bins] = float('inf')  # Invalid bins have infinite priority

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = tunable([0.05, 0.1]) * np.std(priorities)
    priorities += diversity_bonus

    return priorities

call llm times: 60
-------------------



launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.9; space size: 139968; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.9; space size: 139968; measure cnt: 128

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.9; space size: 139968; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.9; space size: 139968; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential. It uses tunable parameters for
    flexibility and strategic innovation.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.2])
    lookahead_depth = tunable([2, 3, 4])
    
    target_ratio = tunable([0.4, 0.5])
    ideal_remaining = tunable([0.45, 0.5]) * bins
    ideal_utilization = tunable([0.85, 0.9])
    fragmentation_threshold = tunable([0.2, 0.3]) * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - ideal_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Simulate next items with varying sizes
            next_items = [item * (1 + tunable([0.1, 0.2, 0.3])) for _ in range(lookahead_depth)]
            placed = 0
            for future_item in next_items:
                best_bin = np.argmax(simulated_bins - future_item > 0)
                if best_bin >= 0:
                    simulated_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(next_items)
    lookahead_score = lookahead_score * 0.2

    # Combine all scores into total priority
    priorities = (
        spatial_fit_score + 
        future_potential_score + 
        utilization_score + 
        fragmentation_penalty + 
        lookahead_score
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 61
-------------------



launch 64 evaluate tasks
this best socre: -211.05; best score: -211.05; global score: -208.9; space size: 7776; measure cnt: 64

launch 64 evaluate tasks
this best socre: -210.85; best score: -210.85; global score: -208.9; space size: 7776; measure cnt: 128
..
launch 64 evaluate tasks
this best socre: -210.85; best score: -210.85; global score: -208.9; space size: 7776; measure cnt: 192
..
launch 64 evaluate tasks
this best socre: -210.85; best score: -210.85; global score: -208.9; space size: 7776; measure cnt: 256
....
launch 64 evaluate tasks
this best socre: -210.85; best score: -210.85; global score: -208.9; space size: 7776; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, and a lookahead
    heuristic for improved future packing potential. It uses tunable parameters for flexibility.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = tunable([0.6, 0.7, 0.8])
    future_potential_base_weight = tunable([0.5, 0.6, 0.7])
    utilization_base_weight = tunable([0.4, 0.5, 0.6])
    fragmentation_penalty_base_weight = tunable([0.1, 0.2, 0.3])
    
    target_ratio = tunable([0.4, 0.5, 0.6])
    target_remaining = tunable([0.3, 0.4, 0.5]) * bins
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold = tunable([0.2, 0.25, 0.3]) * bins
    lookahead_depth = tunable([3, 5, 7])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])

    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * tunable([0.95, 0.9, 0.85])
        future_potential_weight = future_potential_base_weight * tunable([1.1, 1.2, 1.3])
    else:
        spatial_fit_weight = spatial_fit_base_weight * tunable([1.1, 1.2, 1.3])
        future_potential_weight = future_potential_base_weight * tunable([0.9, 0.85, 0.8])

    utilization_weight = utilization_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Item categorization for adaptive bin matching
    max_bin = np.max(bins)
    item_category = 'small' if item < 0.3 * max_bin else \
                   'medium' if item < 0.5 * max_bin else 'large'

    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit_ratio = item / bins[i]
            remaining_space = remaining[i]
            spatial_fit = 1 - np.abs(spatial_fit_ratio - target_ratio)
            
            # Future potential metric with adaptive lookahead
            optimal_remaining = target_remaining[i]
            future_potential = np.exp(-np.abs(remaining_space - optimal_remaining) / (bins[i] * 0.2))
            
            # Utilization bonus
            utilization = (bins[i] - remaining_space) / bins[i]
            utilization_bonus = 1 - np.abs(utilization - ideal_utilization)
            
            # Fragmentation penalty
            fragmentation_penalty = 0
            if remaining_space < fragmentation_threshold[i]:
                fragmentation_penalty = 1 - (remaining_space / bins[i])
            
            # Apply item category-specific adjustments
            if item_category == 'small':
                spatial_fit *= tunable([1.2, 1.3, 1.4])
                future_potential *= tunable([0.8, 0.9, 1.0])
            elif item_category == 'large':
                spatial_fit *= tunable([0.8, 0.9, 1.0])
                future_potential *= tunable([1.2, 1.3, 1.4])
            
            # Combine metrics with adaptive weights
            total_score = (
                spatial_fit_weight * spatial_fit +
                future_potential_weight * future_potential +
                utilization_weight * utilization_bonus -
                fragmentation_penalty_weight * fragmentation_penalty
            )
            
            priorities[i] = total_score
        else:
            priorities[i] = float('inf')

    # Apply lookahead heuristic
    lookahead_bins = bins.copy()
    lookahead_bins[valid_bins] -= item
    future_items = [item * tunable([0.8, 0.9, 1.0]) for _ in range(lookahead_depth)]
    lookahead_score = np.zeros(n_bins, dtype=np.float64)
    
    for i in range(n_bins):
        if valid_bins[i]:
            temp_bins = lookahead_bins.copy()
            temp_bins[i] += item  # Revert the subtraction
            placed = 0
            for future_item in future_items:
                best_bin = np.argmax(temp_bins - future_item > 0)
                if best_bin >= 0:
                    temp_bins[best_bin] -= future_item
                    placed += 1
            lookahead_score[i] = placed / len(future_items)
    
    lookahead_score = lookahead_score * tunable([0.1, 0.15, 0.2])
    priorities += lookahead_score

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    priorities += diversity_bonus

    return priorities

call llm times: 62
-------------------



launch 64 evaluate tasks
this best socre: -219.0; best score: -219.0; global score: -208.9; space size: 3486784401; measure cnt: 64

launch 64 evaluate tasks
this best socre: -217.8; best score: -217.8; global score: -208.9; space size: 3486784401; measure cnt: 128

launch 64 evaluate tasks
this best socre: -217.8; best score: -217.8; global score: -208.9; space size: 3486784401; measure cnt: 192

launch 64 evaluate tasks
this best socre: -217.8; best score: -217.8; global score: -208.9; space size: 3486784401; measure cnt: 256

launch 64 evaluate tasks
this best socre: -217.8; best score: -217.8; global score: -208.9; space size: 3486784401; measure cnt: 320
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Returns priority with which we want to add item to each bin, considering both spatial fit and future packing potential."""
    
    # Calculate remaining capacity if the item is placed in each bin
    remaining_capacity = bins - item
    
    # Avoid negative remaining capacities (though bins should have sufficient capacity)
    remaining_capacity = np.maximum(remaining_capacity, 0)
    
    # Spatial efficiency: how well the item fits into the bin relative to bin capacity
    spatial_efficiency = item / bins
    
    # Future potential: based on remaining capacity and expected future items
    # Using a tunable parameter for expected future item size
    expected_future_item = 0.3  # Example tunable parameter
    
    # Calculate future potential score
    future_potential = remaining_capacity / (expected_future_item + 1e-9)  # Avoid division by zero
    
    # Combine the metrics with tunable weights
    weight_spatial = 0.4
    weight_remaining = 0.2
    weight_future = 0.2
    
    # Normalize each component to prevent one metric from dominating
    spatial_norm = spatial_efficiency / np.max(spatial_efficiency)
    remaining_norm = remaining_capacity / np.max(remaining_capacity)
    future_norm = future_potential / np.max(future_potential)
    
    # Calculate priority as a weighted sum
    priorities = (
        weight_spatial * spatial_norm +
        weight_remaining * remaining_norm +
        weight_future * future_norm
    )
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with options for optimization
    spatial_fit_weight = 0.7
    future_potential_weight = 0.5
    utilization_bonus_weight = 0.7
    fragmentation_penalty_weight = 0.1
    diversity_bonus_multiplier = 0.25
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.5 * bins
    average_item_size = 0.5 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential *= future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.75
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus - fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Apply global adjustment based on overall bin usage
    global_usage = np.mean(bins - remaining) / np.mean(bins)
    if global_usage > 0.6:
        priorities *= 1.2

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------
request...
-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy."""
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0

    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)

    # Get tunable parameters
    weight_spatial = 0.6
    weight_future = 0.5
    weight_util = 0.4
    optimal_factor = 0.3
    scaling_factor = 0.1
    utilization_cap = 0.8
    diversity_bonus_factor = 0.1
    global_usage_threshold = 0.7
    global_usage_multiplier = 1.2

    # Calculate dynamic optimal remaining capacity based on current bin distribution
    if np.any(valid_bins):
        avg_remaining = np.mean(remaining[valid_bins])
        optimal_remaining = optimal_factor * avg_remaining
    else:
        optimal_remaining = 0  # No valid bins, shouldn't affect as valid_bins is checked

    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]

            # Future potential metric: How well remaining capacity aligns with optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * scaling_factor))

            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], utilization_cap)

            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )

            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > global_usage_threshold:
                total_score *= global_usage_multiplier

            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_factor * np.std(priorities)
    priorities += diversity_bonus

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.4
    utilization_bonus_weight = 0.6
    fragmentation_penalty_weight = 0.15
    diversity_bonus_multiplier = 0.25
    
    # Dynamic thresholds based on tunable parameters
    fragmentation_threshold = 0.3 * bins
    average_item_size = 0.7 * bins  # Heuristic based on bin capacity

    # Calculate spatial fit with improved normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25)) * future_potential_weight

    # Calculate utilization bonus with ideal utilization point
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.8
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus based on current priority distribution
    diversity_bonus = diversity_bonus_multiplier * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments.
    
    This function implements a novel "Adaptive Spatial-Future Balance" strategy that:
    1. Combines spatial fit with future packing potential
    2. Uses dynamic weight adjustments based on bin state
    3. Implements diversity bonuses and fragmentation penalties
    4. Includes lookahead heuristics for improved packing efficiency
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_base_weight = 0.5  # Weight for spatial fit component
    future_potential_base_weight = 0.3  # Weight for future potential component
    utilization_bonus_base_weight = 0.4  # Weight for utilization bonus
    fragmentation_penalty_base_weight = 0.1  # Weight for fragmentation penalty
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.8:
        spatial_fit_weight = spatial_fit_base_weight * 0.9
        future_potential_weight = future_potential_base_weight * 1.3
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.1
        future_potential_weight = future_potential_base_weight * 0.9
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight

    # Calculate spatial fit with tunable parameters
    spatial_fit = (item / (bins + 1e-3)) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    optimal_remaining = 0.3 * bins
    future_potential = np.exp(-np.abs(remaining - optimal_remaining) / (bins * 0.2)) * future_potential_weight

    # Calculate utilization bonus
    utilization = (bins - remaining) / bins
    ideal_utilization = 0.7
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable thresholds
    fragmentation_threshold = 0.4 * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Combine metrics into priority score
    priorities = spatial_fit + future_potential + utilization_bonus + fragmentation_penalty

    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.2 * np.std(priorities)
    priorities += diversity_bonus

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------
-----------------------
-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements a "Hybrid Spatial-Future" strategy that:
    1. Combines spatial fit with future packing potential in a novel way
    2. Uses adaptive weights based on bin utilization patterns
    3. Implements a diversity bonus to prevent overfitting to a single bin
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Get tunable parameters
    weight_spatial = 0.6  # Weight for spatial fit component
    weight_future = 0.4   # Weight for future potential component
    weight_util = 0.3     # Weight for utilization bonus
    
    # Calculate dynamic optimal remaining capacity based on current bin distribution
    avg_remaining = np.mean(remaining[valid_bins])
    optimal_remaining = 0.2 * bins
    
    for i in range(len(bins)):
        if valid_bins[i]:
            # Spatial fit metric: How well the item fits into the bin
            spatial_fit = item / bins[i]
            
            # Future potential metric: How well remaining capacity matches optimal pattern
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining[i]) / (bins[i] * 0.1))
            
            # Utilization bonus: Prefer bins that are well-utilized but not overly full
            utilization_bonus = np.minimum((bins[i] - remaining[i]) / bins[i], 0.9)
            
            # Combine metrics with adaptive weights
            total_score = (
                weight_spatial * spatial_fit +
                weight_future * future_potential +
                weight_util * utilization_bonus
            )
            
            # Apply dynamic adjustment based on global bin state
            global_usage = np.mean(bins - remaining) / np.mean(bins)
            if global_usage > 0.7:
                total_score *= 1.2
            
            priorities[i] = total_score
        else:
            # If bin cannot fit the item, assign a very low priority
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority function for online bin-packing with novel strategy.
    
    This version implements an "Adaptive Lookahead" strategy that:
    1. Combines spatial fit with future packing potential using dynamic weights
    2. Incorporates item size categorization for adaptive bin matching
    3. Implements dynamic threshold adjustments based on bin state
    4. Uses a diversity bonus to encourage balanced bin usage
    
    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.
    
    Return:
        Array of same size as bins with priority score of each bin.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    
    # Initialize priority array
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Get tunable parameters
    spatial_fit_base_weight = 0.5
    future_potential_base_weight = 0.4
    utilization_bonus_base_weight = 0.3
    fragmentation_penalty_base_weight = 0.3
    
    # Dynamic weight adjustment based on global bin state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > 0.7:
        spatial_fit_weight = spatial_fit_base_weight * 0.95
        future_potential_weight = future_potential_base_weight * 1.1
    else:
        spatial_fit_weight = spatial_fit_base_weight * 1.1
        future_potential_weight = future_potential_base_weight * 0.9
    
    utilization_bonus_weight = utilization_bonus_base_weight
    fragmentation_penalty_weight = fragmentation_penalty_base_weight
    
    # Item categorization for adaptive bin matching
    item_category = 'small' if item < 0.3 * np.max(bins) else\
                   'medium' if item < 0.5 * np.max(bins) else 'large'
    
    for i in range(n_bins):
        if valid_bins[i]:
            # Spatial fit metric
            spatial_fit = item / bins[i]
            
            # Future potential metric with adaptive lookahead
            optimal_remaining = 0.5 * bins[i]
            future_potential = np.exp(-np.abs(remaining[i] - optimal_remaining) / (bins[i] * 0.2))
            
            # Utilization bonus
            utilization = (bins[i] - remaining[i]) / bins[i]
            ideal_utilization = 0.8
            utilization_bonus = 1 - np.abs(utilization - ideal_utilization)
            
            # Fragmentation penalty
            fragmentation_threshold = 0.3 * bins[i]
            fragmentation_penalty = 0
            if remaining[i] < fragmentation_threshold:
                fragmentation_penalty = 1 - (remaining[i] / bins[i])
            
            # Apply item category-specific weights
            if item_category == 'small':
                spatial_fit *= 1.3
                future_potential *= 0.8
            elif item_category == 'large':
                spatial_fit *= 0.8
                future_potential *= 1.3
            
            # Combine metrics with adaptive weights
            total_score = (
                spatial_fit_weight * spatial_fit +
                future_potential_weight * future_potential +
                utilization_bonus_weight * utilization_bonus -
                fragmentation_penalty_weight * fragmentation_penalty
            )
            
            priorities[i] = total_score
        else:
            priorities[i] = -np.inf
    
    # Apply diversity bonus to encourage balanced bin usage
    diversity_bonus = 0.1 * np.std(priorities)
    priorities += diversity_bonus
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing.
    
    This function calculates the priority score for placing an item into each bin,
    considering both spatial fit and future packing potential. It uses tunable
    parameters to allow for dynamic adjustments.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    # Calculate remaining capacities and valid bins
    remaining = bins - item
    valid_bins = remaining > 0
    
    # Initialize priority array
    priorities = np.zeros_like(bins, dtype=np.float64)
    
    # Spatial fit metric: item / bin, scaled by tunable weight
    spatial_fit_weight = 0.7
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    
    # Future potential metric: remaining / bin, scaled by tunable weight
    future_potential_weight = 0.3
    future_potential = (remaining / bins) * future_potential_weight
    
    # Utilization bonus: preference for bins near ideal utilization
    ideal_utilization = 0.8
    utilization_bonus_weight = 0.2
    used = bins - remaining
    utilization = used / bins
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))
    
    # Fragmentation penalty: penalize very small remaining capacities
    fragmentation_threshold = 0.3
    fragmentation_penalty_weight = 0.1
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold * bins,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )
    
    # Combine metrics into priority score
    priorities = spatial_fit + (1 - future_potential) + utilization_bonus + fragmentation_penalty
    
    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


request...
----------------------------------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and introduces a novel lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)
    
    # Calculate dynamic parameters based on current state
    average_item_size = 0.7 * np.mean(bins)
    global_usage = np.mean((bins - remaining) / bins)
    
    # Tunable parameters with dynamic adjustments
    spatial_fit_weight = 0.75
    future_potential_weight = 0.4
    utilization_bonus_weight = 0.4
    fragmentation_penalty_weight = 0.15
    diversity_bonus_weight = 0.07
    
    # Dynamic thresholds
    fragmentation_threshold = 0.45 * bins
    ideal_remaining = 0.35 * bins
    
    # 1. Calculate spatial fit with dynamic normalization
    spatial_fit = (item / (bins + 1e-4)) * spatial_fit_weight
    
    # 2. Calculate future potential with lookahead heuristic
    # Prioritize bins that leave space close to the average item size
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.2)) * future_potential_weight
    
    # 3. Calculate utilization bonus
    utilization = (bins - remaining) / bins
    utilization_bonus = utilization_bonus_weight * (1 - np.abs(utilization - 0.75))
    
    # 4. Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )
    
    # 5. Calculate diversity bonus to encourage balanced bin usage
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    
    # 6. Combine metrics into priority score with dynamic weight adjustments
    priorities = (
        spatial_fit +
        future_potential +
        utilization_bonus +
        fragmentation_penalty +
        diversity_bonus
    )
    
    # Apply dynamic weight adjustments based on global usage
    if global_usage > 0.65:
        priorities *= 1.05
    
    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')
    
    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------
-----------------------

-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6])
    utilization_bonus_weight = tunable([0.6, 0.7])
    fragmentation_penalty_weight = tunable([0.2, 0.3])
    diversity_bonus_weight = tunable([0.1, 0.15])
    
    target_ratio = tunable([0.6, 0.7])
    ideal_utilization = tunable([0.8, 0.85])
    fragmentation_threshold = tunable([0.2, 0.3]) * bins
    average_item_size = tunable([0.5, 0.6]) * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization bonus with adaptive ideal utilization
    utilization = (bins - remaining) / bins
    utilization_score = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = tunable([2, 3])
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + tunable([0.05, 0.1])) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.15

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 63
-------------------


current thread_i 1
.
launch 64 evaluate tasks
current thread_i 8
current thread_i 9
current thread_i 0
current thread_i 2
current thread_i 4
current thread_i 6
this best socre: -209.15; best score: -209.15; global score: -208.9; space size: 3072; measure cnt: 64
....
launch 64 evaluate tasks
current thread_i 7
this best socre: -209.15; best score: -209.15; global score: -208.9; space size: 3072; measure cnt: 128
....
launch 64 evaluate tasks
current thread_i 5
this best socre: -209.05; best score: -209.05; global score: -208.9; space size: 3072; measure cnt: 192
..........
launch 64 evaluate tasks
this best socre: -209.05; best score: -209.05; global score: -208.9; space size: 3072; measure cnt: 256
.......
launch 64 evaluate tasks
this best socre: -209.05; best score: -209.05; global score: -208.9; space size: 3072; measure cnt: 320
......
launch 64 evaluate tasks
this best socre: -209.05; best score: -209.05; global score: -208.9; space size: 3072; measure cnt: 384
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.3, 0.4])
    fragmentation_penalty_weight = tunable([0.1, 0.15])
    diversity_bonus_weight = tunable([0.05, 0.1])
    
    ideal_fill_level = tunable([0.7, 0.8, 0.85])
    ideal_remaining = tunable([0.2, 0.3, 0.4]) * bins
    fragmentation_threshold = tunable([0.2, 0.25, 0.3]) * bins
    lookahead_depth = tunable([2, 3, 4])
    diversity_multiplier = tunable([0.2, 0.25, 0.3])

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - ideal_fill_level)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with lookahead
    future_potential = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_items = [item * (1 + tunable([0.05, 0.1, 0.15])) for _ in range(lookahead_depth)]
            future_valid = np.zeros(n_bins)
            for next_item in next_items:
                future_remaining = simulated_bins - next_item
                future_valid += future_remaining > 0
            future_potential[i] = np.mean(future_valid) / lookahead_depth
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - tunable([0.7, 0.8, 0.85])))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 64
-------------------



launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -208.9; space size: 157464; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -208.9; space size: 157464; measure cnt: 128

launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -208.9; space size: 157464; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.6; best score: -212.6; global score: -208.9; space size: 157464; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments, lookahead, and tunable parameters."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.7, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.4])
    utilization_weight = tunable([0.3, 0.25, 0.35])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.05])
    diversity_bonus_weight = tunable([0.05, 0.07, 0.03])
    lookahead_depth = tunable([2, 3, 1])
    target_ratio = tunable([0.5, 0.6, 0.4])

    target_remaining = target_ratio * bins
    ideal_utilization = tunable([0.85, 0.8, 0.9])
    fragmentation_threshold = tunable([0.2, 0.15, 0.25]) * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive lookahead
    future_potential = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1 + j * 0.05) for j in range(lookahead_depth)]
            avg_valid = 0
            for future_item in future_items:
                future_remaining = simulated_bins - future_item
                avg_valid += np.mean(future_remaining > 0)
            avg_valid /= lookahead_depth
            future_potential[i] = np.exp(-np.abs(remaining[i] - target_remaining[i]) / (bins[i] * 0.2)) * avg_valid
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 65
-------------------



launch 64 evaluate tasks
this best socre: -213.05; best score: -213.05; global score: -208.9; space size: 19683; measure cnt: 64
...
launch 64 evaluate tasks
this best socre: -210.15; best score: -210.15; global score: -208.9; space size: 19683; measure cnt: 128
...........
launch 64 evaluate tasks
this best socre: -210.15; best score: -210.15; global score: -208.9; space size: 19683; measure cnt: 192
.....
launch 64 evaluate tasks
this best socre: -210.1; best score: -210.1; global score: -208.9; space size: 19683; measure cnt: 256
......
launch 64 evaluate tasks
this best socre: -210.1; best score: -210.1; global score: -208.9; space size: 19683; measure cnt: 320
......
launch 64 evaluate tasks
this best socre: -210.1; best score: -210.1; global score: -208.9; space size: 19683; measure cnt: 384
....
launch 64 evaluate tasks
this best socre: -210.1; best score: -210.1; global score: -208.9; space size: 19683; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with novel hybrid approach.
    
    This function implements a "Hybrid Spatial-Future Balance" strategy that:
    1. Combines spatial fit with future packing potential
    2. Uses dynamic weight adjustments based on bin state
    3. Implements diversity bonuses and fragmentation penalties
    4. Includes lookahead heuristics for improved packing efficiency
    5. Adds tunable parameters for strategic decisions
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with default values and options
    spatial_fit_weight = tunable([0.6, 0.7, 0.8], default=0.7)
    future_potential_weight = tunable([0.3, 0.4, 0.5], default=0.4)
    utilization_weight = tunable([0.2, 0.3, 0.4], default=0.3)
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2], default=0.15)
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15], default=0.1)
    
    target_ratio = tunable([0.5, 0.6, 0.7], default=0.6)
    target_remaining_ratio = tunable([0.3, 0.4, 0.5], default=0.4)
    ideal_utilization = tunable([0.7, 0.75, 0.8], default=0.75)
    fragmentation_threshold = tunable([0.2, 0.25, 0.3], default=0.25)
    
    lookahead_depth = tunable([2, 3, 4], default=3)
    lookahead_bonus_weight = tunable([0.1, 0.15, 0.2], default=0.15)

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold * bins,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Simulate next items based on tunable distribution
            next_item_sizes = [
                item * tunable([1.0, 1.05, 1.1], default=1.05) 
                for _ in range(lookahead_depth)
            ]
            future_valid = np.zeros_like(simulated_bins, dtype=bool)
            for size in next_item_sizes:
                future_remaining = simulated_bins - size
                future_valid |= future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * lookahead_bonus_weight

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 66
-------------------


................................................................
launch 1 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.9; space size: 1.0; measure cnt: 1
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])
    lookahead_depth = tunable([1, 2, 3])
    target_utilization = tunable([0.7, 0.75, 0.8])
    fragmentation_threshold = tunable([0.2, 0.25, 0.3]) * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    target_ratio = target_utilization * bins
    spatial_fit[valid_bins] = np.exp(-np.abs(item / bins[valid_bins] - target_ratio[valid_bins]) / (0.1 * bins[valid_bins]))
    spatial_fit_score = spatial_fit_weight * spatial_fit

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_ratio) / (0.2 * bins))
    future_potential_score = future_potential_weight * future_potential

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - target_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * (1 + tunable([0.05, 0.1, 0.15]))
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * tunable([0.1, 0.15, 0.2])

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 67
-------------------



launch 64 evaluate tasks
this best socre: -214.45; best score: -214.45; global score: -208.9; space size: 59049; measure cnt: 64
.......
launch 64 evaluate tasks
this best socre: -213.6; best score: -213.6; global score: -208.9; space size: 59049; measure cnt: 128
..........................
launch 64 evaluate tasks
this best socre: -213.6; best score: -213.6; global score: -208.9; space size: 59049; measure cnt: 192
........................
launch 64 evaluate tasks
this best socre: -213.5; best score: -213.5; global score: -208.9; space size: 59049; measure cnt: 256
....
launch 64 evaluate tasks
this best socre: -212.7; best score: -212.7; global score: -208.9; space size: 59049; measure cnt: 320
..
launch 64 evaluate tasks
this best socre: -212.7; best score: -212.7; global score: -208.9; space size: 59049; measure cnt: 384
...............
launch 64 evaluate tasks
this best socre: -212.7; best score: -212.7; global score: -208.9; space size: 59049; measure cnt: 448
......
launch 64 evaluate tasks
this best socre: -212.7; best score: -212.7; global score: -208.9; space size: 59049; measure cnt: 512
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments, lookahead, and distribution balancing."""
    
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1])
    balance_bonus_weight = tunable([0.05, 0.1])
    
    target_ratio = tunable([0.5, 0.6])
    target_remaining_ratio = tunable([0.4, 0.5])
    ideal_utilization = tunable([0.85, 0.9])
    fragmentation_threshold_ratio = tunable([0.2, 0.3])
    lookahead_depth = tunable([2, 3])

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * tunable([1.05, 1.1])
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * tunable([0.15, 0.2])

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = tunable([0.1, 0.2]) * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 68
-------------------



launch 64 evaluate tasks
this best socre: -209.5; best score: -209.5; global score: -208.9; space size: 55296; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.2; best score: -209.2; global score: -208.9; space size: 55296; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.2; best score: -209.2; global score: -208.9; space size: 55296; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.2; best score: -209.2; global score: -208.9; space size: 55296; measure cnt: 256

launch 64 evaluate tasks
this best socre: -209.2; best score: -209.2; global score: -208.9; space size: 55296; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.85, 0.9])
    future_potential_weight = tunable([0.5, 0.55, 0.6])
    utilization_weight = tunable([0.3, 0.35, 0.4])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.075, 0.1])
    
    target_ratio = tunable([0.5, 0.6])
    target_remaining = tunable([0.5, 0.6]) * bins
    ideal_utilization = tunable([0.85, 0.9])
    fragmentation_threshold = tunable([0.2, 0.25]) * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = tunable([2, 3])
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Simulate next 'lookahead_depth' items
            future_items = [item * (1 + j * 0.05) for j in range(1, lookahead_depth + 1)]
            future_valid = np.zeros_like(simulated_bins, dtype=bool)
            for future_item in future_items:
                future_remaining = simulated_bins - future_item
                future_valid |= future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Apply dynamic weight adjustments based on global state
    global_usage = np.mean((bins - remaining) / bins)
    if global_usage > tunable([0.65, 0.7]):
        priorities *= 1.05

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 69
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.9; space size: 15552; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.9; space size: 15552; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.9; space size: 15552; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments, lookahead, and novel fit metrics."""
    
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.9, 0.7])
    future_potential_weight = tunable([0.5, 0.6, 0.4])
    utilization_weight = tunable([0.3, 0.4, 0.2])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.05])
    diversity_bonus_weight = tunable([0.05, 0.075, 0.025])
    lookahead_depth = tunable([2, 3, 4])
    ideal_utilization = tunable([0.85, 0.9, 0.8])
    fragmentation_threshold = tunable([0.2, 0.25, 0.15]) * bins

    # Calculate spatial fit score
    target_ratio = tunable([0.5, 0.6, 0.4])
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    expected_future_item = tunable([0.3, 0.4, 0.2])
    future_potential = np.exp(-np.abs(remaining - ideal_utilization * bins) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1 + tunable([0.05, 0.1, 0.025])) for _ in range(lookahead_depth)]
            success = 0
            for future_item in future_items:
                if np.any(simulated_bins >= future_item):
                    success += 1
            lookahead_bonus[i] = success * tunable([0.15, 0.2, 0.1])

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 70
-------------------



launch 64 evaluate tasks
this best socre: -211.25; best score: -211.25; global score: -208.9; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -211.25; best score: -211.25; global score: -208.9; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -211.25; best score: -211.25; global score: -208.9; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
this best socre: -211.25; best score: -211.25; global score: -208.9; space size: 531441; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority function for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.9, 0.7])
    future_potential_weight = tunable([0.5, 0.6, 0.4])
    utilization_weight = tunable([0.3, 0.25, 0.35])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.05])
    diversity_bonus_weight = tunable([0.05, 0.075, 0.025])
    lookahead_depth = tunable([2, 3, 1])
    
    target_ratio = tunable([0.5, 0.6, 0.4])
    target_remaining = target_ratio * bins
    ideal_utilization = tunable([0.85, 0.8, 0.9])
    fragmentation_threshold = tunable([0.2, 0.25, 0.15]) * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * (1 + tunable([0.05, 0.1, 0.025]))
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * tunable([0.15, 0.2, 0.1])

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Dynamic adjustment based on global bin state
    global_usage = np.mean(bins - remaining) / np.mean(bins)
    dynamic_weight = tunable([1.2, 1.3, 1.1]) if global_usage > tunable([0.7, 0.65, 0.75]) else 1.0

    # Combine metrics into priority score
    total_score = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    ) * dynamic_weight

    # Ensure invalid bins have infinite priority (lowest preference)
    total_score[~valid_bins] = float('inf')

    return total_score

call llm times: 71
-------------------



launch 64 evaluate tasks
this best socre: -210.7; best score: -210.7; global score: -208.9; space size: 1594323; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.65; best score: -209.65; global score: -208.9; space size: 1594323; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.65; best score: -209.65; global score: -208.9; space size: 1594323; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.65; best score: -209.65; global score: -208.9; space size: 1594323; measure cnt: 256

launch 64 evaluate tasks
this best socre: -209.65; best score: -209.65; global score: -208.9; space size: 1594323; measure cnt: 320
sampler suggest should end sample, break
request...
-----------------------request...


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments, lookahead, and distribution balancing."""
    
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = 0.7
    future_potential_weight = 0.7
    utilization_weight = 0.5
    fragmentation_penalty_weight = 0.2
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.1
    
    target_ratio = 0.6
    target_remaining_ratio = 0.4
    ideal_utilization = 0.9
    fragmentation_threshold_ratio = 0.3
    lookahead_depth = 3

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------request...


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_bonus_weight = 0.6
    fragmentation_penalty_weight = 0.3
    diversity_bonus_weight = 0.15
    
    target_ratio = 0.7
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins
    average_item_size = 0.5 * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization bonus with adaptive ideal utilization
    utilization = (bins - remaining) / bins
    utilization_score = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.15

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_bonus_weight = 0.6
    fragmentation_penalty_weight = 0.3
    diversity_bonus_weight = 0.15
    
    target_ratio = 0.7
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins
    average_item_size = 0.5 * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization bonus with adaptive ideal utilization
    utilization = (bins - remaining) / bins
    utilization_score = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.15

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_bonus_weight = 0.6
    fragmentation_penalty_weight = 0.3
    diversity_bonus_weight = 0.15
    
    target_ratio = 0.7
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins
    average_item_size = 0.5 * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization bonus with adaptive ideal utilization
    utilization = (bins - remaining) / bins
    utilization_score = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.15

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_bonus_weight = 0.6
    fragmentation_penalty_weight = 0.3
    diversity_bonus_weight = 0.15
    
    target_ratio = 0.7
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins
    average_item_size = 0.5 * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization bonus with adaptive ideal utilization
    utilization = (bins - remaining) / bins
    utilization_score = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.15

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments, lookahead, and distribution balancing."""
    
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = 0.7
    future_potential_weight = 0.7
    utilization_weight = 0.5
    fragmentation_penalty_weight = 0.2
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.1
    
    target_ratio = 0.6
    target_remaining_ratio = 0.4
    ideal_utilization = 0.9
    fragmentation_threshold_ratio = 0.3
    lookahead_depth = 3

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments, lookahead, and distribution balancing."""
    
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = 0.7
    future_potential_weight = 0.7
    utilization_weight = 0.5
    fragmentation_penalty_weight = 0.2
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.1
    
    target_ratio = 0.6
    target_remaining_ratio = 0.4
    ideal_utilization = 0.9
    fragmentation_threshold_ratio = 0.3
    lookahead_depth = 3

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_bonus_weight = 0.6
    fragmentation_penalty_weight = 0.3
    diversity_bonus_weight = 0.15
    
    target_ratio = 0.7
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins
    average_item_size = 0.5 * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization bonus with adaptive ideal utilization
    utilization = (bins - remaining) / bins
    utilization_score = utilization_bonus_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.15

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments, lookahead, and distribution balancing."""
    
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = 0.7
    future_potential_weight = 0.7
    utilization_weight = 0.5
    fragmentation_penalty_weight = 0.2
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.1
    
    target_ratio = 0.6
    target_remaining_ratio = 0.4
    ideal_utilization = 0.9
    fragmentation_threshold_ratio = 0.3
    lookahead_depth = 3

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    target_remaining = 0.5 * bins
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * 1.05
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.7, 0.9])
    future_potential_weight = tunable([0.5, 0.4, 0.6])
    utilization_weight = tunable([0.3, 0.25, 0.35])
    fragmentation_penalty_weight = tunable([0.1, 0.05, 0.15])
    diversity_bonus_weight = tunable([0.05, 0.03, 0.07])
    
    target_ratio_base = tunable([0.5, 0.6])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.1, 0.2])
    ideal_utilization = tunable([0.85, 0.8, 0.9])
    fragmentation_threshold = tunable([0.2, 0.15, 0.25]) * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.5, 0.6, 0.4]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.25])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**tunable([1, 2])

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = tunable([2, 3])
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + tunable([0.05, 0.03, 0.07]) * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.15, 0.1, 0.2])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 72
-------------------



current thread_i 0
launch 64 evaluate tasks
current thread_i 9
this best socre: -208.1; best score: -208.1; global score: -208.1; space size: 1889568; measure cnt: 64

launch 64 evaluate tasks
current thread_i 1
this best socre: -208.1; best score: -208.1; global score: -208.1; space size: 1889568; measure cnt: 128

launch 64 evaluate tasks
current thread_i 7
current thread_i 2
current thread_i 6
current thread_i 4
current thread_i 5
this best socre: -208.1; best score: -208.1; global score: -208.1; space size: 1889568; measure cnt: 192

launch 64 evaluate tasks
current thread_i 8
this best socre: -208.1; best score: -208.1; global score: -208.1; space size: 1889568; measure cnt: 256
sampler suggest should end sample, break
INFO:absl:Best score increased to -208.1
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters wrapped with tunable()
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.2, 0.3])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])
    
    target_ratio = tunable([0.5, 0.6, 0.7])
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold = tunable([0.2, 0.25, 0.3]) * bins
    average_item_size = tunable([0.5, 0.6, 0.7]) * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * tunable([0.2, 0.25, 0.3])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = tunable([2, 3, 4])
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + tunable([0.05, 0.1, 0.15])) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.15, 0.2])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 73
-------------------



launch 64 evaluate tasks
this best socre: -209.3; best score: -209.3; global score: -208.1; space size: 1594323; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.1; best score: -209.1; global score: -208.1; space size: 1594323; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.1; best score: -209.1; global score: -208.1; space size: 1594323; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.1; best score: -209.1; global score: -208.1; space size: 1594323; measure cnt: 256

launch 64 evaluate tasks
this best socre: -209.1; best score: -209.1; global score: -208.1; space size: 1594323; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Dynamic tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8])
    future_potential_weight = tunable([0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4])
    fragmentation_penalty_weight = tunable([0.1, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1])
    
    target_ratio = tunable([0.5, 0.6])
    ideal_utilization = tunable([0.8, 0.85])
    fragmentation_threshold = tunable([0.2, 0.25]) * bins
    average_item_size = tunable([0.4, 0.5]) * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = tunable([2, 3])
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + tunable([0.05, 0.1])) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.15, 0.2])

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 74
-------------------



launch 64 evaluate tasks
this best socre: -208.75; best score: -208.75; global score: -208.1; space size: 4096; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -208.75; best score: -208.75; global score: -208.1; space size: 4096; measure cnt: 128
.......
launch 64 evaluate tasks
this best socre: -208.75; best score: -208.75; global score: -208.1; space size: 4096; measure cnt: 192
.....
launch 64 evaluate tasks
this best socre: -208.75; best score: -208.75; global score: -208.1; space size: 4096; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.7, 0.9])
    future_potential_weight = tunable([0.5, 0.4, 0.6])
    utilization_weight = tunable([0.3, 0.25, 0.35])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.05])
    diversity_bonus_weight = tunable([0.05, 0.07, 0.03])
    
    target_ratio = tunable([0.5, 0.6, 0.4])
    target_remaining = tunable([0.5 * bins, 0.6 * bins, 0.4 * bins])
    ideal_utilization = tunable([0.85, 0.8, 0.9])
    fragmentation_threshold = tunable([0.2 * bins, 0.25 * bins, 0.15 * bins])

    # Calculate spatial fit score
    def calculate_spatial_fit():
        spatial_fit = np.full_like(bins, np.nan)
        spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
        return (1 - spatial_fit) * spatial_fit_weight

    spatial_fit_score = calculate_spatial_fit()

    # Calculate future potential score
    def calculate_future_potential():
        future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.25, 0.15])))
        return future_potential * future_potential_weight

    future_potential_score = calculate_future_potential()

    # Calculate utilization score
    def calculate_utilization_score():
        utilization = (bins - remaining) / bins
        return utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    utilization_score = calculate_utilization_score()

    # Calculate fragmentation penalty
    def calculate_fragmentation_penalty():
        return np.where(
            remaining < fragmentation_threshold,
            fragmentation_penalty_weight * (1 - (remaining / bins)),
            0
        )

    fragmentation_penalty = calculate_fragmentation_penalty()

    # Lookahead heuristic: simulate placing the item and assess future impact
    def calculate_lookahead_bonus():
        lookahead_depth = tunable([2, 3, 1])
        lookahead_bonus = np.zeros(n_bins)
        next_item_sizes = [item * (1 + tunable([0.05, 0.07, 0.03])) for _ in range(lookahead_depth)]
        for i in range(n_bins):
            if valid_bins[i]:
                simulated_bins = bins.copy()
                simulated_bins[i] -= item
                total_future_valid = 0
                for next_size in next_item_sizes:
                    future_remaining = simulated_bins - next_size
                    total_future_valid += np.sum(future_remaining > 0)
                lookahead_bonus[i] = total_future_valid * tunable([0.15, 0.1, 0.2])
        return lookahead_bonus

    lookahead_bonus = calculate_lookahead_bonus()

    # Calculate diversity bonus based on priority distribution
    def calculate_diversity_bonus():
        diversity_bonus = diversity_bonus_weight * np.std(priorities)
        return np.full_like(priorities, diversity_bonus)

    diversity_bonus = calculate_diversity_bonus()

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 75
-------------------



launch 64 evaluate tasks
this best socre: -209.3; best score: -209.3; global score: -208.1; space size: 1594323; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.3; best score: -209.3; global score: -208.1; space size: 1594323; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.3; best score: -209.3; global score: -208.1; space size: 1594323; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.25; best score: -209.25; global score: -208.1; space size: 1594323; measure cnt: 256

launch 64 evaluate tasks
this best socre: -209.25; best score: -209.25; global score: -208.1; space size: 1594323; measure cnt: 320

launch 64 evaluate tasks
this best socre: -209.25; best score: -209.25; global score: -208.1; space size: 1594323; measure cnt: 384

launch 64 evaluate tasks
this best socre: -209.25; best score: -209.25; global score: -208.1; space size: 1594323; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments, lookahead, and distribution balancing."""
    
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5, 0.6])
    fragmentation_penalty_weight = tunable([0.2, 0.3])
    diversity_bonus_weight = tunable([0.05, 0.1])
    lookahead_bonus_weight = tunable([0.1, 0.15])

    target_ratio = tunable([0.5, 0.6, 0.7])
    target_remaining_ratio = tunable([0.4, 0.5, 0.6])
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold_ratio = tunable([0.2, 0.3])
    lookahead_depth = tunable([2, 3, 4])

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic with tunable depth
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1.02 + 0.01*j) for j in range(lookahead_depth)]
            future_valid = np.zeros(lookahead_depth)
            for j, future_item in enumerate(future_items):
                future_remaining = simulated_bins - future_item
                future_valid[j] = np.sum(future_remaining > 0)
            lookahead_bonus[i] = np.mean(future_valid) * lookahead_bonus_weight

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 76
-------------------



launch 64 evaluate tasks
this best socre: -209.9; best score: -209.9; global score: -208.1; space size: 34992; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.9; best score: -209.9; global score: -208.1; space size: 34992; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -209.85; best score: -209.85; global score: -208.1; space size: 34992; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -209.85; best score: -209.85; global score: -208.1; space size: 34992; measure cnt: 256
.
launch 64 evaluate tasks
this best socre: -209.85; best score: -209.85; global score: -208.1; space size: 34992; measure cnt: 320

launch 64 evaluate tasks
this best socre: -209.6; best score: -209.6; global score: -208.1; space size: 34992; measure cnt: 384

launch 64 evaluate tasks
this best socre: -209.6; best score: -209.6; global score: -208.1; space size: 34992; measure cnt: 448
.
launch 64 evaluate tasks
this best socre: -209.6; best score: -209.6; global score: -208.1; space size: 34992; measure cnt: 512
..
launch 64 evaluate tasks
this best socre: -209.6; best score: -209.6; global score: -208.1; space size: 34992; measure cnt: 576
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments, lookahead, and distribution balancing."""
    
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1])
    balance_bonus_weight = tunable([0.1, 0.15])
    
    target_ratio = tunable([0.5, 0.6, 0.7])
    target_remaining_ratio = tunable([0.4, 0.5])
    ideal_utilization = tunable([0.8, 0.85])
    fragmentation_threshold_ratio = tunable([0.2, 0.3])
    lookahead_depth = tunable([2, 3])

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            next_item_size = item * tunable([1.02, 1.05])
            future_remaining = simulated_bins - next_item_size
            future_valid = future_remaining > 0
            lookahead_bonus[i] = np.sum(future_valid) * tunable([0.1, 0.15])

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = balance_bonus_weight * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 77
-------------------



launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -208.1; space size: 41472; measure cnt: 64
.................................
launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -208.1; space size: 41472; measure cnt: 128
.............................................
launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -208.1; space size: 41472; measure cnt: 192
..................................
launch 64 evaluate tasks
this best socre: -211.15; best score: -211.15; global score: -208.1; space size: 41472; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters using tunable wrapper
    spatial_fit_weight = tunable([0.8, 0.85, 0.9])
    future_potential_weight = tunable([0.5, 0.6])
    utilization_weight = tunable([0.3, 0.4])
    fragmentation_penalty_weight = tunable([0.1, 0.15])
    diversity_bonus_weight = tunable([0.05, 0.1])
    lookahead_bonus_weight = tunable([0.1, 0.15])

    target_ratio = tunable([0.5, 0.6])
    target_remaining_ratio = tunable([0.4, 0.5])
    ideal_utilization = tunable([0.85, 0.9])
    fragmentation_threshold_ratio = tunable([0.2, 0.3])
    lookahead_depth = tunable([2, 3])
    future_item_sizes = [item * (1 + i * 0.05) for i in range(lookahead_depth)]

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid_bins_nonzero = bins[valid_bins] > 0
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.3])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_valid_count = 0
            for future_size in future_item_sizes:
                future_remaining = simulated_bins - future_size
                future_valid = future_remaining > 0
                future_valid_count += np.sum(future_valid)
            lookahead_bonus[i] = (future_valid_count / len(future_item_sizes)) * lookahead_bonus_weight

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 78
-------------------



launch 64 evaluate tasks
this best socre: -212.4; best score: -212.4; global score: -208.1; space size: 6144; measure cnt: 64
.
launch 64 evaluate tasks
this best socre: -211.85; best score: -211.85; global score: -208.1; space size: 6144; measure cnt: 128
....
launch 64 evaluate tasks
this best socre: -211.55; best score: -211.55; global score: -208.1; space size: 6144; measure cnt: 192
.....
launch 64 evaluate tasks
this best socre: -211.55; best score: -211.55; global score: -208.1; space size: 6144; measure cnt: 256
.....
launch 64 evaluate tasks
this best socre: -211.55; best score: -211.55; global score: -208.1; space size: 6144; measure cnt: 320
...
launch 64 evaluate tasks
this best socre: -211.55; best score: -211.55; global score: -208.1; space size: 6144; measure cnt: 384
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    lookahead, and balance.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.7, 0.9])
    future_potential_weight = tunable([0.5, 0.4, 0.6])
    utilization_weight = tunable([0.3, 0.25, 0.35])
    fragmentation_penalty_weight = tunable([0.1, 0.05, 0.15])
    diversity_bonus_weight = tunable([0.05, 0.03, 0.07])
    balance_bonus_weight = tunable([0.1, 0.08, 0.12])
    lookahead_depth = tunable([2, 3, 4])
    
    target_ratio = tunable([0.5, 0.45, 0.55])
    target_remaining_ratio = tunable([0.5, 0.45, 0.55])
    ideal_utilization = tunable([0.85, 0.8, 0.9])
    fragmentation_threshold_ratio = tunable([0.2, 0.15, 0.25])
    diversity_threshold = tunable([0.1, 0.05, 0.15])

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))
    utilization_score = utilization_weight * (1 / (1 + np.exp(-10*(utilization - ideal_utilization))))  # Sigmoid

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1 + j*0.05) for j in range(lookahead_depth)]
            future_valid = np.zeros(lookahead_depth)
            for j, future_item in enumerate(future_items):
                future_remaining = simulated_bins - future_item
                future_valid[j] = np.sum(future_remaining > 0)
            lookahead_bonus[i] = np.mean(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 79
-------------------



launch 64 evaluate tasks
this best socre: -208.25; best score: -208.25; global score: -208.1; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -208.25; best score: -208.25; global score: -208.1; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -208.25; best score: -208.25; global score: -208.1; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
this best socre: -208.25; best score: -208.25; global score: -208.1; space size: 531441; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    and a lookahead heuristic for improved future packing potential.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.8, 0.85, 0.9])
    future_potential_weight = tunable([0.6, 0.7])
    utilization_weight = tunable([0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.15])
    diversity_bonus_weight = tunable([0.05, 0.1])
    
    target_ratio = tunable([0.5, 0.6])
    ideal_utilization = tunable([0.85, 0.9])
    fragmentation_threshold = tunable([0.2, 0.25]) * bins
    average_item_size = tunable([0.5, 0.6]) * bins

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    future_item_sizes = [item * (1 + 0.05 * i) for i in range(3)]  # Simulate next 3 items
    future_potential = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_valid = 0
            for size in future_item_sizes:
                future_remaining = simulated_bins - size
                total_valid += np.sum(future_remaining > 0)
            future_potential[i] = total_valid
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = tunable([2, 3])
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.15

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 80
-------------------


..
launch 64 evaluate tasks
this best socre: -215.3; best score: -215.3; global score: -208.1; space size: 1536; measure cnt: 64
..
launch 64 evaluate tasks
this best socre: -215.3; best score: -215.3; global score: -208.1; space size: 1536; measure cnt: 128
.............
launch 64 evaluate tasks
this best socre: -215.3; best score: -215.3; global score: -208.1; space size: 1536; measure cnt: 192
......
launch 64 evaluate tasks
this best socre: -215.3; best score: -215.3; global score: -208.1; space size: 1536; measure cnt: 256
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    lookahead, and balance.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.6
    utilization_weight = 0.35
    fragmentation_penalty_weight = 0.15
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.08
    lookahead_depth = 4
    
    target_ratio = 0.5
    target_remaining_ratio = 0.45
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.2
    diversity_threshold = 0.1

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))
    utilization_score = utilization_weight * (1 / (1 + np.exp(-10*(utilization - ideal_utilization))))  # Sigmoid

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1 + j*0.05) for j in range(lookahead_depth)]
            future_valid = np.zeros(lookahead_depth)
            for j, future_item in enumerate(future_items):
                future_remaining = simulated_bins - future_item
                future_valid[j] = np.sum(future_remaining > 0)
            lookahead_bonus[i] = np.mean(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    lookahead, and balance.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.6
    utilization_weight = 0.35
    fragmentation_penalty_weight = 0.15
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.08
    lookahead_depth = 4
    
    target_ratio = 0.5
    target_remaining_ratio = 0.45
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.2
    diversity_threshold = 0.1

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))
    utilization_score = utilization_weight * (1 / (1 + np.exp(-10*(utilization - ideal_utilization))))  # Sigmoid

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1 + j*0.05) for j in range(lookahead_depth)]
            future_valid = np.zeros(lookahead_depth)
            for j, future_item in enumerate(future_items):
                future_remaining = simulated_bins - future_item
                future_valid[j] = np.sum(future_remaining > 0)
            lookahead_bonus[i] = np.mean(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...
-----------------------request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    lookahead, and balance.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.6
    utilization_weight = 0.35
    fragmentation_penalty_weight = 0.15
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.08
    lookahead_depth = 4
    
    target_ratio = 0.5
    target_remaining_ratio = 0.45
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.2
    diversity_threshold = 0.1

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))
    utilization_score = utilization_weight * (1 / (1 + np.exp(-10*(utilization - ideal_utilization))))  # Sigmoid

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1 + j*0.05) for j in range(lookahead_depth)]
            future_valid = np.zeros(lookahead_depth)
            for j, future_item in enumerate(future_items):
                future_remaining = simulated_bins - future_item
                future_valid[j] = np.sum(future_remaining > 0)
            lookahead_bonus[i] = np.mean(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    lookahead, and balance.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.6
    utilization_weight = 0.35
    fragmentation_penalty_weight = 0.15
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.08
    lookahead_depth = 4
    
    target_ratio = 0.5
    target_remaining_ratio = 0.45
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.2
    diversity_threshold = 0.1

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))
    utilization_score = utilization_weight * (1 / (1 + np.exp(-10*(utilization - ideal_utilization))))  # Sigmoid

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1 + j*0.05) for j in range(lookahead_depth)]
            future_valid = np.zeros(lookahead_depth)
            for j, future_item in enumerate(future_items):
                future_remaining = simulated_bins - future_item
                future_valid[j] = np.sum(future_remaining > 0)
            lookahead_bonus[i] = np.mean(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Dynamic tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    ideal_utilization = 0.8
    fragmentation_threshold = 0.25 * bins
    average_item_size = 0.4 * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 3
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.1) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

request...
-----------------------
request...
import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    lookahead, and balance.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.6
    utilization_weight = 0.35
    fragmentation_penalty_weight = 0.15
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.08
    lookahead_depth = 4
    
    target_ratio = 0.5
    target_remaining_ratio = 0.45
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.2
    diversity_threshold = 0.1

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))
    utilization_score = utilization_weight * (1 / (1 + np.exp(-10*(utilization - ideal_utilization))))  # Sigmoid

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1 + j*0.05) for j in range(lookahead_depth)]
            future_valid = np.zeros(lookahead_depth)
            for j, future_item in enumerate(future_items):
                future_remaining = simulated_bins - future_item
                future_valid[j] = np.sum(future_remaining > 0)
            lookahead_bonus[i] = np.mean(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Dynamic tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    ideal_utilization = 0.8
    fragmentation_threshold = 0.25 * bins
    average_item_size = 0.4 * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 3
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.1) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    lookahead, and balance.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.6
    utilization_weight = 0.35
    fragmentation_penalty_weight = 0.15
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.08
    lookahead_depth = 4
    
    target_ratio = 0.5
    target_remaining_ratio = 0.45
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.2
    diversity_threshold = 0.1

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))
    utilization_score = utilization_weight * (1 / (1 + np.exp(-10*(utilization - ideal_utilization))))  # Sigmoid

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1 + j*0.05) for j in range(lookahead_depth)]
            future_valid = np.zeros(lookahead_depth)
            for j, future_item in enumerate(future_items):
                future_remaining = simulated_bins - future_item
                future_valid[j] = np.sum(future_remaining > 0)
            lookahead_bonus[i] = np.mean(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Dynamic tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio = 0.5
    ideal_utilization = 0.8
    fragmentation_threshold = 0.25 * bins
    average_item_size = 0.4 * bins

    # Calculate spatial fit with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with lookahead heuristic
    future_potential = np.exp(-np.abs(remaining - average_item_size) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))

    # Calculate fragmentation penalty
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic: simulate placing the item and assess future impact
    lookahead_depth = 3
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.1) for _ in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.6, 0.7])
    utilization_weight = tunable([0.3, 0.35])
    fragmentation_penalty_weight = tunable([0.1, 0.15])
    diversity_bonus_weight = tunable([0.05, 0.1])
    lookahead_depth = tunable([2, 3, 4])
    balance_bonus_weight = tunable([0.08, 0.1])

    target_ratio_base = 0.6
    item_size_factor = tunable([0.1, 0.15])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor
    ideal_utilization = tunable([0.8, 0.85])
    fragmentation_threshold_ratio = tunable([0.15, 0.2])
    diversity_threshold = tunable([0.1, 0.15])

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = tunable([0.45, 0.5]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.3])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**tunable([1, 2])

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + tunable([0.05, 0.1]) * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.15])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = balance_bonus_weight * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 81
-------------------



current thread_i 4
launch 64 evaluate tasks
current thread_i 1
current thread_i 7
current thread_i 5
current thread_i 6
this best socre: -209.6; best score: -209.6; global score: -208.1; space size: 147456; measure cnt: 64

launch 64 evaluate tasks
current thread_i 0
current thread_i 8
current thread_i 2
this best socre: -208.8; best score: -208.8; global score: -208.1; space size: 147456; measure cnt: 128

launch 64 evaluate tasks
this best socre: -208.8; best score: -208.8; global score: -208.1; space size: 147456; measure cnt: 192

launch 64 evaluate tasks
this best socre: -208.8; best score: -208.8; global score: -208.1; space size: 147456; measure cnt: 256

launch 64 evaluate tasks
current thread_i 9
this best socre: -208.8; best score: -208.8; global score: -208.1; space size: 147456; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with novel metrics and tunable parameters.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    lookahead, and balance with tunable parameters.

    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.

    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with dynamic selection
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])  # Weight for spatial fit score
    future_potential_weight = tunable([0.6, 0.7, 0.8])  # Weight for future potential score
    utilization_weight = tunable([0.3, 0.4, 0.5])  # Weight for utilization score
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15])  # Weight for fragmentation penalty
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])  # Weight for diversity bonus
    lookahead_depth = tunable([2, 3, 4])  # Number of future items to simulate
    balance_bonus_weight = tunable([0.08, 0.1, 0.12])  # Weight for balance bonus

    target_ratio_base = tunable([0.5, 0.6, 0.7])  # Base target ratio for spatial fit
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.1, 0.15, 0.2])  # Dynamic adjustment based on item size
    ideal_utilization = tunable([0.8, 0.85, 0.9])  # Target utilization for bins
    fragmentation_threshold_ratio = tunable([0.1, 0.15, 0.2])  # Threshold for fragmentation penalty
    diversity_threshold = tunable([0.05, 0.1, 0.15])  # Threshold for diversity bonus

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score with adaptive target remaining
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))
    utilization_score = utilization_weight * (1 / (1 + np.exp(-10*(utilization - ideal_utilization))))  # Sigmoid

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = balance_bonus_weight * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 82
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 531441; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.25, 0.3, 0.35])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1])
    balance_bonus_weight = tunable([0.05, 0.1])
    lookahead_depth = tunable([3, 4, 5])
    target_ratio_base = tunable([0.5, 0.6, 0.7])
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold_ratio = tunable([0.1, 0.15, 0.2])
    diversity_threshold = tunable([0.05, 0.1, 0.15])

    # Dynamic target ratio based on item size relative to bins
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.1, 0.15, 0.2])
    target_ratio = np.clip(target_ratio, 0.4, 0.8)  # Ensure reasonable range

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**tunable([1, 2, 3])) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.4, 0.5, 0.6]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.15, 0.2, 0.25])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**tunable([1, 2, 3])

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + tunable([0.03, 0.05, 0.07]) * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.15, 0.2])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = balance_bonus_weight * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 83
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 172186884; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 172186884; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 172186884; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with strategic options
    spatial_fit_weight = tunable([0.7, 0.8, 0.6])
    future_potential_weight = tunable([0.6, 0.7, 0.5])
    utilization_weight = tunable([0.3, 0.4, 0.2])
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.0])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.0])
    
    target_ratio_base = tunable([0.6, 0.5, 0.7])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.1, 0.2, 0.05])
    ideal_utilization = tunable([0.85, 0.8, 0.9])
    fragmentation_threshold = tunable([0.15, 0.2, 0.1]) * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.5, 0.6, 0.4]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.25, 0.15])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**tunable([2, 3, 1])

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = tunable([3, 2, 4])
    lookahead_bonus = np.zeros(n_bins)
    # Simulate future items with varying sizes based on current item
    next_item_sizes = [item * (1 + tunable([0.05, 0.1, 0.02]) * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.15, 0.05])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 84
-------------------



launch 64 evaluate tasks
this best socre: -208.35; best score: -208.35; global score: -208.1; space size: 14348907; measure cnt: 64

launch 64 evaluate tasks
this best socre: -208.35; best score: -208.35; global score: -208.1; space size: 14348907; measure cnt: 128

launch 64 evaluate tasks
this best socre: -208.35; best score: -208.35; global score: -208.1; space size: 14348907; measure cnt: 192

launch 64 evaluate tasks
this best socre: -208.35; best score: -208.35; global score: -208.1; space size: 14348907; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with dynamic adjustments
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.3, 0.4])
    fragmentation_penalty_weight = tunable([0.05, 0.1])
    diversity_bonus_weight = tunable([0.05, 0.1])
    
    target_ratio_base = tunable([0.6, 0.7])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.1, 0.2])
    ideal_utilization = tunable([0.8, 0.85])
    fragmentation_threshold_multiplier = tunable([0.15, 0.2])
    fragmentation_threshold = fragmentation_threshold_multiplier * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining_base = tunable([0.5, 0.6]) * bins
    target_remaining = target_remaining_base + (item / np.mean(bins)) * tunable([0.1, 0.2]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.3])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**tunable([2, 3])

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes and increased depth
    lookahead_depth = tunable([3, 4])
    lookahead_bonus = np.zeros(n_bins)
    growth_rates = tunable([0.05, 0.1])
    next_item_sizes = [item * (1 + growth_rates * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.15])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 85
-------------------



launch 64 evaluate tasks
this best socre: -213.1; best score: -213.1; global score: -208.1; space size: 147456; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -208.1; space size: 147456; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -208.1; space size: 147456; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -208.1; space size: 147456; measure cnt: 256
.
launch 64 evaluate tasks
this best socre: -209.95; best score: -209.95; global score: -208.1; space size: 147456; measure cnt: 320
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Dynamic parameters based on item and bins
    item_ratio = item / np.mean(bins) if np.mean(bins) != 0 else 0
    state = [item_ratio, np.std(bins)/np.mean(bins) if np.mean(bins) != 0 else 0]

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9], state)
    future_potential_weight = tunable([0.6, 0.7, 0.8], state)
    utilization_weight = tunable([0.3, 0.4, 0.5], state)
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2], state)
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15], state)
    
    target_ratio_base = tunable([0.5, 0.6, 0.7], state)
    target_ratio = target_ratio_base + (item_ratio * tunable([0.1, 0.2, 0.3], state))
    ideal_utilization = tunable([0.8, 0.85, 0.9], state)
    fragmentation_threshold_ratio = tunable([0.1, 0.15, 0.2], state)
    lookahead_depth = tunable([2, 3, 4], state)

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score
    target_remaining = target_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 86
-------------------


................................................................
launch 1 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 1.0; measure cnt: 1
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.75, 0.8, 0.85])
    future_potential_weight = tunable([0.6, 0.65, 0.7])
    utilization_weight = tunable([0.3, 0.35, 0.4])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1])
    balance_bonus_weight = tunable([0.08, 0.1])
    lookahead_depth = tunable([3, 4, 5])
    adaptability_threshold = tunable([0.2, 0.25, 0.3])

    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.05, 0.1, 0.15])
    ideal_utilization = 0.85
    fragmentation_threshold = tunable([0.15, 0.2, 0.25]) * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.45, 0.5, 0.55]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.15, 0.2, 0.25])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**tunable([2, 3])

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes and adaptability
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + tunable([0.03, 0.05, 0.07]) * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.12, 0.15])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > tunable([0.08, 0.1, 0.12]), diversity_bonus, 0)

    # Calculate future adaptability score
    adaptability_scores = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Generate a range of possible future item sizes
            future_item_range = np.linspace(item * 0.8, item * 1.2, 10)
            adaptability = 0
            for future_item in future_item_range:
                future_remaining = simulated_bins - future_item
                adaptability += np.sum(future_remaining > 0) / len(future_remaining)
            adaptability_scores[i] = adaptability / len(future_item_range)
    adaptability_bonus = tunable([0.05, 0.1]) * (adaptability_scores / np.max(adaptability_scores))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        adaptability_bonus
    )

    # Apply dynamic weight adjustment based on current bin state
    current_utilization = np.mean(utilization)
    if current_utilization > tunable([0.7, 0.75]):
        utilization_weight = tunable([0.4, 0.45, 0.5])
        fragmentation_penalty_weight = tunable([0.15, 0.2, 0.25])
    else:
        utilization_weight = tunable([0.3, 0.35, 0.4])
        fragmentation_penalty_weight = tunable([0.1, 0.12, 0.15])

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 87
-------------------



launch 64 evaluate tasks
this best socre: -208.45; best score: -208.45; global score: -208.1; space size: 4132485216; measure cnt: 64

launch 64 evaluate tasks
this best socre: -208.45; best score: -208.45; global score: -208.1; space size: 4132485216; measure cnt: 128

launch 64 evaluate tasks
this best socre: -208.45; best score: -208.45; global score: -208.1; space size: 4132485216; measure cnt: 192

launch 64 evaluate tasks
this best socre: -208.45; best score: -208.45; global score: -208.1; space size: 4132485216; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with multiple options
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])
    lookahead_depth_base = tunable([2, 3, 4])
    
    target_ratio_base = tunable([0.5, 0.6, 0.7])
    target_remaining_ratio = tunable([0.4, 0.45, 0.5])
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold_ratio = tunable([0.1, 0.15, 0.2])
    diversity_threshold = tunable([0.05, 0.1, 0.15])

    # Dynamic target ratio based on item size relative to bins
    avg_bin = np.mean(bins) if n_bins > 0 else 1.0
    item_rel_size = item / avg_bin
    target_ratio = target_ratio_base + (item_rel_size - 0.5) * 0.2
    target_ratio = np.clip(target_ratio, 0.4, 0.7)

    # Calculate spatial fit score with dynamic target
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Future potential score with adaptive target remaining
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Fragmentation penalty with tunable threshold
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Dynamic lookahead depth based on item size
    lookahead_depth = int(lookahead_depth_base + item_rel_size * 2)
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 88
-------------------



launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 177147; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 177147; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 177147; measure cnt: 192
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.5, 0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.4, 0.5, 0.6])
    utilization_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15])
    diversity_bonus_weight = tunable([0.01, 0.02, 0.03])
    
    target_ratio_base = tunable([0.5, 0.6, 0.7])
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold_factor = tunable([0.1, 0.15, 0.2])
    lookahead_depth = tunable([2, 3, 4])
    next_item_size_growth = tunable([0.05, 0.1, 0.15])

    # Calculate spatial fit with dynamic target ratio
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential with adaptive target remaining
    average_item_size = np.mean(bins) * tunable([0.3, 0.4, 0.5])
    target_remaining = average_item_size * tunable([1.0, 1.5, 2.0])
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.25, 0.3])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_factor * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    growth_rate = next_item_size_growth
    next_item_sizes = [item * (1 + growth_rate * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.15, 0.2])

    # Calculate diversity bonus based on remaining capacity distribution
    if np.sum(valid_bins) > 0:
        diversity_bonus = diversity_bonus_weight * np.std(remaining[valid_bins])
    else:
        diversity_bonus = 0.0
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 89
-------------------



launch 64 evaluate tasks
this best socre: -209.25; best score: -209.25; global score: -208.1; space size: 6377292; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.25; best score: -209.25; global score: -208.1; space size: 6377292; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.25; best score: -209.25; global score: -208.1; space size: 6377292; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.25; best score: -209.25; global score: -208.1; space size: 6377292; measure cnt: 256
sampler suggest should end sample, break
request...
request...
-----------------------request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with strategic options
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.7
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.2
    ideal_utilization = 0.8
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.6 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 4
    lookahead_bonus = np.zeros(n_bins)
    # Simulate future items with varying sizes based on current item
    next_item_sizes = [item * (1 + 0.02 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.05

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------
request...

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with strategic options
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.7
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.2
    ideal_utilization = 0.8
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.6 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 4
    lookahead_bonus = np.zeros(n_bins)
    # Simulate future items with varying sizes based on current item
    next_item_sizes = [item * (1 + 0.02 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.05

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with strategic options
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.7
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.2
    ideal_utilization = 0.8
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.6 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 4
    lookahead_bonus = np.zeros(n_bins)
    # Simulate future items with varying sizes based on current item
    next_item_sizes = [item * (1 + 0.02 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.05

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.



-----------------------
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.75
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.1
    balance_bonus_weight = 0.1
    lookahead_depth = 5
    adaptability_threshold = 0.3

    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.45 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**3

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes and adaptability
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.03 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.12

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > 0.08, diversity_bonus, 0)

    # Calculate future adaptability score
    adaptability_scores = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Generate a range of possible future item sizes
            future_item_range = np.linspace(item * 0.8, item * 1.2, 10)
            adaptability = 0
            for future_item in future_item_range:
                future_remaining = simulated_bins - future_item
                adaptability += np.sum(future_remaining > 0) / len(future_remaining)
            adaptability_scores[i] = adaptability / len(future_item_range)
    adaptability_bonus = 0.05 * (adaptability_scores / np.max(adaptability_scores))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        adaptability_bonus
    )

    # Apply dynamic weight adjustment based on current bin state
    current_utilization = np.mean(utilization)
    if current_utilization > 0.7:
        utilization_weight = 0.45
        fragmentation_penalty_weight = 0.25
    else:
        utilization_weight = 0.4
        fragmentation_penalty_weight = 0.15

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
request...
----------------------------------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.75
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.1
    balance_bonus_weight = 0.1
    lookahead_depth = 5
    adaptability_threshold = 0.3

    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.45 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**3

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes and adaptability
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.03 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.12

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > 0.08, diversity_bonus, 0)

    # Calculate future adaptability score
    adaptability_scores = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Generate a range of possible future item sizes
            future_item_range = np.linspace(item * 0.8, item * 1.2, 10)
            adaptability = 0
            for future_item in future_item_range:
                future_remaining = simulated_bins - future_item
                adaptability += np.sum(future_remaining > 0) / len(future_remaining)
            adaptability_scores[i] = adaptability / len(future_item_range)
    adaptability_bonus = 0.05 * (adaptability_scores / np.max(adaptability_scores))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        adaptability_bonus
    )

    # Apply dynamic weight adjustment based on current bin state
    current_utilization = np.mean(utilization)
    if current_utilization > 0.7:
        utilization_weight = 0.45
        fragmentation_penalty_weight = 0.25
    else:
        utilization_weight = 0.4
        fragmentation_penalty_weight = 0.15

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
request...
-----------------------

-----------------------

request...
import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with strategic options
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.7
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.2
    ideal_utilization = 0.8
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.6 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 4
    lookahead_bonus = np.zeros(n_bins)
    # Simulate future items with varying sizes based on current item
    next_item_sizes = [item * (1 + 0.02 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.05

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.75
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.1
    balance_bonus_weight = 0.1
    lookahead_depth = 5
    adaptability_threshold = 0.3

    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.45 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**3

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes and adaptability
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.03 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.12

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > 0.08, diversity_bonus, 0)

    # Calculate future adaptability score
    adaptability_scores = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Generate a range of possible future item sizes
            future_item_range = np.linspace(item * 0.8, item * 1.2, 10)
            adaptability = 0
            for future_item in future_item_range:
                future_remaining = simulated_bins - future_item
                adaptability += np.sum(future_remaining > 0) / len(future_remaining)
            adaptability_scores[i] = adaptability / len(future_item_range)
    adaptability_bonus = 0.05 * (adaptability_scores / np.max(adaptability_scores))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        adaptability_bonus
    )

    # Apply dynamic weight adjustment based on current bin state
    current_utilization = np.mean(utilization)
    if current_utilization > 0.7:
        utilization_weight = 0.45
        fragmentation_penalty_weight = 0.25
    else:
        utilization_weight = 0.4
        fragmentation_penalty_weight = 0.15

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-----------------------

-----------------------
request...

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.35
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.1
    lookahead_depth = 4
    balance_bonus_weight = 0.08

    target_ratio_base = 0.6
    item_size_factor = 0.15
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.15
    diversity_threshold = 0.1

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = balance_bonus_weight * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


----------------------------------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.35
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.1
    lookahead_depth = 4
    balance_bonus_weight = 0.08

    target_ratio_base = 0.6
    item_size_factor = 0.15
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.15
    diversity_threshold = 0.1

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = balance_bonus_weight * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with suggested options
    spatial_fit_weight = tunable([0.75, 0.8, 0.85])
    future_potential_weight = tunable([0.6, 0.65, 0.7])
    utilization_weight = tunable([0.3, 0.35, 0.4])
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])
    lookahead_depth = tunable([2, 3, 4])
    adaptability_threshold = tunable([0.3, 0.35, 0.4])

    target_ratio_base = tunable([0.6, 0.65, 0.7])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.1, 0.15, 0.2])
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold = tunable([0.15, 0.2, 0.25]) * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.45, 0.5, 0.55]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.25, 0.3])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**3

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes and adaptability
    lookahead_bonus = np.zeros(n_bins)
    growth_rate = tunable([0.03, 0.05, 0.07])
    next_item_sizes = [item * (1 + growth_rate * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.12, 0.15])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > tunable([0.08, 0.1, 0.12]), diversity_bonus, 0)

    # Calculate future adaptability score
    adaptability_scores = np.zeros(n_bins)
    future_item_range = np.linspace(item * tunable([0.8, 0.85, 0.9]), 
                                   item * tunable([1.2, 1.3, 1.4]), 
                                   tunable([10, 15, 20]))
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            adaptability = 0
            for future_item in future_item_range:
                future_remaining = simulated_bins - future_item
                adaptability += np.sum(future_remaining > 0) / len(future_remaining)
            adaptability_scores[i] = adaptability / len(future_item_range)
    adaptability_bonus = tunable([0.05, 0.07, 0.1]) * (adaptability_scores / np.max(adaptability_scores))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        adaptability_bonus
    )

    # Apply dynamic weight adjustment based on current bin state
    current_utilization = np.mean(utilization)
    if current_utilization > tunable([0.7, 0.75, 0.8]):
        utilization_weight = tunable([0.45, 0.5, 0.55])
        fragmentation_penalty_weight = tunable([0.25, 0.3, 0.35])
    else:
        utilization_weight = tunable([0.4, 0.45, 0.5])
        fragmentation_penalty_weight = tunable([0.15, 0.2, 0.25])

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 90
-------------------


current thread_i 7

launch 64 evaluate tasks
current thread_i 2
current thread_i 0
current thread_i 9
current thread_i 4
current thread_i 8
current thread_i 1
this best socre: -209.0; best score: -209.0; global score: -208.1; space size: 847288609443; measure cnt: 64

launch 64 evaluate tasks
current thread_i 5
current thread_i 6
this best socre: -209.0; best score: -209.0; global score: -208.1; space size: 847288609443; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.0; best score: -209.0; global score: -208.1; space size: 847288609443; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.0; best score: -209.0; global score: -208.1; space size: 847288609443; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.6, 0.7])
    utilization_weight = tunable([0.3, 0.35])
    fragmentation_penalty_weight = tunable([0.05, 0.1])
    diversity_bonus_weight = tunable([0.05, 0.1])
    lookahead_depth = tunable([2, 3, 4])
    target_ratio_base = tunable([0.6, 0.65])
    item_size_factor = tunable([0.1, 0.15])
    ideal_utilization = tunable([0.8, 0.85])
    fragmentation_threshold_ratio = tunable([0.15, 0.2])
    diversity_threshold = tunable([0.1, 0.15])

    # Calculate spatial fit score with dynamic target ratio
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.4, 0.5, 0.6]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.15, 0.2])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    growth_factor = tunable([0.03, 0.05, 0.07])
    next_item_sizes = [item * (1 + growth_factor * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.08, 0.1])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 91
-------------------



launch 64 evaluate tasks
this best socre: -209.2; best score: -209.2; global score: -208.1; space size: 165888; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.2; best score: -209.2; global score: -208.1; space size: 165888; measure cnt: 128
.
launch 64 evaluate tasks
this best socre: -209.2; best score: -209.2; global score: -208.1; space size: 165888; measure cnt: 192
...
launch 64 evaluate tasks
this best socre: -208.95; best score: -208.95; global score: -208.1; space size: 165888; measure cnt: 256
.
launch 64 evaluate tasks
this best socre: -208.55; best score: -208.55; global score: -208.1; space size: 165888; measure cnt: 320
.
launch 64 evaluate tasks
this best socre: -208.55; best score: -208.55; global score: -208.1; space size: 165888; measure cnt: 384
.
launch 64 evaluate tasks
this best socre: -208.55; best score: -208.55; global score: -208.1; space size: 165888; measure cnt: 448

launch 64 evaluate tasks
this best socre: -208.55; best score: -208.55; global score: -208.1; space size: 165888; measure cnt: 512
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with multiple options
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.6, 0.7, 0.8])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])
    balance_bonus_weight = tunable([0.05, 0.1, 0.15])

    target_ratio_base = tunable([0.6, 0.65, 0.7])
    item_influence = tunable([0.1, 0.15, 0.2])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_influence
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold = tunable([0.15, 0.2, 0.25]) * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.45, 0.5, 0.55]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.25, 0.3])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization)) ** tunable([2, 3])

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes and adaptability
    lookahead_depth = tunable([2, 3, 4])
    lookahead_bonus = np.zeros(n_bins)
    growth_rates = tunable([0.03, 0.05, 0.07])
    next_item_sizes = [item * (1 + growth_rates * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.12, 0.15])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > tunable([0.08, 0.1, 0.12]), diversity_bonus, 0)

    # Calculate balance bonus to encourage even bin usage
    balance_bonus = balance_bonus_weight * np.exp(-np.abs(remaining - np.mean(remaining)) / (np.std(remaining) + 1e-8))
    balance_bonus = np.where(np.std(remaining) > tunable([0.1, 0.15, 0.2]), balance_bonus, 0)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Apply dynamic weight adjustment based on current bin state
    current_utilization = np.mean(utilization)
    if current_utilization > tunable([0.7, 0.75, 0.8]):
        utilization_weight = tunable([0.45, 0.5, 0.55])
        fragmentation_penalty_weight = tunable([0.2, 0.25, 0.3])
    else:
        utilization_weight = tunable([0.35, 0.4, 0.45])
        fragmentation_penalty_weight = tunable([0.15, 0.2, 0.25])

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 92
-------------------



launch 64 evaluate tasks
this best socre: -209.4; best score: -209.4; global score: -208.1; space size: 62762119218; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.2; best score: -209.2; global score: -208.1; space size: 62762119218; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.2; best score: -209.2; global score: -208.1; space size: 62762119218; measure cnt: 192

launch 64 evaluate tasks
this best socre: -208.7; best score: -208.7; global score: -208.1; space size: 62762119218; measure cnt: 256

launch 64 evaluate tasks
this best socre: -208.7; best score: -208.7; global score: -208.1; space size: 62762119218; measure cnt: 320

launch 64 evaluate tasks
this best socre: -208.7; best score: -208.7; global score: -208.1; space size: 62762119218; measure cnt: 384

launch 64 evaluate tasks
this best socre: -208.7; best score: -208.7; global score: -208.1; space size: 62762119218; measure cnt: 448
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with strategic options
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15])
    diversity_bonus_weight = tunable([0.03, 0.05, 0.07])
    
    target_ratio_base = tunable([0.6, 0.7, 0.8])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.1, 0.2, 0.3])
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold = tunable([0.15, 0.2, 0.25]) * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.5, 0.6, 0.7]) * bins
    decay_rate = tunable([0.2, 0.3, 0.4])
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * decay_rate))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with penalties for extremes
    utilization = (bins - remaining) / bins
    utilization_deviation = np.abs(utilization - ideal_utilization)
    utilization_score = utilization_weight * (1 - utilization_deviation**tunable([1, 2, 3]))

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = tunable([2, 3, 4])
    lookahead_bonus = np.zeros(n_bins)
    growth_rates = tunable([[0.02, 0.05], [0.03, 0.06], [0.04, 0.07]])
    next_item_sizes = [item * (1 + growth_rates[0] * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.05, 0.1, 0.15])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 93
-------------------



launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.1; space size: 28697814; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.1; space size: 28697814; measure cnt: 128

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.1; space size: 28697814; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.1; space size: 28697814; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with strategic options
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.6, 0.7, 0.8])
    utilization_weight = tunable([0.3, 0.4])
    fragmentation_penalty_weight = tunable([0.05, 0.1])
    diversity_bonus_weight = tunable([0.05, 0.1])
    
    target_ratio_base = tunable([0.6, 0.7])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.1, 0.2])
    ideal_utilization = tunable([0.8, 0.85])
    fragmentation_threshold = tunable([0.15, 0.2]) * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.5, 0.6]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.3])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = tunable([2, 3, 4])
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + tunable([0.05, 0.1]) * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.05, 0.1])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 94
-------------------



launch 64 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -208.1; space size: 55296; measure cnt: 64
...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 57 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -208.1; space size: 55296; measure cnt: 121
...............................................................................................................................................................................................................................................................................................
launch 15 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -208.1; space size: 55296; measure cnt: 136
..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
launch 50 evaluate tasks
this best socre: -210.25; best score: -210.25; global score: -208.1; space size: 55296; measure cnt: 186
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = tunable([0.7, 0.6, 0.8])
    future_potential_weight = tunable([0.6, 0.5, 0.7])
    utilization_weight = tunable([0.3, 0.25, 0.35])
    fragmentation_penalty_weight = tunable([0.1, 0.05, 0.15])
    diversity_bonus_weight = tunable([0.1, 0.05, 0.15])
    lookahead_depth = tunable([2, 3, 4])
    balance_bonus_weight = tunable([0.08, 0.05, 0.1])
    target_ratio_base = tunable([0.6, 0.55, 0.65])
    item_size_factor = tunable([0.15, 0.1, 0.2])
    ideal_utilization = tunable([0.85, 0.8, 0.9])
    fragmentation_threshold_ratio = tunable([0.15, 0.1, 0.2])
    diversity_threshold = tunable([0.1, 0.05, 0.15])

    # Calculate target ratio dynamically based on item size relative to mean bin capacity
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor

    # Spatial fit score calculation
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Future potential score calculation with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Utilization score calculation with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization)) ** 2

    # Fragmentation penalty calculation
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Diversity bonus calculation
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Balance bonus calculation
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = balance_bonus_weight * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine all scores into priority
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 95
-------------------



launch 64 evaluate tasks
this best socre: -209.35; best score: -209.35; global score: -208.1; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.35; best score: -209.35; global score: -208.1; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.35; best score: -209.35; global score: -208.1; space size: 531441; measure cnt: 192
.
launch 64 evaluate tasks
this best socre: -209.15; best score: -209.15; global score: -208.1; space size: 531441; measure cnt: 256

launch 64 evaluate tasks
this best socre: -209.15; best score: -209.15; global score: -208.1; space size: 531441; measure cnt: 320

launch 64 evaluate tasks
this best socre: -208.7; best score: -208.7; global score: -208.1; space size: 531441; measure cnt: 384

launch 64 evaluate tasks
this best socre: -208.7; best score: -208.7; global score: -208.1; space size: 531441; measure cnt: 448

launch 64 evaluate tasks
this best socre: -208.7; best score: -208.7; global score: -208.1; space size: 531441; measure cnt: 512

launch 64 evaluate tasks
this best socre: -208.7; best score: -208.7; global score: -208.1; space size: 531441; measure cnt: 576
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with strategic options
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])
    
    target_ratio_base = tunable([0.6, 0.7, 0.8])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.1, 0.15, 0.2])
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold = tunable([0.15, 0.2, 0.25]) * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.5, 0.6, 0.7]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.25, 0.3])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**tunable([2, 3])

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = tunable([3, 4, 5])
    lookahead_bonus = np.zeros(n_bins)
    growth_rates = tunable([[0.02, 0.03, 0.04], [0.03, 0.04, 0.05], [0.04, 0.05, 0.06]])
    next_item_sizes = [item * (1 + growth_rates[i] * (j+1)) for j in range(lookahead_depth) for i in range(lookahead_depth)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.05, 0.1, 0.15])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score with dynamic weights
    dynamic_weights = np.array([
        spatial_fit_weight,
        future_potential_weight,
        utilization_weight,
        fragmentation_penalty_weight,
        lookahead_bonus * tunable([1, 2, 3]),
        diversity_bonus
    ])
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Apply dynamic weights based on current bin state
    utilization_avg = np.mean(utilization)
    if utilization_avg < 0.6:
        priorities = priorities * np.array([1, 1, 1.5, 0.5, 1, 1])
    elif utilization_avg > 0.9:
        priorities = priorities * np.array([1, 1, 0.5, 1.5, 1, 1])

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 96
-------------------



launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.1; space size: 86093442; measure cnt: 64

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.1; space size: 86093442; measure cnt: 128

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.1; space size: 86093442; measure cnt: 192

launch 64 evaluate tasks
this best socre: -212.75; best score: -212.75; global score: -208.1; space size: 86093442; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = tunable([0.7, 0.75, 0.8], current_option=0.75)
    future_potential_weight = tunable([0.5, 0.6, 0.7], current_option=0.6)
    utilization_weight = tunable([0.3, 0.35, 0.4], current_option=0.35)
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15], current_option=0.1)
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15], current_option=0.05)
    adaptability_bonus_weight = tunable([0.02, 0.05, 0.1], current_option=0.05)

    target_ratio_base = tunable([0.5, 0.6, 0.7], current_option=0.6)
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.05, 0.1, 0.15], current_option=0.1)
    ideal_utilization = tunable([0.8, 0.85, 0.9], current_option=0.85)
    fragmentation_threshold = tunable([0.1, 0.15, 0.2], current_option=0.15) * bins
    lookahead_depth = tunable([2, 3, 4], current_option=3)
    growth_rate = tunable([0.03, 0.05, 0.07], current_option=0.05)

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    ratio = item / bins[valid]
    # Using a sigmoid function for fit
    spatial_fit[valid] = 1 / (1 + np.exp(-10 * (ratio - target_ratio)))
    spatial_fit_score = (1 - np.abs(ratio - target_ratio)) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.4, 0.45, 0.5], current_option=0.45) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.25, 0.3], current_option=0.25)))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization)) ** tunable([2, 3], current_option=2)

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + growth_rate * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.12, 0.15], current_option=0.12)

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > tunable([0.05, 0.08, 0.1], current_option=0.08), diversity_bonus, 0)

    # Calculate adaptability bonus
    adaptability_bonus = np.zeros(n_bins)
    future_item_range = np.linspace(item * 0.8, item * 1.2, tunable([5, 10, 15], current_option=10))
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            adaptability = 0
            for future_item in future_item_range:
                future_remaining = simulated_bins - future_item
                adaptability += np.sum(future_remaining > 0) / len(future_remaining)
            adaptability_bonus[i] = adaptability / len(future_item_range)
    adaptability_bonus = adaptability_bonus_weight * (adaptability_bonus / np.max(adaptability_bonus))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        adaptability_bonus
    )

    # Dynamic weight adjustment based on current bin state
    current_avg_utilization = np.mean(utilization)
    if current_avg_utilization > tunable([0.7, 0.75], current_option=0.7):
        utilization_weight = tunable([0.4, 0.45], current_option=0.45)
        fragmentation_penalty_weight = tunable([0.15, 0.2], current_option=0.15)
    else:
        utilization_weight = tunable([0.35, 0.4], current_option=0.35)
        fragmentation_penalty_weight = tunable([0.1, 0.12], current_option=0.1)

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 97
-------------------


................................................................
launch 1 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 1.0; measure cnt: 1
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.2, 0.3, 0.4])
    fragmentation_penalty_weight = tunable([0.03, 0.05, 0.07])
    diversity_bonus_weight = tunable([0.03, 0.05, 0.07])
    
    target_ratio_base = tunable([0.5, 0.6, 0.7])
    target_ratio_adjustment = tunable([0.05, 0.1, 0.15])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * target_ratio_adjustment
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold_coeff = tunable([0.1, 0.15, 0.2])
    fragmentation_threshold = fragmentation_threshold_coeff * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining_coeff = tunable([0.4, 0.5, 0.6])
    target_remaining = target_remaining_coeff * bins
    decay_factor = tunable([0.15, 0.2, 0.25])
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * decay_factor))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = tunable([1, 2, 3, 4])
    lookahead_scaling = tunable([0.03, 0.05, 0.07])
    next_item_sizes = [item * (1 + lookahead_scaling * i) for i in range(1, lookahead_depth + 1)]
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.05, 0.1, 0.15])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 98
-------------------



launch 64 evaluate tasks
this best socre: -209.0; best score: -209.0; global score: -208.1; space size: 6377292; measure cnt: 64

launch 64 evaluate tasks
this best socre: -209.0; best score: -209.0; global score: -208.1; space size: 6377292; measure cnt: 128

launch 64 evaluate tasks
this best socre: -209.0; best score: -209.0; global score: -208.1; space size: 6377292; measure cnt: 192

launch 64 evaluate tasks
this best socre: -209.0; best score: -209.0; global score: -208.1; space size: 6377292; measure cnt: 256
sampler suggest should end sample, break
request...
-----------------------request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with multiple options
    spatial_fit_weight = 0.9
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.1
    balance_bonus_weight = 0.05

    target_ratio_base = 0.7
    item_influence = 0.15
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_influence
    ideal_utilization = 0.9
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.45 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization)) ** 3

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes and adaptability
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    growth_rates = 0.05
    next_item_sizes = [item * (1 + growth_rates * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > 0.12, diversity_bonus, 0)

    # Calculate balance bonus to encourage even bin usage
    balance_bonus = balance_bonus_weight * np.exp(-np.abs(remaining - np.mean(remaining)) / (np.std(remaining) + 1e-8))
    balance_bonus = np.where(np.std(remaining) > 0.15, balance_bonus, 0)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Apply dynamic weight adjustment based on current bin state
    current_utilization = np.mean(utilization)
    if current_utilization > 0.8:
        utilization_weight = 0.5
        fragmentation_penalty_weight = 0.3
    else:
        utilization_weight = 0.35
        fragmentation_penalty_weight = 0.25

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

request...
-----------------------

-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.7
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.1
    lookahead_depth = 2
    target_ratio_base = 0.6
    item_size_factor = 0.15
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.15
    diversity_threshold = 0.15

    # Calculate spatial fit score with dynamic target ratio
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.6 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.15))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    growth_factor = 0.03
    next_item_sizes = [item * (1 + growth_factor * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.75
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.1
    balance_bonus_weight = 0.1
    lookahead_depth = 5
    adaptability_threshold = 0.3

    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.2 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.45 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**3

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes and adaptability
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.03 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.12

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > 0.08, diversity_bonus, 0)

    # Calculate future adaptability score
    adaptability_scores = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            # Generate a range of possible future item sizes
            future_item_range = np.linspace(item * 0.8, item * 1.2, 10)
            adaptability = 0
            for future_item in future_item_range:
                future_remaining = simulated_bins - future_item
                adaptability += np.sum(future_remaining > 0) / len(future_remaining)
            adaptability_scores[i] = adaptability / len(future_item_range)
    adaptability_bonus = 0.05 * (adaptability_scores / np.max(adaptability_scores))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        adaptability_bonus
    )

    # Apply dynamic weight adjustment based on current bin state
    current_utilization = np.mean(utilization)
    if current_utilization > 0.7:
        utilization_weight = 0.45
        fragmentation_penalty_weight = 0.25
    else:
        utilization_weight = 0.4
        fragmentation_penalty_weight = 0.15

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


-----------------------
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.7
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.1
    lookahead_depth = 2
    target_ratio_base = 0.6
    item_size_factor = 0.15
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.15
    diversity_threshold = 0.15

    # Calculate spatial fit score with dynamic target ratio
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.6 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.15))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    growth_factor = 0.03
    next_item_sizes = [item * (1 + growth_factor * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
request...
-----------------------request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.7
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.1
    lookahead_depth = 2
    target_ratio_base = 0.6
    item_size_factor = 0.15
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.15
    diversity_threshold = 0.15

    # Calculate spatial fit score with dynamic target ratio
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.6 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.15))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    growth_factor = 0.03
    next_item_sizes = [item * (1 + growth_factor * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.


import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = 0.7
    future_potential_weight = 0.7
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.15
    diversity_bonus_weight = 0.1
    lookahead_depth = 2
    balance_bonus_weight = 0.05
    target_ratio_base = 0.55
    item_size_factor = 0.2
    ideal_utilization = 0.9
    fragmentation_threshold_ratio = 0.1
    diversity_threshold = 0.05

    # Calculate target ratio dynamically based on item size relative to mean bin capacity
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor

    # Spatial fit score calculation
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Future potential score calculation with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Utilization score calculation with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization)) ** 2

    # Fragmentation penalty calculation
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Diversity bonus calculation
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Balance bonus calculation
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = balance_bonus_weight * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine all scores into priority
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with multiple options
    spatial_fit_weight = 0.9
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.1
    balance_bonus_weight = 0.05

    target_ratio_base = 0.7
    item_influence = 0.15
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_influence
    ideal_utilization = 0.9
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.45 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.25))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization)) ** 3

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes and adaptability
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    growth_rates = 0.05
    next_item_sizes = [item * (1 + growth_rates * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > 0.12, diversity_bonus, 0)

    # Calculate balance bonus to encourage even bin usage
    balance_bonus = balance_bonus_weight * np.exp(-np.abs(remaining - np.mean(remaining)) / (np.std(remaining) + 1e-8))
    balance_bonus = np.where(np.std(remaining) > 0.15, balance_bonus, 0)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Apply dynamic weight adjustment based on current bin state
    current_utilization = np.mean(utilization)
    if current_utilization > 0.8:
        utilization_weight = 0.5
        fragmentation_penalty_weight = 0.3
    else:
        utilization_weight = 0.35
        fragmentation_penalty_weight = 0.25

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.
-----------------------
-----------------------

request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = 0.7
    future_potential_weight = 0.7
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.15
    diversity_bonus_weight = 0.1
    lookahead_depth = 2
    balance_bonus_weight = 0.05
    target_ratio_base = 0.55
    item_size_factor = 0.2
    ideal_utilization = 0.9
    fragmentation_threshold_ratio = 0.1
    diversity_threshold = 0.05

    # Calculate target ratio dynamically based on item size relative to mean bin capacity
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor

    # Spatial fit score calculation
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Future potential score calculation with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Utilization score calculation with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization)) ** 2

    # Fragmentation penalty calculation
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Diversity bonus calculation
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Balance bonus calculation
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = balance_bonus_weight * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine all scores into priority
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with strategic options
    spatial_fit_weight = 0.8
    future_potential_weight = 0.5
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.1
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.7
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.2
    ideal_utilization = 0.8
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.6 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 4
    lookahead_bonus = np.zeros(n_bins)
    # Simulate future items with varying sizes based on current item
    next_item_sizes = [item * (1 + 0.02 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.05

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------

-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters with tunable wrapper
    spatial_fit_weight = tunable([0.7, 0.6, 0.8])
    future_potential_weight = tunable([0.6, 0.5, 0.7])
    utilization_weight = tunable([0.3, 0.25, 0.35])
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.075])
    
    target_ratio_base = tunable([0.6, 0.55, 0.65])
    item_size_factor = tunable([0.1, 0.15, 0.2])
    ideal_utilization = tunable([0.85, 0.8, 0.9])
    fragmentation_threshold_ratio = tunable([0.15, 0.2, 0.1])
    diversity_threshold = tunable([0.15, 0.2, 0.1])
    
    lookahead_depth = tunable([2, 3, 1])
    growth_factor = tunable([0.03, 0.05, 0.02])

    # Calculate dynamic target ratio based on item size relative to bins
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor
    target_ratio = np.clip(target_ratio, 0.5, 0.8)  # Ensure reasonable range

    # Spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Future potential score with adaptive target remaining
    target_remaining = tunable([0.5, 0.6, 0.4]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.15, 0.2, 0.1])))
    future_potential_score = future_potential * future_potential_weight

    # Utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Fragmentation penalty with tunable threshold
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + growth_factor * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.1, 0.15, 0.05])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 99
-------------------



current thread_i 4
launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 14348907; measure cnt: 64

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 14348907; measure cnt: 128

launch 64 evaluate tasks
this best socre: -10000000000.0; best score: -10000000000.0; global score: -208.1; space size: 14348907; measure cnt: 192
sampler suggest should end sample, break
request...
-----------------------

import numpy as np


def priority_v0(item: float, bins: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins: Array of capacities for each bin.

    Return:
        Array of same size as bins with priority score of each bin.
    """
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead.
    
    This function calculates the priority score for placing an item into each bin,
    considering spatial fit, future potential, utilization, fragmentation, diversity,
    lookahead, and balance.
    
    Args:
        item: Size of the item to be placed.
        bins: Array of current bin capacities.
    
    Returns:
        Array of priority scores, lower scores indicate higher priority.
    """
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.8
    future_potential_weight = 0.6
    utilization_weight = 0.35
    fragmentation_penalty_weight = 0.15
    diversity_bonus_weight = 0.05
    balance_bonus_weight = 0.08
    lookahead_depth = 4
    
    target_ratio = 0.5
    target_remaining_ratio = 0.45
    ideal_utilization = 0.85
    fragmentation_threshold_ratio = 0.2
    diversity_threshold = 0.1

    # Calculate spatial fit score
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit**2) * spatial_fit_weight  # Quadratic fit

    # Calculate future potential score
    target_remaining = target_remaining_ratio * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))
    utilization_score = utilization_weight * (1 / (1 + np.exp(-10*(utilization - ideal_utilization))))  # Sigmoid

    # Calculate fragmentation penalty
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            future_items = [item * (1 + j*0.05) for j in range(lookahead_depth)]
            future_valid = np.zeros(lookahead_depth)
            for j, future_item in enumerate(future_items):
                future_remaining = simulated_bins - future_item
                future_valid[j] = np.sum(future_remaining > 0)
            lookahead_bonus[i] = np.mean(future_valid) * 0.15

    # Calculate diversity bonus
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > diversity_threshold, diversity_bonus, 0)

    # Calculate distribution balance bonus
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = 0.2 * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v0`."""
    """Advanced priority strategy for online bin-packing with dynamic adjustments and novel metrics."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = 0.7
    future_potential_weight = 0.6
    utilization_weight = 0.3
    fragmentation_penalty_weight = 0.05
    diversity_bonus_weight = 0.05
    
    target_ratio_base = 0.6
    target_ratio = target_ratio_base + (item / np.mean(bins)) * 0.1
    ideal_utilization = 0.85
    fragmentation_threshold = 0.15 * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = 2
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities


def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:
    """Improved version of `priority_v1`."""



Create an improved Python function for online bin-packing that demonstrates:
Novel priority strategy: Propose a smarter item-bin matching approach considering both spatial fit and future packing potential
Parameter tuning points: Clearly mark tuning parameters using tunable([option1, option2, ...]) wrapper. Example:
`if remaining_capacity > tunable([0.2, 0.5]):`
`sorted(items, key=lambda x: tunable([x.size, x.weight]))`
Focus first on strategic innovation, then expose tuning parameters through tunable([option1, option2, ...]) calls. Keep implementation practical but non-trivial.
Things you should also focus on:
1.You can try a lot of functions and check the answers, however, the final functions you provide for me should be the best ones.
2.You can break the traditional thinking and try new ideas. To achieve this goal, you can note the disadvantages of existing traditional algorithms, and try to improve them in the functions you generate.
3.You can break the problem down into iteratively optimized submodules, then try to improve the performance of each submodule.
4.You can merge the strategies of multiple algorithms, and try to improve the performance of the functions you generate by combining the advantages of multiple algorithms.
You can try any possible methods as long as they are correct and reasonable.

-----------------------
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments and lookahead."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.6, 0.7, 0.8])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.1, 0.15, 0.2])
    diversity_bonus_weight = tunable([0.05, 0.1, 0.15])
    lookahead_depth = tunable([2, 3, 4])
    target_ratio_base = tunable([0.55, 0.6, 0.65])
    item_size_factor = tunable([0.1, 0.15, 0.2])
    ideal_utilization = tunable([0.85, 0.9, 0.95])
    fragmentation_threshold_ratio = tunable([0.1, 0.15, 0.2])
    balance_bonus_weight = tunable([0.03, 0.05, 0.07])

    # Calculate target ratio dynamically based on item size relative to mean bin capacity
    target_ratio = target_ratio_base + (item / np.mean(bins)) * item_size_factor

    # Spatial fit score calculation
    spatial_fit = np.full_like(bins, np.nan)
    valid = valid_bins
    spatial_fit[valid] = np.abs(item / bins[valid] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Future potential score calculation with adaptive target remaining
    target_remaining = 0.5 * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * 0.2))
    future_potential_score = future_potential * future_potential_weight

    # Utilization score calculation with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization)) ** 2

    # Fragmentation penalty calculation
    fragmentation_threshold = fragmentation_threshold_ratio * bins
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic
    lookahead_bonus = np.zeros(n_bins)
    next_item_sizes = [item * (1 + 0.05 * i) for i in range(1, lookahead_depth + 1)]
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * 0.1

    # Diversity bonus calculation
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)
    diversity_bonus = np.where(np.std(bins) > tunable([0.03, 0.05, 0.07]), diversity_bonus, 0)

    # Balance bonus calculation
    balance_bonus = np.zeros(n_bins)
    current_distribution = bins / bins.sum()
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            simulated_distribution = simulated_bins / simulated_bins.sum()
            balance_bonus[i] = balance_bonus_weight * (1 - np.abs(current_distribution[i] - simulated_distribution[i]))

    # Combine all scores into priority
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus +
        balance_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 100
-------------------



current thread_i 1
launch 64 evaluate tasks
current thread_i 5
current thread_i 6
current thread_i 0
this best socre: -208.1; best score: -208.1; global score: -208.1; space size: 531441; measure cnt: 64

launch 64 evaluate tasks
current thread_i 7
current thread_i 2
current thread_i 8
current thread_i 9
this best socre: -208.1; best score: -208.1; global score: -208.1; space size: 531441; measure cnt: 128

launch 64 evaluate tasks
this best socre: -208.1; best score: -208.1; global score: -208.1; space size: 531441; measure cnt: 192

launch 64 evaluate tasks
current thread_i 4
this best socre: -208.1; best score: -208.1; global score: -208.1; space size: 531441; measure cnt: 256
sampler suggest should end sample, break
-------------------
    """Advanced priority strategy for online bin-packing with dynamic adjustments."""
    remaining = bins - item
    valid_bins = remaining > 0
    n_bins = len(bins)
    priorities = np.zeros(n_bins, dtype=np.float64)

    # Tunable parameters
    spatial_fit_weight = tunable([0.7, 0.8, 0.9])
    future_potential_weight = tunable([0.5, 0.6, 0.7])
    utilization_weight = tunable([0.3, 0.4, 0.5])
    fragmentation_penalty_weight = tunable([0.05, 0.1, 0.15])
    diversity_bonus_weight = tunable([0.03, 0.05, 0.07])
    
    target_ratio_base = tunable([0.6, 0.7, 0.8])
    target_ratio = target_ratio_base + (item / np.mean(bins)) * tunable([0.1, 0.2, 0.3])
    ideal_utilization = tunable([0.8, 0.85, 0.9])
    fragmentation_threshold = tunable([0.1, 0.15, 0.2]) * bins

    # Calculate spatial fit score with dynamic target ratio
    spatial_fit = np.full_like(bins, np.nan)
    spatial_fit[valid_bins] = np.abs(item / bins[valid_bins] - target_ratio)
    spatial_fit_score = (1 - spatial_fit) * spatial_fit_weight

    # Calculate future potential score with adaptive target remaining
    target_remaining = tunable([0.5, 0.6, 0.7]) * bins
    future_potential = np.exp(-np.abs(remaining - target_remaining) / (bins * tunable([0.2, 0.3])))
    future_potential_score = future_potential * future_potential_weight

    # Calculate utilization score with smoother transition
    utilization = (bins - remaining) / bins
    utilization_score = utilization_weight * (1 - np.abs(utilization - ideal_utilization))**2

    # Calculate fragmentation penalty with tunable threshold
    fragmentation_penalty = np.where(
        remaining < fragmentation_threshold,
        fragmentation_penalty_weight * (1 - (remaining / bins)),
        0
    )

    # Enhanced lookahead heuristic with dynamic item sizes
    lookahead_depth = tunable([2, 3, 4])
    lookahead_bonus = np.zeros(n_bins)
    growth_rates = tunable([0.02, 0.05, 0.1])
    next_item_sizes = [item * (1 + growth_rates * i) for i in range(1, lookahead_depth + 1)]
    
    for i in range(n_bins):
        if valid_bins[i]:
            simulated_bins = bins.copy()
            simulated_bins[i] -= item
            total_future_valid = 0
            for next_size in next_item_sizes:
                future_remaining = simulated_bins - next_size
                total_future_valid += np.sum(future_remaining > 0)
            lookahead_bonus[i] = total_future_valid * tunable([0.05, 0.1])

    # Calculate diversity bonus based on priority distribution
    diversity_bonus = diversity_bonus_weight * np.std(priorities)
    diversity_bonus = np.full_like(priorities, diversity_bonus)

    # Combine metrics into priority score
    priorities = (
        spatial_fit_score +
        future_potential_score +
        utilization_score +
        fragmentation_penalty +
        lookahead_bonus +
        diversity_bonus
    )

    # Ensure invalid bins have infinite priority (lowest preference)
    priorities[~valid_bins] = float('inf')

    return priorities

call llm times: 101
-------------------



launch 64 evaluate tasks
this best socre: -208.9; best score: -208.9; global score: -208.1; space size: 2125764; measure cnt: 64
...................
launch 64 evaluate tasks
this best socre: -208.9; best score: -208.9; global score: -208.1; space size: 2125764; measure cnt: 128
.......................................
launch 64 evaluate tasks
